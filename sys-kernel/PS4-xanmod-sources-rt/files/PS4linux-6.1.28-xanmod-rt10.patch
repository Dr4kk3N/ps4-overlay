--- linux-6.1.13-xanmod-rt7/arch/x86/Kconfig	2023-05-10 20:56:43.894287754 +0200
+++ linux-6.1.13-PS4-rt7/arch/x86/Kconfig	2023-04-17 23:37:25.892080876 +0200
@@ -563,6 +563,30 @@
 	  enable more than ~168 cores.
 	  If you don't have one of these, you should say N here.
 
+config X86_PS4
+       bool "Sony PlayStation 4"
+       depends on X86_64
+       depends on X86_EXTENDED_PLATFORM
+       depends on PCI
+       help
+         Select to include support for the Sony PlayStation 4 game console.
+
+
+choice
+       prompt "Platform:" if X86_PS4
+       default X86_PS4_AEOLIA_BELIZE
+       depends on X86_64
+    depends on X86_EXTENDED_PLATFORM
+    depends on PCI
+       help
+         Select the desired ps4 platform to build this kernel for.
+
+       config X86_PS4_AEOLIA_BELIZE
+               bool "aeolia/belize"
+       config X86_PS4_BAIKAL
+               bool "baikal"
+endchoice
+
 config X86_VSMP
 	bool "ScaleMP vSMP"
 	select HYPERVISOR_GUEST
--- linux-6.1.13-xanmod-rt7/arch/x86/include/asm/ps4.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/include/asm/ps4.h	2023-04-17 23:37:25.894080925 +0200
@@ -0,0 +1,60 @@
+/*
+ * ps4.h: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_PS4_H
+#define _ASM_X86_PS4_H
+
+#ifdef CONFIG_X86_PS4
+
+#include <linux/irqdomain.h>
+
+#define PS4_DEFAULT_TSC_FREQ 1594000000
+
+#define EMC_TIMER_BASE 0xd0281000
+#define EMC_TIMER_VALUE 0x28
+
+extern unsigned long ps4_calibrate_tsc(void);
+
+/*
+ * The PS4 Aeolia southbridge device is a composite device containing some
+ * standard-ish, some not-so-standard, and some completely custom functions,
+ * all using special MSI handling. This function does the equivalent of
+ * pci_enable_msi_range and friends, for those devices. Only works after the
+ * Aeolia MSR routing function device (function 4) has been probed.
+ * Returns 1 or count, depending on IRQ allocation constraints, or negative on
+ * error. Assigned IRQ(s) start at dev->irq.
+ */
+extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int apcie_status(void);
+extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
+
+#else
+
+static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+static inline void apcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+static inline int apcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
+#endif
+#endif
--- linux-6.1.13-xanmod-rt7/arch/x86/include/asm/setup.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/include/asm/setup.h	2023-04-17 23:37:25.894080925 +0200
@@ -66,6 +66,12 @@
 static inline void x86_ce4100_early_setup(void) { }
 #endif
 
+#ifdef CONFIG_X86_PS4
+extern void x86_ps4_early_setup(void);
+#else
+static inline void x86_ps4_early_setup(void) { }
+#endif
+
 #ifndef _SETUP
 
 #include <asm/espfix.h>
--- linux-6.1.13-xanmod-rt7/arch/x86/include/asm/irqdomain.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/include/asm/irqdomain.h	2023-04-17 23:37:25.893080901 +0200
@@ -14,6 +14,7 @@
 
 extern int x86_fwspec_is_ioapic(struct irq_fwspec *fwspec);
 extern int x86_fwspec_is_hpet(struct irq_fwspec *fwspec);
+extern int x86_fwspec_is_aeolia(struct irq_fwspec *fwspec);
 
 extern struct irq_domain *x86_vector_domain;
 
--- linux-6.1.13-xanmod-rt7/arch/x86/include/uapi/asm/bootparam.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/include/uapi/asm/bootparam.h	2023-04-17 23:37:25.895080950 +0200
@@ -276,6 +276,7 @@
 	X86_SUBARCH_XEN,
 	X86_SUBARCH_INTEL_MID,
 	X86_SUBARCH_CE4100,
+	X86_SUBARCH_PS4,
 	X86_NR_SUBARCHS,
 };
 
--- linux-6.1.13-xanmod-rt7/arch/x86/kernel/amd_nb.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/kernel/amd_nb.c	2023-04-17 23:37:25.896080974 +0200
@@ -66,6 +66,7 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
@@ -88,6 +89,7 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F4) },
--- linux-6.1.13-xanmod-rt7/arch/x86/kernel/apic/apic.c	2023-05-10 20:56:43.931287928 +0200
+++ linux-6.1.13-PS4-rt7/arch/x86/kernel/apic/apic.c	2023-04-17 23:37:25.897080999 +0200
@@ -2581,6 +2581,13 @@
 		msg->arch_addr_lo.virt_destid_8_14 = cfg->dest_apicid >> 8;
 	else
 		WARN_ON_ONCE(cfg->dest_apicid > 0xFF);
+
+       pr_info("apcie_irq_msi_compose_msg %x %x %x %x %x\n", msg->data,
+               msg->address_hi,
+               msg->arch_addr_lo.base_address,
+               msg->arch_addr_lo.destid_0_7,
+               cfg->vector);
+
 }
 
 u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid)
--- linux-6.1.13-xanmod-rt7/arch/x86/kernel/head64.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/kernel/head64.c	2023-04-17 23:37:25.899081048 +0200
@@ -549,6 +549,9 @@
 	case X86_SUBARCH_INTEL_MID:
 		x86_intel_mid_early_setup();
 		break;
+	case X86_SUBARCH_PS4:
+                x86_ps4_early_setup();
+                break;
 	default:
 		break;
 	}
--- linux-6.1.13-xanmod-rt7/arch/x86/platform/Makefile	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/platform/Makefile	2023-04-17 23:37:25.901081097 +0200
@@ -9,6 +9,7 @@
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
 obj-y	+= olpc/
+obj-y   += ps4/
 obj-y	+= scx200/
 obj-y	+= ts5500/
 obj-y	+= uv/
--- linux-6.1.13-xanmod-rt7/arch/x86/kernel/apic/vector.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/kernel/apic/vector.c	2023-04-17 23:37:25.898081023 +0200
@@ -676,6 +676,15 @@
 	return 0;
 }
 
+int x86_fwspec_is_aeolia(struct irq_fwspec *fwspec)
+{
+       if (is_fwnode_irqchip(fwspec->fwnode)) {
+               const char *fwname = fwnode_get_name(fwspec->fwnode);
+               return fwname && !strncmp(fwname, "Aeolia-MSI", 10);
+       }
+       return 0;
+}
+
 static int x86_vector_select(struct irq_domain *d, struct irq_fwspec *fwspec,
 			     enum irq_domain_bus_token bus_token)
 {
@@ -687,7 +696,7 @@
 	if (apic->apic_id_valid(32768))
 		return 0;
 
-	return x86_fwspec_is_ioapic(fwspec) || x86_fwspec_is_hpet(fwspec);
+	return x86_fwspec_is_ioapic(fwspec) || x86_fwspec_is_hpet(fwspec) || x86_fwspec_is_aeolia(fwspec);
 }
 
 static const struct irq_domain_ops x86_vector_domain_ops = {
--- linux-6.1.13-xanmod-rt7/arch/x86/mm/init_64.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/mm/init_64.c	2023-05-19 02:21:54.447753932 +0200
@@ -1368,8 +1368,15 @@
 
 int kernel_set_to_readonly;
 
+//static int first = true;
+//void icc_do_pulse_orange_with_white(void);
 void mark_rodata_ro(void)
 {
+  /*  if(first) {
+        first = false;
+        icc_do_pulse_orange_with_white();
+    }
+*/
 	unsigned long start = PFN_ALIGN(_text);
 	unsigned long rodata_start = PFN_ALIGN(__start_rodata);
 	unsigned long end = (unsigned long)__end_rodata_hpage_align;
--- linux-6.1.13-xanmod-rt7/arch/x86/platform/ps4/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/platform/ps4/Makefile	2023-04-17 23:37:25.902081121 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_X86_PS4) += ps4.o calibrate.o
--- linux-6.1.13-xanmod-rt7/arch/x86/platform/ps4/calibrate.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/platform/ps4/calibrate.c	2023-04-17 23:37:25.903081146 +0200
@@ -0,0 +1,116 @@
+/*
+ * calibrate.c: Sony PS4 TSC/LAPIC calibration
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+#include <asm/delay.h>
+#include <asm/apic.h>
+
+/* The PS4 southbridge (Aeolia) has an EMC timer that ticks at 32.768kHz,
+ * which seems to be an appropriate clock reference for calibration. Both TSC
+ * and the LAPIC timer are based on the core clock frequency and thus can be
+ * calibrated together. */
+static void __iomem *emc_timer = NULL;
+
+static __init inline u32 emctimer_read32(unsigned int reg)
+{
+	return ioread32(emc_timer + reg);
+}
+
+static __init inline void emctimer_write32(unsigned int reg, u32 val)
+{
+	iowrite32(val, emc_timer + reg);
+}
+
+static __init inline u32 emctimer_read(void)
+{
+	u32 t1, t2;
+	t1 = emctimer_read32(EMC_TIMER_VALUE);
+	while (1) {
+		t2 = emctimer_read32(EMC_TIMER_VALUE);
+		if (t1 == t2)
+			return t1;
+		t1 = t2;
+	}
+}
+
+static __init unsigned long ps4_measure_tsc_freq(void)
+{
+	unsigned long ret = 0;
+	u32 t1, t2;
+	u64 tsc1, tsc2;
+
+	// This is part of the Aeolia pcie device, but it's too early to
+	// do this in a driver.
+	emc_timer = ioremap(EMC_TIMER_BASE, 0x100);
+	if (!emc_timer)
+		goto fail;
+
+	// reset/start the timer
+	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	// udelay is not calibrated yet, so this is likely wildly off, but good
+	// enough to work.
+	udelay(300);
+	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
+	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+
+	t1 = emctimer_read();
+	tsc1 = tsc2 = rdtsc();
+
+	while (emctimer_read() == t1) {
+		// 0.1s timeout should be enough
+		tsc2 = rdtsc();
+		if ((tsc2 - tsc1) > (PS4_DEFAULT_TSC_FREQ/10)) {
+			pr_warn("EMC timer is broken.\n");
+			goto fail;
+		}
+	}
+	pr_info("EMC timer started in %lld TSC ticks\n", tsc2 - tsc1);
+
+	// Wait for a tick boundary
+	t1 = emctimer_read();
+	while ((t2 = emctimer_read()) == t1);
+	tsc1 = rdtsc();
+
+	// Wait for 1024 ticks to elapse (31.25ms)
+	// We don't need to wait very long, as we are looking for transitions.
+	// At this value, a TSC uncertainty of ~50 ticks corresponds to 1ppm of
+	// clock accuracy.
+	while ((emctimer_read() - t2) < 1024);
+	tsc2 = rdtsc();
+
+	// TSC rate is 32 times the elapsed time
+	ret = (tsc2 - tsc1) * 32;
+
+	pr_info("Calibrated TSC frequency: %ld kHz\n", ret);
+fail:
+	if (emc_timer) {
+		iounmap(emc_timer);
+		emc_timer = NULL;
+	}
+	return ret;
+}
+
+unsigned long __init ps4_calibrate_tsc(void)
+{
+	unsigned long tsc_freq = ps4_measure_tsc_freq();
+
+	if (!tsc_freq) {
+		pr_warn("Unable to measure TSC frequency, assuming default.\n");
+		tsc_freq = PS4_DEFAULT_TSC_FREQ;
+	}
+
+	lapic_timer_period = (tsc_freq + 8 * HZ) / (16 * HZ);
+
+	return (tsc_freq + 500) / 1000;
+}
--- linux-6.1.13-xanmod-rt7/arch/x86/platform/ps4/ps4.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/arch/x86/platform/ps4/ps4.c	2023-04-17 23:37:25.903081146 +0200
@@ -0,0 +1,74 @@
+/*
+ * ps4.c: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/reboot.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+
+static bool is_ps4;
+bool apcie_initialized;
+
+/*
+ * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * an RTC class device; stub these out.
+ */
+static void dummy_get_wallclock(struct timespec64 *now)
+{
+	now->tv_sec = now->tv_nsec = 0;
+}
+static int dummy_set_wallclock(const struct timespec64 *now)
+{
+	return -ENODEV;
+}
+
+/*
+ * Provide a way for generic drivers to query for the availability of the
+ * PS4 apcie driver/device, which is a dependency for them.
+ */
+int apcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return apcie_initialized;
+}
+EXPORT_SYMBOL_GPL(apcie_status);
+
+void icc_reboot(void);
+
+/*
+ * PS4 specific x86_init function overrides and early setup calls.
+ */
+void __init x86_ps4_early_setup(void)
+{
+	pr_info("x86_ps4_early_setup: PS4 early setup\n");
+	is_ps4 = true;
+	x86_platform.calibrate_tsc = ps4_calibrate_tsc;
+	x86_platform.get_wallclock = dummy_get_wallclock;
+	x86_platform.set_wallclock = dummy_set_wallclock;
+
+	legacy_pic = &null_legacy_pic;
+	machine_ops.emergency_restart = icc_reboot;
+}
--- linux-6.1.13-xanmod-rt7/drivers/Makefile	2023-05-10 20:56:43.979288154 +0200
+++ linux-6.1.13-PS4-rt7/drivers/Makefile	2023-04-17 23:37:25.904081170 +0200
@@ -86,6 +86,7 @@
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-$(CONFIG_HSI)		+= hsi/
 obj-$(CONFIG_SLIMBUS)		+= slimbus/
+obj-$(CONFIG_X86_PS4)           += ps4/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
--- linux-6.1.13-xanmod-rt7/drivers/ata/ahci.c	2023-05-10 20:56:43.998288244 +0200
+++ linux-6.1.13-PS4-rt7/drivers/ata/ahci.c	2023-04-26 02:50:40.864138649 +0200
@@ -34,6 +34,10 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
 
@@ -44,6 +48,7 @@
 	AHCI_PCI_BAR_ENMOTUS	= 2,
 	AHCI_PCI_BAR_CAVIUM_GEN5	= 4,
 	AHCI_PCI_BAR_STANDARD	= 5,
+	
 };
 
 enum board_ids {
@@ -615,6 +620,11 @@
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Sony (PS4) */
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_AEOLIA_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BELIZE_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BAIKAL_AHCI), board_ahci },
+
 	/* Loongson */
 	{ PCI_VDEVICE(LOONGSON, 0x7a08), board_ahci },
 
@@ -958,6 +968,23 @@
 	if (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))
 		return 0;
 
+        #ifdef CONFIG_X86_PS4
+        if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+                rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(31));
+                if (rc) {
+                        dev_err(&pdev->dev, "31-bit DMA enable failed\n");
+                        return rc;
+                }
+                rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(31));
+                if (rc) {
+                        dev_err(&pdev->dev,
+                                "31-bit consistent DMA enable failed\n");
+                        return rc;
+                }
+                return 0;
+        }
+        #endif
+
 	rc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_bits));
 	if (rc)
 		dev_err(&pdev->dev, "DMA enable failed\n");
@@ -1576,6 +1603,12 @@
 {
 	int nvec;
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		return apcie_assign_irqs(pdev, n_ports);
+	}
+	#endif
+
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1697,6 +1730,12 @@
 
 	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
 
+        #ifdef CONFIG_X86_PS4
+        /* This will return negative on non-PS4 platforms */
+        if (apcie_status() == 0)
+                return -EPROBE_DEFER;
+        #endif
+
 	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
@@ -1730,6 +1769,7 @@
 	} else if (pdev->vendor == PCI_VENDOR_ID_LOONGSON) {
 		if (pdev->device == 0x7a08)
 			ahci_pci_bar = AHCI_PCI_BAR_LOONGSON;
+
 	}
 
 	/* acquire resources */
@@ -1944,8 +1984,255 @@
 				     NULL);
 	pm_runtime_get_noresume(&pdev->dev);
 	ata_pci_remove_one(pdev);
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		apcie_free_irqs(pdev->irq, 1);
+	}
+#endif
+}
+
+#ifdef CONFIG_X86_PS4
+void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr)
+{
+	int i;
+	u32 v;
+	u32 v2;
+	bool is_phy_gen_3;
+	unsigned int trace_length;
+
+  dev_info(dev, "Belize SATA PHY init\n");
+
+	for (i = 0; i < 100; i++) {
+		udelay(10000);
+	}
+
+  //step 1
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x81);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff00) | 1);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xa5);
+
+  //step 2
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+
+  if (ctlr->dev_id == 0x90ca104d || ctlr->dev_id == 0x909f104d || ctlr->dev_id == 0x90d9104d) {
+    is_phy_gen_3 = false;
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xfffff3ff);
+  }else{
+    u32 v2 = bpcie_ahci_read(ctlr->r_mem, 0);
+    if ((v2 & 0xf00000) != 0x300000) {
+      bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x400);
+      is_phy_gen_3 = false;
+    }else{
+      dev_info(dev,"PHY SET GEN3\n");
+      bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x800);
+      is_phy_gen_3 = true;
+    }
+  }
+  //--- step 3 ---
+  if (ctlr->trace_len == 0) {
+    trace_length = 6;
+  }else{
+    trace_length = ctlr->trace_len & 0x1f;
+    if (trace_length >= 0x13) {
+      trace_length = 6;
+    }
+  }
+  dev_info(dev,"Belize SATA PHY Trace length : %d\n",trace_length);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xa3);
+
+  //--- step 4 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x800);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xd0);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff800) | 0x441);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xe1);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff8f) | 0x60);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xd0);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffff3fff) | 0x8000);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xf1);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x400);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x48);
+
+  //--- step 5 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, 0x62d8);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xe);
+
+  //--- step 6 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffdfff);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+  //--- step 7 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  if (trace_length >= 0xe) {
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x28);
+  }else{
+    if (trace_length < 0xb) {
+      bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 8);
+    }else{
+      bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x10);
+    }
+  }
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x12);
+
+  //--- step 8 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  if (trace_length < 5) {
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x24);
+  }else{
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x2a);
+  }
+
+  //--- step 9 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xff);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, 1);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x97);
+
+  //--- step 10 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  if (is_phy_gen_3) {
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff80) | 0xd3);
+  }else{
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff80) | 0xee);
+  }
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x95);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff00) | 0xee);
+
+  //--- step 11 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xff);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, 0);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+  //--- step 12 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  if (trace_length < 0xe){
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0x900);
+  }else{
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xe00);
+  }
+
+  //--- step 13 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff07f) | 0x900);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+
+  //--- step 14 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  if (is_phy_gen_3){
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xd00);
+  }else{
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xe80);
+  }
+
+  //--- step 15 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 200);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffefff);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 10);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffefff);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x82);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x1000);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xc9);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x1000);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x84);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc0) | 0xc);
+
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+  //--- step 16 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  v = v & 0xffff0fff;
+  if (trace_length < 0xe) {
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x8000);
+  }else{
+    bpcie_ahci_write(ctlr->r_mem, 0x17c, v);
+  }
+
+  //--- step 17 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+  bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffff0fff) | 0x8000);
+
+  //--- step 18 ---
+  bpcie_ahci_write(ctlr->r_mem, 0xa0, 0);
+  v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+  bpcie_ahci_write(ctlr->r_mem, 0xa4, v | 0x40);
+
+  //--- step 19 ---
+  if (ctlr->dev_id != 0x909f104d && ctlr->dev_id != 0x90ca104d && ctlr->dev_id != 0x90d9104d) {
+    v2 = 0x73000000;
+  }else{
+    v2 = 0x30000000;
+  }
+
+  //--- step 20 ---
+  bpcie_ahci_write(ctlr->r_mem, 0xa0, 4);
+  v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+  bpcie_ahci_write(ctlr->r_mem, 0xa4, (v & 0x88ffffff) | v2);
+
+  //--- step 21 ---
+  v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+
+  //--- step 22 ---
+	for (i = 0; i < 100; i++) {
+		udelay(10000);
+	}
+
+  //--- step 23 ---
+  bpcie_ahci_write(ctlr->r_mem, 0x178, 0xf9);
+  v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+
+  if (is_phy_gen_3) {
+    dev_info(dev,"Align 90=0x%02x\n",v & 0x7f);
+  }
+  //done!
 }
 
+EXPORT_SYMBOL_GPL(bpcie_sata_phy_init);
+#endif
+
 module_pci_driver(ahci_pci_driver);
 
 MODULE_AUTHOR("Jeff Garzik");
--- linux-6.1.13-xanmod-rt7/drivers/ata/ahci.h	2023-05-10 20:56:43.999288249 +0200
+++ linux-6.1.13-PS4-rt7/drivers/ata/ahci.h	2023-04-17 23:37:25.906081220 +0200
@@ -454,4 +454,30 @@
 	return (cap & 0x1f) + 1;
 }
 
+#ifdef CONFIG_X86_PS4
+struct f_resource{
+	u64 resource_i_ptr;
+	u64 r_bustag;
+	void __iomem * r_bushandle;
+};
+
+struct ahci_controller{
+	void *dev;
+	int dev_id;
+	struct f_resource *r_mem;
+	u32 trace_len;
+};
+
+void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr);
+
+static inline void bpcie_ahci_write(struct f_resource *r_mem, u32 offset, u32 val) {
+	iowrite32(val, r_mem->r_bushandle + offset);
+}
+
+static inline u32 bpcie_ahci_read(struct f_resource *r_mem, u32 offset) {
+		return ioread32(r_mem->r_bushandle + offset);
+}
+#endif
+
+
 #endif /* _AHCI_H */
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/Makefile	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/Makefile	2023-04-17 23:37:25.907081244 +0200
@@ -251,6 +251,7 @@
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
 amdgpu-$(CONFIG_HMM_MIRROR) += amdgpu_mn.o
+amdgpu-$(CONFIG_X86_PS4) += ps4_bridge.o
 
 include $(FULL_AMD_PATH)/pm/Makefile
 
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2023-05-10 20:56:44.121288826 +0200
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2023-04-17 23:37:25.908081269 +0200
@@ -278,6 +278,8 @@
 /* max cursor sizes (in pixels) */
 #define CIK_CURSOR_WIDTH 128
 #define CIK_CURSOR_HEIGHT 128
+#define LVP_CURSOR_WIDTH 64
+#define LVP_CURSOR_HEIGHT 64
 
 /* smart shift bias level limits */
 #define AMDGPU_SMARTSHIFT_MAX_BIAS (100)
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c	2023-04-17 23:37:25.909081293 +0200
@@ -1516,6 +1516,30 @@
 	.late_register = amdgpu_connector_late_register,
 };
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_get_modes(struct drm_connector *connector);
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
+
+
+static const struct drm_connector_helper_funcs amdgpu_ps4_dp_connector_helper_funcs = {
+	.get_modes = ps4_bridge_get_modes,
+	.mode_valid = ps4_bridge_mode_valid,
+	.best_encoder = amdgpu_connector_dvi_encoder,
+};
+
+static const struct drm_connector_funcs amdgpu_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = amdgpu_connector_set_property,
+	.destroy = amdgpu_connector_destroy,
+	.force = amdgpu_connector_dvi_force,
+};
+#endif
+
 static const struct drm_connector_funcs amdgpu_connector_edp_funcs = {
 	.dpms = drm_helper_connector_dpms,
 	.detect = amdgpu_connector_dp_detect,
@@ -1548,6 +1572,7 @@
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1595,6 +1620,16 @@
 	if (!amdgpu_connector)
 		return;
 
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &amdgpu_connector->base;
 
 	amdgpu_connector->connector_id = connector_id;
@@ -1649,12 +1684,22 @@
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
+			if (is_ps4_bridge) {
 			drm_connector_init_with_ddc(dev, &amdgpu_connector->base,
 						    &amdgpu_connector_dp_funcs,
 						    connector_type,
 						    ddc);
 			drm_connector_helper_add(&amdgpu_connector->base,
 						 &amdgpu_connector_dp_helper_funcs);
+			} else {
+			drm_connector_init(dev, &amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_funcs, connector_type);
+			drm_connector_helper_add(&amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_helper_funcs);
+						//&amdgpu_connector_dp_helper_funcs);
+
+
+			}
 			drm_object_attach_property(&amdgpu_connector->base.base,
 						      adev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c	2023-05-10 20:56:44.125288845 +0200
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c	2023-04-17 23:37:25.912081367 +0200
@@ -101,6 +101,8 @@
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
+	"GLADIUS",
 	"HAWAII",
 	"MULLINS",
 	"TOPAZ",
@@ -2098,6 +2100,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		if (adev->flags & AMD_IS_APU)
 			adev->family = AMDGPU_FAMILY_KV;
 		else
@@ -3327,6 +3331,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		/*
 		 * We have systems in the wild with these ASICs that require
 		 * VGA support which is not supported with DC.
@@ -4618,6 +4624,8 @@
 		case CHIP_KAVERI:
 		case CHIP_KABINI:
 		case CHIP_MULLINS:
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
 #endif
 		case CHIP_CARRIZO:
 		case CHIP_STONEY:
@@ -6087,6 +6095,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 #endif
 	case CHIP_TONGA:
 	case CHIP_FIJI:
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2023-05-10 20:56:44.127288855 +0200
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2023-04-17 23:37:25.913081391 +0200
@@ -51,6 +51,9 @@
 #include "amdgpu_xgmi.h"
 #include "amdgpu_reset.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
 /*
  * KMS wrapper.
  * - 3.0.0 - initial driver
@@ -1807,6 +1810,12 @@
 	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
+	/* liverpool */
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	/* gladius */
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|AMD_IS_APU},
 #endif
 	/* topaz */
 	{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},
@@ -2112,6 +2121,8 @@
 		case CHIP_HAWAII:
 		case CHIP_KABINI:
 		case CHIP_MULLINS:
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
 			dev_info(&pdev->dev,
 				 "CIK support provided by radeon.\n");
 			dev_info(&pdev->dev,
@@ -2137,6 +2148,16 @@
 	if (ret)
 		return ret;
 
+	#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+	#endif
+
 	pci_set_drvdata(pdev, ddev);
 
 	ret = amdgpu_driver_load_kms(adev, flags);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c	2023-04-17 23:37:25.914081416 +0200
@@ -32,6 +32,22 @@
 #include "atom.h"
 #include "atombios_encoders.h"
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void amdgpu_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 amdgpu_link_encoder_connector(struct drm_device *dev)
 {
@@ -49,6 +65,9 @@
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			amdgpu_encoder = to_amdgpu_encoder(encoder);
 			if (amdgpu_encoder->devices & amdgpu_connector->devices) {
+				#ifdef CONFIG_X86_PS4
+				amdgpu_maybe_add_bridge(connector, encoder);
+				#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 					amdgpu_atombios_encoder_init_backlight(amdgpu_encoder, connector);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c	2023-04-17 23:37:25.915081440 +0200
@@ -380,7 +380,8 @@
 		tmo_gfx = AMDGPU_IB_TEST_GFX_XGMI_TIMEOUT;
 	}
 
-	for (i = 0; i < adev->num_rings; ++i) {
+	//TODO test if this is needed now
+	for (i = 0; i < 1 /*adev->num_rings*/; ++i) {
 		struct amdgpu_ring *ring = adev->rings[i];
 		long tmo;
 
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c	2023-04-17 23:37:25.916081465 +0200
@@ -542,6 +542,8 @@
 	case CHIP_KABINI:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return AMDGPU_FW_LOAD_DIRECT;
 #endif
 	case CHIP_TOPAZ:
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/atombios_dp.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/atombios_dp.c	2023-04-17 23:37:25.917081489 +0200
@@ -258,12 +258,19 @@
 		amdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));
 	static const unsigned link_rates[3] = { 162000, 270000, 540000 };
 	unsigned max_link_rate = drm_dp_max_link_rate(dpcd);
+	unsigned min_lane_num = 1;
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct drm_device *dev = amdgpu_connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
 
+	/* Liverpool is always connected to an encoder that needs 4 lanes */
+	if (adev->asic_type == CHIP_LIVERPOOL)
+			min_lane_num = 4;
 	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==
 	    ENCODER_OBJECT_ID_NUTMEG) {
-		for (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {
+		for (lane_num = min_lane_num; lane_num <= max_lane_num; lane_num <<= 1) {
 			max_pix_clock = (lane_num * 270000 * 8) / bpp;
 			if (max_pix_clock >= pix_clock) {
 				*dp_lanes = lane_num;
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	2023-04-17 23:37:25.918081514 +0200
@@ -442,9 +442,11 @@
 	struct drm_connector *connector;
 	struct amdgpu_connector *amdgpu_connector;
 	struct amdgpu_connector_atom_dig *dig_connector;
-
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_device *adev = dev->dev_private;
 	/* dp bridges are always DP */
-	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE ||
+	adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/atombios_i2c.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/atombios_i2c.c	2023-04-17 23:37:25.919081538 +0200
@@ -31,7 +31,7 @@
 
 #define TARGET_HW_I2C_CLOCK 50
 
-/* these are a limitation of ProcessI2cChannelTransaction not the hw */
+/* these are a limitation of ProcessI2cChannelTransaction // ReadEDIDFromHWAssistedI2C not the hw */
 #define ATOM_MAX_HW_I2C_WRITE 3
 #define ATOM_MAX_HW_I2C_READ  255
 
@@ -42,7 +42,7 @@
 	struct drm_device *dev = chan->dev;
 	struct amdgpu_device *adev = drm_to_adev(dev);
 	PROCESS_I2C_CHANNEL_TRANSACTION_PS_ALLOCATION args;
-	int index = GetIndexIntoMasterTable(COMMAND, ProcessI2cChannelTransaction);
+	int index = GetIndexIntoMasterTable(COMMAND, ReadEDIDFromHWAssistedI2C);
 	unsigned char *base;
 	u16 out = cpu_to_le16(0);
 	int r = 0;
@@ -162,7 +162,7 @@
 void amdgpu_atombios_i2c_channel_trans(struct amdgpu_device *adev, u8 slave_addr, u8 line_number, u8 offset, u8 data)
 {
 	PROCESS_I2C_CHANNEL_TRANSACTION_PS_ALLOCATION args;
-	int index = GetIndexIntoMasterTable(COMMAND, ProcessI2cChannelTransaction);
+	int index = GetIndexIntoMasterTable(COMMAND, ReadEDIDFromHWAssistedI2C);
 
 	args.ucRegIndex = offset;
 	args.lpI2CDataOut = data;
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/cik.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/cik.c	2023-04-18 00:49:45.935821190 +0200
@@ -136,6 +136,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+        case CHIP_GLADIUS:
 		if (encode)
 			*codecs = &cik_video_codecs_encode;
 		else
@@ -824,6 +826,206 @@
 	0xc24d, 0xffffffff, 0x00000000
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+		0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+		0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+		0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+		0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+		0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+		0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+		0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+		0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+		0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+		0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+		0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+		0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+		0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+		0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+		0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0xf0a8, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0xf082, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0xf0b0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0xf0b2, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0xf0b1, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x1579, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf0a0, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0xf085, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0xf088, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0xf086, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0xf081, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0xf0b8, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0xf089, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0xf080, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0xf08c, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0xf08d, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0xf094, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0xf095, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0xf096, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0xf097, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0xf098, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0xf09f, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0xf09e, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0xf084, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0xf0a4, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0xf09d, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0xf0ad, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0xf0ac, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0xf09c, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	/* */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0xf008, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0xf009, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0xf00a, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0xf00b, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0xf00c, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0xf00d, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0xf00e, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0xf00f, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0xf010, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0xf011, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0xf012, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0xf013, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0xf014, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0xf015, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0xf016, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0xf017, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0xf018, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0xf019, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0xf01a, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0xf01b, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0xf01c, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0xf01d, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0xf01e, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0xf01f, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0xf020, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0xf021, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0xf022, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0xf023, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0xf024, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0xf025, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0xf026, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0xf027, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0xf028, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0xf029, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0xf02a, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0xf02b, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0xf02c, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0xf02d, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0xf02e, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0xf02f, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0xf030, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0xf031, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0xf032, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0xf033, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0xf034, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0xf035, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0xf036, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0xf037, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0xf038, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0xf039, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0xf000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x21c2, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0x3109, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x2684, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0xf000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0xf003, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0xf004, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x1579, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf080, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x1bb6, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x260d, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x16ec, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x263e, 0x73773777, 0x12011003, /* GB_ADDR_CONFIG */
+	0xbd2, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x2285, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x22fc, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x22c9, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0xc281, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0xa293, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0x30df, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x136, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0xf9e, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0x31da, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x2300, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x2542, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0x2b03, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
+static const u32 gladius_golden_common_registers[] =
+{
+	mmATC_MISC_CG, 0x000c0fc0, 0x000c0200,
+	mmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,	// 0x2684
+	mmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,
+	mmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,
+	mmDB_DEBUG2, 0xf00fffff, 0x00000400,
+	mmPA_SC_ENHANCE, 0xffffffff, 0x20000001,
+	mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,
+	mmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,
+	mmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0020003c, //0x0001003c,
+	0xec9d, 0xffffffff, 0x0001003c,//mmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,
+	mmSQ_CONFIG, 0x07f80000, 0x07180000,
+	mmTA_CNTL_AUX, 0x000f000f, 0x000b0000,
+	mmTCC_CTRL, 0x00100000, 0xf31fff7f,
+	mmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,
+	mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,
+	mmVGT_RESET_DEBUG, 0x00000004, 0x00000004,
+	mmDCI_CLK_CNTL, 0x00000080, 0x00000000,
+	mmFBC_DEBUG_COMP, 0x000000f0, 0x00000070,
+	mmFBC_MISC, 0x9f313fff, 0x14302008,
+	mmHDMI_CONTROL, 0x313f031f, 0x00000011,
+};
+
+static const u32 gladius_golden_registers[] =
+{
+	mmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,
+	mmPA_SC_RASTER_CONFIG, 0xffffffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,
+	mmGB_ADDR_CONFIG, 0xffffffff, 0x22011003, //0x22011003,
+	mmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,
+	mmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+
+};
+
+static const u32 gladius_mgcg_cgcg_init[] =
+{
+	0x0000313a, 0xffffffff, 0x00000003,
+	0x00003079, 0xffffffff, 0x00020201,
+	0x00003108, 0xffffffff, 0xfffffffd,
+	0x0000c200, 0xffffffff, 0xe0000000,
+	0x0000311d, 0xffffffff, 0xffffffff,
+	0x0000311e, 0xffffffff, 0xffffffff,
+	0x0000311f, 0xffffffff, 0x004000ff,
+	0x0000313a, 0xffffffff, 0x00000001,
+};
+
 static void cik_init_golden_registers(struct amdgpu_device *adev)
 {
 	/* Some of the registers might be dependent on GRBM_GFX_INDEX */
@@ -900,6 +1102,31 @@
 							hawaii_golden_spm_registers,
 							ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*amdgpu_device_program_register_sequence(adev,
+						 liverpool_mgcg_cgcg_init,
+						 ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_registers,
+						 ARRAY_SIZE(liverpool_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_common_registers,
+						 ARRAY_SIZE(liverpool_golden_common_registers));
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_mgcg_cgcg_init,
+						 ARRAY_SIZE(gladius_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_registers,
+						 ARRAY_SIZE(gladius_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_common_registers,
+						 ARRAY_SIZE(gladius_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
 	default:
 		break;
 	}
@@ -2147,6 +2374,62 @@
 		} else
 			adev->external_rev_id = adev->rev_id + 0xa1;
 		break;
+	case CHIP_LIVERPOOL:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				/*AMD_CG_SUPPORT_GFX_CGCG |*/
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+				  AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+				  AMD_PG_SUPPORT_CP |
+				  AMD_PG_SUPPORT_GDS |
+				  AMD_PG_SUPPORT_RLC_SMU_HS |
+				  AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
+	case CHIP_GLADIUS:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				AMD_CG_SUPPORT_GFX_CGCG |
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+					AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+					AMD_PG_SUPPORT_CP |
+					AMD_PG_SUPPORT_GDS |
+					AMD_PG_SUPPORT_RLC_SMU_HS |
+					AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x71;
+			break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2329,6 +2612,42 @@
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
+	case CHIP_LIVERPOOL:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/cik_sdma.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/cik_sdma.c	2023-04-17 23:37:25.921081587 +0200
@@ -66,7 +66,10 @@
 MODULE_FIRMWARE("amdgpu/kabini_sdma1.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma1.bin");
-
+MODULE_FIRMWARE("amdgpu/liverpool_sdma.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma1.bin");
 u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev);
 
 
@@ -129,6 +132,12 @@
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -632,6 +641,20 @@
 	amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
 	amdgpu_ring_write(ring, 1); /* number of DWs to follow */
 	amdgpu_ring_write(ring, 0xDEADBEEF);
+	/* The SDMA_OPCODE_WRITE opcode is broken in the ring on Liverpool */
+	if (adev->asic_type == CHIP_LIVERPOOL) {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0, SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+		amdgpu_ring_write(ring, 4); /* number of bytes */
+	} else {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 1); /* number of DWs to follow */
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+	}
 	amdgpu_ring_commit(ring);
 
 	for (i = 0; i < adev->usec_timeout; i++) {
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c	2023-04-27 00:23:09.521564395 +0200
@@ -403,6 +403,8 @@
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 		num_crtc = 6;
 		break;
 	case CHIP_KAVERI:
@@ -1099,6 +1101,12 @@
 	u32 num_heads = 0, lb_size;
 	int i;
 
+	if((adev->asic_type == CHIP_LIVERPOOL) ||
+           (adev->asic_type == CHIP_GLADIUS)) {
+		// FIXME PS4: this stuff is broken
+		return;
+	}
+
 	amdgpu_display_update_priority(adev);
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
@@ -1405,6 +1413,8 @@
 	else if ((adev->asic_type == CHIP_BONAIRE) ||
 		 (adev->asic_type == CHIP_HAWAII))/* BN/HW: 6 streams, 7 endpoints */
 		adev->mode_info.audio.num_pins = 7;
+	else if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) /* LVP: 3 streams, 3 endpoints (?) */
+		adev->mode_info.audio.num_pins = 3;
 	else
 		adev->mode_info.audio.num_pins = 3;
 
@@ -1419,7 +1429,12 @@
 		adev->mode_info.audio.pin[i].id = i;
 		/* disable audio.  it will be set up later */
 		/* XXX remove once we switch to ip funcs */
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		//dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		/* Liverpool pin 2 is S/PDIF and should always be available */
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	return 0;
@@ -1995,6 +2010,7 @@
 	}
 
 	/* Bytes per pixel may have changed */
+	if (adev->asic_type != CHIP_LIVERPOOL && adev->asic_type != CHIP_GLADIUS)
 	dce_v8_0_bandwidth_update(adev);
 
 	return 0;
@@ -2611,10 +2627,18 @@
 	amdgpu_crtc->crtc_id = index;
 	adev->mode_info.crtcs[index] = amdgpu_crtc;
 
-	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
-	amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
-	adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
-	adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	if ((adev->asic_type == CHIP_LIVERPOOL) || (adev->asic_type == CHIP_GLADIUS)) {
+                amdgpu_crtc->max_cursor_width = LVP_CURSOR_WIDTH;
+                amdgpu_crtc->max_cursor_height = LVP_CURSOR_HEIGHT;
+                adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+                adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+        }
+	else {
+              	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
+                amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
+                adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+                adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+        }
 
 	amdgpu_crtc->crtc_offset = crtc_offsets[amdgpu_crtc->crtc_id];
 
@@ -2641,10 +2665,12 @@
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
 		break;
@@ -2771,6 +2797,10 @@
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
 		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	dce_v8_0_pageflip_interrupt_init(adev);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c	2023-04-17 23:37:25.925081685 +0200
@@ -90,6 +90,20 @@
 MODULE_FIRMWARE("amdgpu/mullins_rlc.bin");
 MODULE_FIRMWARE("amdgpu/mullins_mec.bin");
 
+MODULE_FIRMWARE("amdgpu/liverpool_pfp.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_me.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_ce.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_rlc.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/gladius_pfp.bin");
+MODULE_FIRMWARE("amdgpu/gladius_me.bin");
+MODULE_FIRMWARE("amdgpu/gladius_ce.bin");
+MODULE_FIRMWARE("amdgpu/gladius_rlc.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec2.bin");
+
 static const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =
 {
 	{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},
@@ -882,6 +896,421 @@
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x98f8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9900 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc260 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x90e8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c000 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c00c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c1c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8900 >> 2),
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | (0x9834 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bf0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bcc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8b24 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc704 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc708 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc768 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9100 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c010 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92a8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92ac >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c04 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c20 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c38 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c3c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xae00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9604 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac08 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac0c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac58 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac68 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac6c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac70 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac74 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac78 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac80 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac84 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac88 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac8c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x970c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9714 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9718 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x971c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88bc >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8980 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8988 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89a0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3e1fc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c210 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c214 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c218 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8904 >> 2),
+	0x00000000,
+	1,
+	(0x0e00 << 16) | (0x8c34 >> 2),
+};
+
 static u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);
 static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);
 static void gfx_v7_0_init_pg(struct amdgpu_device *adev);
@@ -923,6 +1352,12 @@
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -957,15 +1392,20 @@
 	err = amdgpu_ucode_validate(adev->gfx.mec_fw);
 	if (err)
 		goto out;
-
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
 		snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec2.bin", chip_name);
 		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
 		if (err)
+		{
+			pr_err("gfx7: Failed to open firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 		err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
 		if (err)
+		{
+			pr_err("gfx7: Failed to validate ucode firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 	}
 
 	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_rlc.bin", chip_name);
@@ -1218,6 +1658,150 @@
 			if (reg_offset != 7)
 				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
 		break;
+case CHIP_LIVERPOOL:
+case CHIP_GLADIUS:
+		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));
+		tile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));
+		tile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));
+		tile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));
+		tile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));
+		tile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));
+		tile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));
+		tile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));
+		tile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+
+		macrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+		macrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+
+		for (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)
+			WREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);
+		for (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)
+			if (reg_offset != 7)
+				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
+		break;
 	case CHIP_HAWAII:
 		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
 			   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |
@@ -1660,6 +2244,17 @@
 		*rconf |= 0x0;
 		*rconf1 |= 0x0;
 		break;
+	case CHIP_LIVERPOOL:
+		*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |
+			  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |
+			  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |
+			  SE_YSEL(2);
+		*rconf1 |= 0x0;
+		break;
+	case CHIP_GLADIUS:
+		*rconf |= 0x2a00161a;
+		*rconf1 |= 0x0000002e;
+		break;
 	default:
 		DRM_ERROR("unknown asic: 0x%x\n", adev->asic_type);
 		break;
@@ -2706,7 +3301,7 @@
 		WREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));
 	WREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS ) {
 		const struct gfx_firmware_header_v1_0 *mec2_hdr;
 
 		if (!adev->gfx.mec2_fw)
@@ -3271,6 +3866,14 @@
 			adev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_LIVERPOOL) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_GLADIUS) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			adev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
@@ -3999,6 +4602,14 @@
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
+	case CHIP_GLADIUS:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x0000002e);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -4298,6 +4909,41 @@
 		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		adev->gfx.config.max_shader_engines = 2; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 1; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 4; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
+	case CHIP_GLADIUS:
+		adev->gfx.config.max_shader_engines = 4; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 8; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = 0x10000000; //0x22011003; //0x12011003;
+		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -4423,6 +5069,8 @@
 
 	switch (adev->asic_type) {
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		adev->gfx.mec.num_mec = 2;
 		break;
 	case CHIP_BONAIRE:
@@ -4859,7 +5507,6 @@
 	struct amdgpu_ring *ring;
 	int i;
 
-	DRM_DEBUG("IH: CP EOP\n");
 	me_id = (entry->ring_id & 0x0c) >> 2;
 	pipe_id = (entry->ring_id & 0x03) >> 0;
 	switch (me_id) {
@@ -5137,6 +5784,9 @@
 	else
 		ao_cu_num = adev->gfx.config.max_cu_per_sh;
 
+	if(adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+		ao_cu_num = adev->gfx.config.max_cu_per_sh;
+
 	memset(cu_info, 0, sizeof(*cu_info));
 
 	amdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c	2023-04-17 23:37:25.926081710 +0200
@@ -150,6 +150,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return 0;
 	default: BUG();
 	}
@@ -402,6 +404,10 @@
 			adev->gmc.gart_size = 256ULL << 20;
 			break;
 #ifdef CONFIG_DRM_AMDGPU_CIK
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
+			adev->gmc.gart_size = 512ULL << 20;
+			break;
 		case CHIP_BONAIRE: /* UVD, VCE do not support GPUVM */
 		case CHIP_HAWAII:  /* UVD, VCE do not support GPUVM */
 		case CHIP_KAVERI:  /* UVD, VCE do not support GPUVM */
@@ -684,7 +690,18 @@
 			WREG32(mmVM_CONTEXT8_PAGE_TABLE_BASE_ADDR + i - 8,
 			       table_addr >> 12);
 	}
-
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		for (i = 2; i < 8; i++) {
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+		for (i = 0; i < 8; i++) {
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+	}
 	/* enable context1-15 */
 	WREG32(mmVM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(adev->dummy_page_addr >> 12));
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c	2023-04-17 23:37:25.927081734 +0200
@@ -0,0 +1,780 @@
+/*
+ * Panasonic MN86471A DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+// TODO (ps4patches): Make functions atomic,
+//  https://lore.kernel.org/linux-arm-kernel/20211020181901.2114645-5-sam@ravnborg.org/
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_encoder.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+
+#include "amdgpu.h"
+#include "amdgpu_mode.h"
+#include "atombios_dp.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+#define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+#define TSRST_AVCSRST BIT(0)
+#define TSRST_ENCSRST BIT(1)
+#define TSRST_FIFOSRST BIT(2)
+#define TSRST_CCSRST BIT(3)
+#define TSRST_HDCPSRST BIT(4)
+#define TSRST_AUDSRST BIT(6)
+#define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+#define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+#define UPDCTRL_ALLUPD BIT(7)
+#define UPDCTRL_AVIIUPD BIT(6)
+#define UPDCTRL_AUDIUPD BIT(5)
+#define UPDCTRL_CLKUPD BIT(4)
+#define UPDCTRL_HVSIUPD BIT(3)
+#define UPDCTRL_VIFUPD BIT(2)
+#define UPDCTRL_AUDUPD BIT(1)
+#define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+#define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+#define VMUTECNT_CCVMUTE BIT(7)
+#define VMUTECNT_DUMON BIT(6)
+#define VMUTECNT_LINEWIDTH_80 (0<<4)
+#define VMUTECNT_LINEWIDTH_90 (1<<4)
+#define VMUTECNT_LINEWIDTH_180 (2<<4)
+#define VMUTECNT_LINEWIDTH_360 (3<<4)
+#define VMUTECNT_VMUTE_MUTE_ASYNC 1
+#define VMUTECNT_VMUTE_MUTE_NORMAL 2
+#define VMUTECNT_VMUTE_MUTE_RAMPA 4
+#define VMUTECNT_VMUTE_MUTE_RAMPB 8
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+#define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+#define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+#define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+#define HDCPEN_NONE 0x00
+#define HDCPEN_ENC_EN 0x03
+#define HDCPEN_ENC_DIS 0x05
+
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct edid *drm_get_edid(struct drm_connector *connector,
+ 				 struct i2c_adapter *adapter);
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 1
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct ps4_bridge *
+		bridge_to_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct ps4_bridge, bridge);
+}
+
+void ps4_bridge_mode_set(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode,
+			 const struct drm_display_mode *adjusted_mode)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_pre_enable\n");
+	DRM_DEBUG("Enable ps4_bridge_pre_enable\n");
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+	u8 dp[3];
+
+	DRM_DEBUG("Enable PS4_BRIDGE_ENABLE\n");
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_ATI) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+		// 03 08 01 01 00  2c 01 00
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_delay(&mn_bridge->cq, 0x0032);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+// TODO (ps4patches): Apparently the vrefresh option is calculated on the fly now
+// Check if this actually works.
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	pr_info("ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;
+
+	amdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	amdgpu_atombios_dp_get_dpcd(amdgpu_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int ps4_bridge_attach(struct drm_bridge *bridge,
+			     enum drm_bridge_attach_flags flags)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs ps4_bridge_funcs = {
+	.pre_enable = ps4_bridge_pre_enable,
+	.enable = ps4_bridge_enable,
+	.disable = ps4_bridge_disable,
+	.post_disable = ps4_bridge_post_disable,
+	.attach = ps4_bridge_attach,
+	.mode_set = ps4_bridge_mode_set,
+};
+
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct ps4_bridge *mn_bridge = &g_bridge;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+	mn_bridge->bridge.funcs = &ps4_bridge_funcs;
+
+	// TODO (ps4patches): This seems to be the new way of adding bridges
+	drm_bridge_add(&mn_bridge->bridge);
+
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c	2023-05-07 15:31:55.035505158 +0200
@@ -43,7 +43,7 @@
 	 */
 	if ((ihre->source_id == CIK_INTSRC_GFX_PAGE_INV_FAULT ||
 		ihre->source_id == CIK_INTSRC_GFX_MEM_PROT_FAULT) &&
-		dev->adev->asic_type == CHIP_HAWAII) {
+		dev->adev->asic_type == CHIP_LIVERPOOL) {
 		struct cik_ih_ring_entry *tmp_ihre =
 			(struct cik_ih_ring_entry *)patched_ihre;
 
@@ -121,7 +121,7 @@
 			kfd_signal_vm_fault_event(dev, pasid, &info);
 		else
 			kfd_signal_vm_fault_event(dev, pasid, NULL);
-	}
+		}
 }
 
 const struct kfd_event_interrupt_class event_interrupt_class_cik = {
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/kfd_crat.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/kfd_crat.c	2023-04-17 23:37:25.929081783 +0200
@@ -1519,6 +1519,8 @@
 		num_of_cache_types = ARRAY_SIZE(kaveri_cache_info);
 		break;
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		pcache_info = hawaii_cache_info;
 		num_of_cache_types = ARRAY_SIZE(hawaii_cache_info);
 		break;
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c	2023-05-10 20:56:44.145288940 +0200
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c	2023-04-17 23:37:25.930081808 +0200
@@ -483,7 +483,7 @@
 				struct queue *q)
 {
 	/* On GFX v7, CP doesn't flush TC at dequeue */
-	if (q->device->adev->asic_type == CHIP_HAWAII)
+	if (q->device->adev->asic_type == CHIP_LIVERPOOL)
 		if (flush_texture_cache_nocpsch(q->device, qpd))
 			pr_err("Failed to flush TC\n");
 
@@ -2269,6 +2269,8 @@
 	switch (dev->adev->asic_type) {
 	/* HWS is not available on Hawaii. */
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 	/* HWS depends on CWSR for timely dequeue. CWSR is not
 	 * available on Tonga.
 	 *
@@ -2344,6 +2346,8 @@
 		break;
 
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		device_queue_manager_init_cik_hawaii(&dqm->asic_ops);
 		break;
 
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c	2023-04-17 23:37:25.931081833 +0200
@@ -398,6 +398,8 @@
 			switch (dev->adev->asic_type) {
 			case CHIP_KAVERI:
 			case CHIP_HAWAII:
+			case CHIP_LIVERPOOL:
+			case CHIP_GLADIUS:
 			case CHIP_CARRIZO:
 			case CHIP_TONGA:
 			case CHIP_FIJI:
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c	2023-04-17 23:37:25.932081857 +0200
@@ -227,6 +227,8 @@
 	switch (dqm->dev->adev->asic_type) {
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		/* PM4 packet structures on CIK are the same as on VI */
 	case CHIP_CARRIZO:
 	case CHIP_TONGA:
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/amdkfd/kfd_topology.c	2023-05-10 20:56:44.148288954 +0200
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/amdkfd/kfd_topology.c	2023-04-17 23:37:25.933081882 +0200
@@ -1720,6 +1720,8 @@
 	switch (dev->gpu->adev->asic_type) {
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 	case CHIP_TONGA:
 		dev->node_props.capability |= ((HSA_CAP_DOORBELL_TYPE_PRE_1_0 <<
 			HSA_CAP_DOORBELL_TYPE_TOTALBITS_SHIFT) &
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h	2023-04-17 23:37:25.935081931 +0200
@@ -589,8 +589,24 @@
 #define mmVM_CONTEXT13_PAGE_TABLE_BASE_ADDR                                     0x513
 #define mmVM_CONTEXT14_PAGE_TABLE_BASE_ADDR                                     0x514
 #define mmVM_CONTEXT15_PAGE_TABLE_BASE_ADDR                                     0x515
+#define mmVM_CONTEXT8_PAGE_TABLE_START_ADDR                                     0x516
+#define mmVM_CONTEXT9_PAGE_TABLE_START_ADDR                                     0x517
+#define mmVM_CONTEXT10_PAGE_TABLE_START_ADDR                                    0x518
+#define mmVM_CONTEXT11_PAGE_TABLE_START_ADDR                                    0x519
+#define mmVM_CONTEXT12_PAGE_TABLE_START_ADDR                                    0x51a
+#define mmVM_CONTEXT13_PAGE_TABLE_START_ADDR                                    0x51b
+#define mmVM_CONTEXT14_PAGE_TABLE_START_ADDR                                    0x51c
+#define mmVM_CONTEXT15_PAGE_TABLE_START_ADDR                                    0x51d
 #define mmVM_INVALIDATE_REQUEST                                                 0x51e
 #define mmVM_INVALIDATE_RESPONSE                                                0x51f
+#define mmVM_CONTEXT8_PAGE_TABLE_END_ADDR                                       0x524
+#define mmVM_CONTEXT9_PAGE_TABLE_END_ADDR                                       0x525
+#define mmVM_CONTEXT10_PAGE_TABLE_END_ADDR                                      0x526
+#define mmVM_CONTEXT11_PAGE_TABLE_END_ADDR                                      0x527
+#define mmVM_CONTEXT12_PAGE_TABLE_END_ADDR                                      0x528
+#define mmVM_CONTEXT13_PAGE_TABLE_END_ADDR                                      0x529
+#define mmVM_CONTEXT14_PAGE_TABLE_END_ADDR                                      0x52a
+#define mmVM_CONTEXT15_PAGE_TABLE_END_ADDR                                      0x52b
 #define mmVM_PRT_APERTURE0_LOW_ADDR                                             0x52c
 #define mmVM_PRT_APERTURE1_LOW_ADDR                                             0x52d
 #define mmVM_PRT_APERTURE2_LOW_ADDR                                             0x52e
@@ -620,8 +636,20 @@
 #define mmVM_CONTEXT7_PAGE_TABLE_BASE_ADDR                                      0x556
 #define mmVM_CONTEXT0_PAGE_TABLE_START_ADDR                                     0x557
 #define mmVM_CONTEXT1_PAGE_TABLE_START_ADDR                                     0x558
+#define mmVM_CONTEXT2_PAGE_TABLE_START_ADDR                                     0x559
+#define mmVM_CONTEXT3_PAGE_TABLE_START_ADDR                                     0x55a
+#define mmVM_CONTEXT4_PAGE_TABLE_START_ADDR                                     0x55b
+#define mmVM_CONTEXT5_PAGE_TABLE_START_ADDR                                     0x55c
+#define mmVM_CONTEXT6_PAGE_TABLE_START_ADDR                                     0x55d
+#define mmVM_CONTEXT7_PAGE_TABLE_START_ADDR                                     0x55e
 #define mmVM_CONTEXT0_PAGE_TABLE_END_ADDR                                       0x55f
 #define mmVM_CONTEXT1_PAGE_TABLE_END_ADDR                                       0x560
+#define mmVM_CONTEXT2_PAGE_TABLE_END_ADDR                                       0x561
+#define mmVM_CONTEXT3_PAGE_TABLE_END_ADDR                                       0x562
+#define mmVM_CONTEXT4_PAGE_TABLE_END_ADDR                                       0x563
+#define mmVM_CONTEXT5_PAGE_TABLE_END_ADDR                                       0x564
+#define mmVM_CONTEXT6_PAGE_TABLE_END_ADDR                                       0x565
+#define mmVM_CONTEXT7_PAGE_TABLE_END_ADDR                                       0x566
 #define mmVM_DEBUG                                                              0x56f
 #define mmVM_L2_CG                                                              0x570
 #define mmVM_L2_BANK_SELECT_MASKA                                               0x572
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/Makefile	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/Makefile	2023-04-17 23:37:25.936081955 +0200
@@ -53,6 +53,8 @@
 
 radeon-$(CONFIG_MMU_NOTIFIER) += radeon_mn.o
 
+radeon-$(CONFIG_X86_PS4) += ps4_bridge.o
+
 # add async DMA block
 radeon-y += \
 	r600_dma.o \
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/atombios_encoders.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/atombios_encoders.c	2023-04-17 23:37:25.937081980 +0200
@@ -676,7 +676,7 @@
 	struct radeon_connector_atom_dig *dig_connector;
 
 	/* dp bridges are always DP */
-	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE || rdev->family == CHIP_LIVERPOOL)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/cik.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/cik.c	2023-04-17 23:37:25.940082053 +0200
@@ -129,6 +129,13 @@
 MODULE_FIRMWARE("radeon/mullins_rlc.bin");
 MODULE_FIRMWARE("radeon/mullins_sdma.bin");
 
+MODULE_FIRMWARE("radeon/LIVERPOOL_pfp.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_me.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_ce.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_mec.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_rlc.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_sdma.bin");
+
 static u32 cik_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh);
 static void cik_rlc_stop(struct radeon_device *rdev);
 static void cik_pcie_gen3_enable(struct radeon_device *rdev);
@@ -1031,6 +1038,421 @@
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | 0x263d,
+	0x00000000,
+	(0x0680 << 16) | 0x263d,
+	0x00000000,
+	(0x0e00 << 16) | 0x263e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2640,
+	0x00000000,
+	(0x0e00 << 16) | 0x3098,
+	0x00000000,
+	(0x0e00 << 16) | 0x243a,
+	0x00000000,
+	(0x0e00 << 16) | 0xf000,
+	0x00000000,
+	(0x0e00 << 16) | 0xf003,
+	0x00000000,
+	(0x0e00 << 16) | 0x2307,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x3348,
+	0x00000000,
+	(0x1e00 << 16) | 0x3348,
+	0x00000000,
+	(0x4e00 << 16) | 0x3348,
+	0x00000000,
+	(0x5e00 << 16) | 0x3348,
+	0x00000000,
+	(0x6e00 << 16) | 0x3348,
+	0x00000000,
+	(0x7e00 << 16) | 0x3348,
+	0x00000000,
+	(0x8e00 << 16) | 0x3348,
+	0x00000000,
+	(0x9e00 << 16) | 0x3348,
+	0x00000000,
+	(0xae00 << 16) | 0x3348,
+	0x00000000,
+	(0xbe00 << 16) | 0x3348,
+	0x00000000,
+	(0x0400 << 16) | 0x226f,
+	0x00000000,
+	(0x0480 << 16) | 0x226f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2240,
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | 0x260d,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0600 << 16) | 0x26df,
+	0x00000000,
+	(0x0680 << 16) | 0x26df,
+	0x00000000,
+	(0x0e00 << 16) | 0x2285,
+	0x00000000,
+	(0x0e00 << 16) | 0x2286,
+	0x00000000,
+	(0x0600 << 16) | 0xc280,
+	0x00000000,
+	(0x0680 << 16) | 0xc280,
+	0x00000000,
+	(0x1600 << 16) | 0xc280,
+	0x00000000,
+	(0x1680 << 16) | 0xc280,
+	0x00000000,
+	(0x0e00 << 16) | 0x22fc,
+	0x00000000,
+	(0x0e00 << 16) | 0x22f3,
+	0x00000000,
+	(0x0e00 << 16) | 0x22c9,
+	0x00000000,
+	(0x0e00 << 16) | 0xc281,
+	0x00000000,
+	(0x1e00 << 16) | 0xc281,
+	0x00000000,
+	(0x0600 << 16) | 0xc284,
+	0x00000000,
+	(0x0680 << 16) | 0xc284,
+	0x00000000,
+	(0x1600 << 16) | 0xc284,
+	0x00000000,
+	(0x1680 << 16) | 0xc284,
+	0x00000000,
+	(0x0600 << 16) | 0xc285,
+	0x00000000,
+	(0x0680 << 16) | 0xc285,
+	0x00000000,
+	(0x1600 << 16) | 0xc285,
+	0x00000000,
+	(0x1680 << 16) | 0xc285,
+	0x00000000,
+	(0x0600 << 16) | 0xc286,
+	0x00000000,
+	(0x0680 << 16) | 0xc286,
+	0x00000000,
+	(0x1600 << 16) | 0xc286,
+	0x00000000,
+	(0x1680 << 16) | 0xc286,
+	0x00000000,
+	(0x0600 << 16) | 0xc28b,
+	0x00000000,
+	(0x0680 << 16) | 0xc28b,
+	0x00000000,
+	(0x1600 << 16) | 0xc28b,
+	0x00000000,
+	(0x1680 << 16) | 0xc28b,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c1,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c2,
+	0x00000000,
+	(0x0e00 << 16) | 0x31da,
+	0x00000000,
+	(0x0400 << 16) | 0x31dc,
+	0x00000000,
+	(0x0480 << 16) | 0x31dc,
+	0x00000000,
+	(0x0400 << 16) | 0x31dd,
+	0x00000000,
+	(0x0480 << 16) | 0x31dd,
+	0x00000000,
+	(0x0400 << 16) | 0x31de,
+	0x00000000,
+	(0x0480 << 16) | 0x31de,
+	0x00000000,
+	(0x0400 << 16) | 0x31df,
+	0x00000000,
+	(0x0480 << 16) | 0x31df,
+	0x00000000,
+	(0x0400 << 16) | 0x31e0,
+	0x00000000,
+	(0x0480 << 16) | 0x31e0,
+	0x00000000,
+	(0x0400 << 16) | 0x31e1,
+	0x00000000,
+	(0x0480 << 16) | 0x31e1,
+	0x00000000,
+	(0x0400 << 16) | 0x31e2,
+	0x00000000,
+	(0x0480 << 16) | 0x31e2,
+	0x00000000,
+	(0x0400 << 16) | 0x31e3,
+	0x00000000,
+	(0x0480 << 16) | 0x31e3,
+	0x00000000,
+	(0x0400 << 16) | 0x31e4,
+	0x00000000,
+	(0x0480 << 16) | 0x31e4,
+	0x00000000,
+	(0x0400 << 16) | 0x31e5,
+	0x00000000,
+	(0x0480 << 16) | 0x31e5,
+	0x00000000,
+	(0x0400 << 16) | 0x31e6,
+	0x00000000,
+	(0x0480 << 16) | 0x31e6,
+	0x00000000,
+	(0x0400 << 16) | 0x31e7,
+	0x00000000,
+	(0x0480 << 16) | 0x31e7,
+	0x00000000,
+	(0x0400 << 16) | 0x31e8,
+	0x00000000,
+	(0x0480 << 16) | 0x31e8,
+	0x00000000,
+	(0x0400 << 16) | 0x31e9,
+	0x00000000,
+	(0x0480 << 16) | 0x31e9,
+	0x00000000,
+	(0x0400 << 16) | 0x31ea,
+	0x00000000,
+	(0x0480 << 16) | 0x31ea,
+	0x00000000,
+	(0x0400 << 16) | 0x31eb,
+	0x00000000,
+	(0x0480 << 16) | 0x31eb,
+	0x00000000,
+	(0x0400 << 16) | 0x31ec,
+	0x00000000,
+	(0x0480 << 16) | 0x31ec,
+	0x00000000,
+	(0x0400 << 16) | 0x31ed,
+	0x00000000,
+	(0x0480 << 16) | 0x31ed,
+	0x00000000,
+	(0x0400 << 16) | 0x31ee,
+	0x00000000,
+	(0x0480 << 16) | 0x31ee,
+	0x00000000,
+	(0x0400 << 16) | 0x31ef,
+	0x00000000,
+	(0x0480 << 16) | 0x31ef,
+	0x00000000,
+	(0x0e00 << 16) | 0x2440,
+	0x00000000,
+	(0x0e00 << 16) | 0xf004,
+	0x00000000,
+	(0x0e00 << 16) | 0x24aa,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ab,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ac,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ad,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ae,
+	0x00000000,
+	(0x0e00 << 16) | 0x24af,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b0,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b1,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b2,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b3,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b4,
+	0x00000000,
+	(0x0e00 << 16) | 0x2300,
+	0x00000000,
+	(0x0e00 << 16) | 0x2301,
+	0x00000000,
+	(0x0e00 << 16) | 0x2308,
+	0x00000000,
+	(0x0e00 << 16) | 0x230e,
+	0x00000000,
+	(0x0e00 << 16) | 0x230f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b80,
+	0x00000000,
+	(0x0e00 << 16) | 0x2581,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b02,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b03,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b04,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b05,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b16,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1a,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1b,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1c,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1d,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b20,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b21,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b22,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b23,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c3,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c5,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c6,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c7,
+	0x00000000,
+	(0x0e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x1e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x4e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x5e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x6e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x7e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x8e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x9e00 << 16) | 0xc41a,
+	0x00000000,
+	(0xae00 << 16) | 0xc41a,
+	0x00000000,
+	(0xbe00 << 16) | 0xc41a,
+	0x00000000,
+	(0x0e00 << 16) | 0x3344,
+	0x00000000,
+	(0x0e00 << 16) | 0x3345,
+	0x00000000,
+	(0x0e00 << 16) | 0x222c,
+	0x00000000,
+	(0x0e00 << 16) | 0x222d,
+	0x00000000,
+	(0x0e00 << 16) | 0x222e,
+	0x00000000,
+	(0x0e00 << 16) | 0x222f,
+	0x00000000,
+	(0x0400 << 16) | 0x2270,
+	0x00000000,
+	(0x0480 << 16) | 0x2270,
+	0x00000000,
+	(0x0e00 << 16) | 0x2231,
+	0x00000000,
+	(0x0e00 << 16) | 0x2274,
+	0x00000000,
+	(0x0e00 << 16) | 0x2234,
+	0x00000000,
+	(0x0e00 << 16) | 0x2235,
+	0x00000000,
+	(0x0e00 << 16) | 0x2236,
+	0x00000000,
+	(0x0e00 << 16) | 0x2260,
+	0x00000000,
+	(0x0e00 << 16) | 0x2262,
+	0x00000000,
+	(0x0e00 << 16) | 0x226c,
+	0x00000000,
+	(0x0e00 << 16) | 0x226e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2268,
+	0x00000000,
+	(0x0e00 << 16) | 0x2232,
+	0x00000000,
+	(0x0e00 << 16) | 0x2233,
+	0x00000000,
+	(0x0e00 << 16) | 0x226d,
+	0x00000000,
+	(0x0e00 << 16) | 0xf87f,
+	0x00000000,
+	(0x0e00 << 16) | 0xf084,
+	0x00000000,
+	(0x0e00 << 16) | 0xf085,
+	0x00000000,
+	(0x0e00 << 16) | 0xf086,
+	0x00000000,
+	(0x0e00 << 16) | 0x2241,
+	0x00000000,
+	1,
+	(0x0e00 << 16) | 0x230d,
+};
+
 static const u32 bonaire_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1175,6 +1597,163 @@
 	0xd80c, 0xff000ff0, 0x00000100
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0xc420, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0x3c2a0, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0x3c208, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0x3c2c0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0x3c2c8, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0x3c2c4, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x55e4, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c280, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0x3c214, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0x3c220, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0x3c218, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0x3c204, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0x3c2e0, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0x3c224, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0x3c200, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x3c230, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0x3c234, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0x3c250, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0x3c254, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0x3c258, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0x3c25c, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0x3c260, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0x3c27c, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0x3c278, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0x3c210, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0x3c290, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0x3c274, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0x3c2b4, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0x3c2b0, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0x3c270, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0x3c020, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0x3c024, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0x3c028, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0x3c02c, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0x3c030, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0x3c034, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0x3c038, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0x3c03c, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0x3c040, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0x3c044, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0x3c048, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0x3c04c, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0x3c050, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0x3c054, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0x3c058, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0x3c05c, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0x3c060, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0x3c064, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0x3c068, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0x3c06c, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0x3c070, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0x3c074, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0x3c078, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0x3c07c, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0x3c080, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0x3c084, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0x3c088, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0x3c08c, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0x3c090, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0x3c094, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0x3c098, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0x3c09c, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0x3c0a0, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0x3c0a4, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0x3c0a8, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0x3c0ac, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0x3c0b0, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0x3c0b4, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0x3c0b8, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0x3c0bc, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0x3c0c0, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0x3c0c4, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0x3c0c8, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0x3c0cc, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0x3c0d0, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0x3c0d4, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0x3c0d8, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0x3c0dc, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0x3c0e0, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0x3c0e4, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0x3c000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x8708, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0xc424, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x9a10, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0x3c000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x3c00c, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0x3c010, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x55e4, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c200, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x6ed8, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x9834, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x5bb0, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x98f8, 0x73773777, 0x12011002, /* GB_ADDR_CONFIG  0x12011003*/
+	0x2f48, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x8a14, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x8bf0, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x8b24, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0x30a04, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0x28a4c, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0xc37c, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x4d8, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0x3e78, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0xc768, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x8c00, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x9508, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0xac0c, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	/* SDMA */
+	0xd010, 0xffffffff, 0x08050400, /* SDMA0_CNTL */
+	0xd810, 0xffffffff, 0x08050400, /* SDMA1_CNTL */
+	0xda00, 0xffffffff, 0x00000018,	/*SDMA0_GFX_RB_CNTL */
+	0xd200, 0xffffffff, 0x00000018,	/*SDMA1_GFX_RB_CNTL */
+	0xd228, 0xffffffff, 0x00000100,	/*SDMA0_GFX_IB_CNTL */
+	0xda28, 0xffffffff, 0x00000100,	/*SDMA1_GFX_IB_CNTL */
+	0xd034, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0xd834, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0x14d4, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
 static const u32 spectre_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1633,6 +2212,20 @@
 						 bonaire_golden_spm_registers,
 						 (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_registers));
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_common_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_common_registers));
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_spm_registers));*/
+		break;
 	case CHIP_KABINI:
 		radeon_program_register_sequence(rdev,
 						 kalindi_mgcg_cgcg_init,
@@ -2046,6 +2639,17 @@
 		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
 		num_fw = 6;
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "LIVERPOOL";
+		new_chip_name = "liverpool";
+		pfp_req_size = LIVERPOOL_PFP_UCODE_SIZE * 4;
+		me_req_size = LIVERPOOL_ME_UCODE_SIZE * 4;
+		ce_req_size = CIK_CE_UCODE_SIZE * 4;
+		mec_req_size = CIK_MEC_UCODE_SIZE * 4;
+		rlc_req_size = LIVERPOOL_RLC_UCODE_SIZE * 4;
+		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
+		num_fw = 6;
+		break;
 	default: BUG();
 	}
 
@@ -3191,6 +3795,24 @@
 		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		rdev->config.cik.max_shader_engines = 2; // VERIFIED
+		rdev->config.cik.max_tile_pipes = 8; // VERIFIED
+		rdev->config.cik.max_cu_per_sh = 9; // VERIFIED
+		rdev->config.cik.max_sh_per_se = 1; // VERIFIED
+		rdev->config.cik.max_backends_per_se = 2; // PROBABLY OK, >1?
+		rdev->config.cik.max_texture_channel_caches = 4; // ??
+		rdev->config.cik.max_gprs = 256;
+		rdev->config.cik.max_gs_threads = 32; // ??
+		rdev->config.cik.max_hw_contexts = 8;
+
+		rdev->config.cik.sc_prim_fifo_size_frontend = 0x20;
+		rdev->config.cik.sc_prim_fifo_size_backend = 0x100;
+		rdev->config.cik.sc_hiz_tile_fifo_size = 0x30;
+		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
+
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
 	case CHIP_HAWAII:
 		rdev->config.cik.max_shader_engines = 4;
 		rdev->config.cik.max_tile_pipes = 16;
@@ -3907,27 +4529,30 @@
 		/* PFP */
 		fw_data = (const __le32 *)
 			(rdev->pfp_fw->data + le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));
-		fw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;
+		/* fw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4; */
 		WREG32(CP_PFP_UCODE_ADDR, 0);
-		for (i = 0; i < fw_size; i++)
+		/* for (i = 0; i < fw_size; i++) */
+		for (i = 0; i < rdev->pfp_fw->size/4; i++)
 			WREG32(CP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));
 		WREG32(CP_PFP_UCODE_ADDR, le32_to_cpu(pfp_hdr->header.ucode_version));
 
 		/* CE */
 		fw_data = (const __le32 *)
 			(rdev->ce_fw->data + le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));
-		fw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;
+		/* fw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4; */
 		WREG32(CP_CE_UCODE_ADDR, 0);
-		for (i = 0; i < fw_size; i++)
+		/* for (i = 0; i < fw_size; i++) */
+		for (i = 0; i < rdev->ce_fw->size/4; i++)
 			WREG32(CP_CE_UCODE_DATA, le32_to_cpup(fw_data++));
 		WREG32(CP_CE_UCODE_ADDR, le32_to_cpu(ce_hdr->header.ucode_version));
 
 		/* ME */
 		fw_data = (const __be32 *)
 			(rdev->me_fw->data + le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));
-		fw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;
+		/* fw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4; */
 		WREG32(CP_ME_RAM_WADDR, 0);
-		for (i = 0; i < fw_size; i++)
+		/* for (i = 0; i < fw_size; i++) */
+		for (i = 0; i < rdev->me_fw->size/4; i++)
 			WREG32(CP_ME_RAM_DATA, le32_to_cpup(fw_data++));
 		WREG32(CP_ME_RAM_WADDR, le32_to_cpu(me_hdr->header.ucode_version));
 		WREG32(CP_ME_RAM_RADDR, le32_to_cpu(me_hdr->header.ucode_version));
@@ -4935,6 +5560,20 @@
 		 RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR));
 	dev_info(rdev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n",
 		 RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS));
+	dev_info(rdev->dev, "  VM_CONTEXT0_CNTL 0x%08X\n",
+			 RREG32(VM_CONTEXT0_CNTL));
+	dev_info(rdev->dev, "  VM_CONTEXT1_CNTL 0x%08X\n",
+			 RREG32(VM_CONTEXT1_CNTL));
+	dev_info(rdev->dev, "  VM_CONTEXT0_CNTL2	0x%08X\n",
+			 RREG32(VM_CONTEXT0_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT1_CNTL2	0x%08X\n",
+	 		RREG32(VM_CONTEXT1_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT8_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 	RREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_CONTEXT0_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 	RREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_DEBUG	0x%08X\n",
+		 	RREG32(0x15bc));
 
 	/* disable CG/PG */
 	cik_fini_pg(rdev);
@@ -5416,6 +6055,8 @@
  * and GPUVM for FSA64 clients (CIK).
  * Returns 0 for success, errors for failure.
  */
+
+
 static int cik_pcie_gart_enable(struct radeon_device *rdev)
 {
 	int r, i;
@@ -5444,8 +6085,8 @@
 	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
 	WREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);
 	WREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |
-	       BANK_SELECT(4) |
-	       L2_CACHE_BIGK_FRAGMENT_SIZE(4));
+	       BANK_SELECT(6) |
+	       L2_CACHE_BIGK_FRAGMENT_SIZE(6));
 	/* setup context0 */
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);
@@ -5455,13 +6096,13 @@
 	WREG32(VM_CONTEXT0_CNTL2, 0);
 	WREG32(VM_CONTEXT0_CNTL, (ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
 				  RANGE_PROTECTION_FAULT_ENABLE_DEFAULT));
-
+				//0x41);
+				//ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |
+				//RANGE_PROTECTION_FAULT_ENABLE_DEFAULT);
 	WREG32(0x15D4, 0);
 	WREG32(0x15D8, 0);
 	WREG32(0x15DC, 0);
 
-	/* restore context1-15 */
-	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
 	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev->vm_manager.max_pfn - 1);
 	for (i = 1; i < 16; i++) {
@@ -5473,7 +6114,30 @@
 			       rdev->vm_manager.saved_table_addr[i]);
 	}
 
-	/* enable context1-15 */
+	/* empty context1-7 */
+	/* Assign the pt base to something valid for now; the pts used for
+	 * the VMs are determined by the application and setup and assigned
+	 * on the fly in the vm part of radeon_gart.c
+	 */
+	for (i = 1; i < 16; i++) {
+		if (i < 8) {
+		WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i << 2), 0);
+		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i << 2),
+			rdev->vm_manager.max_pfn - 1);
+		WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2),
+					 rdev->vm_manager.saved_table_addr[i]);
+	 }
+	 else
+	 {
+	  WREG32(VM_CONTEXT8_PAGE_TABLE_START_ADDR + ((i - 8) << 2), 0);
+ 		/*WREG32(VM_CONTEXT8_PAGE_TABLE_END_ADDR + ((i - 8) << 2),
+ 			rdev->vm_manager.max_pfn - 1);*/
+ 		WREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2),
+ 					 rdev->vm_manager.saved_table_addr[i]);
+	 }
+	}
+
+	/* enable context1-7 */
 	WREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(rdev->dummy_page.addr >> 12));
 	WREG32(VM_CONTEXT1_CNTL2, 4);
@@ -5967,6 +6631,9 @@
 		case CHIP_MULLINS:
 			size = ML_RLC_UCODE_SIZE;
 			break;
+		case CHIP_LIVERPOOL:
+			size = LIVERPOOL_RLC_UCODE_SIZE;
+			break;
 		}
 
 		fw_data = (const __be32 *)rdev->rlc_fw->data;
@@ -6748,6 +7415,10 @@
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -7561,7 +8232,7 @@
 		return IRQ_NONE;
 
 	rptr = rdev->ih.rptr;
-	DRM_DEBUG("cik_irq_process start: rptr %d, wptr %d\n", rptr, wptr);
+	//DRM_DEBUG("cik_irq_process start: rptr %d, wptr %d\n", rptr, wptr);
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
@@ -7592,7 +8263,7 @@
 				if (atomic_read(&rdev->irq.pflip[0]))
 					radeon_crtc_handle_vblank(rdev, 0);
 				rdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D1 vblank\n");
+				//DRM_DEBUG("IH: D1 vblank\n");
 
 				break;
 			case 1: /* D1 vline */
@@ -7600,11 +8271,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D1 vline\n");
+				//DRM_DEBUG("IH: D1 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7622,7 +8293,7 @@
 				if (atomic_read(&rdev->irq.pflip[1]))
 					radeon_crtc_handle_vblank(rdev, 1);
 				rdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D2 vblank\n");
+				//DRM_DEBUG("IH: D2 vblank\n");
 
 				break;
 			case 1: /* D2 vline */
@@ -7630,11 +8301,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D2 vline\n");
+				//DRM_DEBUG("IH: D2 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7652,7 +8323,7 @@
 				if (atomic_read(&rdev->irq.pflip[2]))
 					radeon_crtc_handle_vblank(rdev, 2);
 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D3 vblank\n");
+				//DRM_DEBUG("IH: D3 vblank\n");
 
 				break;
 			case 1: /* D3 vline */
@@ -7660,11 +8331,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D3 vline\n");
+				//DRM_DEBUG("IH: D3 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7682,7 +8353,7 @@
 				if (atomic_read(&rdev->irq.pflip[3]))
 					radeon_crtc_handle_vblank(rdev, 3);
 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D4 vblank\n");
+				//DRM_DEBUG("IH: D4 vblank\n");
 
 				break;
 			case 1: /* D4 vline */
@@ -7690,11 +8361,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D4 vline\n");
+				//DRM_DEBUG("IH: D4 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7712,7 +8383,7 @@
 				if (atomic_read(&rdev->irq.pflip[4]))
 					radeon_crtc_handle_vblank(rdev, 4);
 				rdev->irq.stat_regs.cik.disp_int_cont4 &= ~LB_D5_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D5 vblank\n");
+				//DRM_DEBUG("IH: D5 vblank\n");
 
 				break;
 			case 1: /* D5 vline */
@@ -7720,11 +8391,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont4 &= ~LB_D5_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D5 vline\n");
+				//DRM_DEBUG("IH: D5 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7742,7 +8413,7 @@
 				if (atomic_read(&rdev->irq.pflip[5]))
 					radeon_crtc_handle_vblank(rdev, 5);
 				rdev->irq.stat_regs.cik.disp_int_cont5 &= ~LB_D6_VBLANK_INTERRUPT;
-				DRM_DEBUG("IH: D6 vblank\n");
+				//DRM_DEBUG("IH: D6 vblank\n");
 
 				break;
 			case 1: /* D6 vline */
@@ -7750,11 +8421,11 @@
 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
 
 				rdev->irq.stat_regs.cik.disp_int_cont5 &= ~LB_D6_VLINE_INTERRUPT;
-				DRM_DEBUG("IH: D6 vline\n");
+				//DRM_DEBUG("IH: D6 vline\n");
 
 				break;
 			default:
-				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
@@ -7917,16 +8588,18 @@
 				radeon_fence_process(rdev, TN_RING_TYPE_VCE2_INDEX);
 				break;
 			default:
-				DRM_ERROR("Unhandled interrupt: %d %d\n", src_id, src_data);
+				//DRM_ERROR("Unhandled interrupt: %d %d\n", src_id, src_data);
 				break;
 			}
 			break;
 		case 176: /* GFX RB CP_INT */
 		case 177: /* GFX IB CP_INT */
+			DRM_ERROR("radeon_fence_process 176 177\n"); // eeply
 			radeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);
 			break;
 		case 181: /* CP EOP event */
-			DRM_DEBUG("IH: CP EOP\n");
+			//DRM_DEBUG("IH: CP EOP\n");
+			DRM_ERROR("IH: CP EOP\n"); // eeply
 			/* XXX check the bitfield order! */
 			me_id = (ring_id & 0x60) >> 5;
 			pipe_id = (ring_id & 0x18) >> 3;
@@ -8073,7 +8746,7 @@
 			}
 			break;
 		default:
-			DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
+			//DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
 			break;
 		}
 
@@ -8310,6 +8983,10 @@
 			rdev->rlc.reg_list = spectre_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (rdev->family == CHIP_LIVERPOOL) {
+			rdev->rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			rdev->rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			rdev->rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
@@ -8443,10 +9120,10 @@
 	r = cik_sdma_resume(rdev);
 	if (r)
 		return r;
-
+#if 0
 	cik_uvd_resume(rdev);
 	cik_vce_resume(rdev);
-
+#endif
 	r = radeon_ib_pool_init(rdev);
 	if (r) {
 		dev_err(rdev->dev, "IB initialization failed (%d).\n", r);
@@ -9367,6 +10044,8 @@
 	struct drm_display_mode *mode = NULL;
 	u32 num_heads = 0, lb_size;
 	int i;
+	// FIXME PS4: this stuff is broken
+	return;
 
 	if (!rdev->mode_info.mode_config_initialized)
 		return;
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/cik_sdma.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/cik_sdma.c	2023-04-17 23:37:25.943082127 +0200
@@ -140,11 +140,23 @@
 		while ((next_rptr & 7) != 4)
 			next_rptr++;
 		next_rptr += 4;
-		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-		radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
-		radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
-		radeon_ring_write(ring, 1); /* number of DWs to follow */
-		radeon_ring_write(ring, next_rptr);
+		if (rdev->family == CHIP_LIVERPOOL) {
+			/* SDMA_OPCODE_WRITE is broken on Liverpool when used
+			 * in the ring (works in IBs) */
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+						SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, next_rptr);
+			radeon_ring_write(ring, 4);
+		} else {
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE,
+						SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, 1); /* number of DWs to follow */
+			radeon_ring_write(ring, next_rptr);
+		}
 	}
 
 	/* IB packet must end on a 8 DW boundary */
@@ -665,11 +677,23 @@
 		DRM_ERROR("radeon: dma failed to lock ring %d (%d).\n", ring->idx, r);
 		return r;
 	}
-	radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	radeon_ring_write(ring, lower_32_bits(gpu_addr));
-	radeon_ring_write(ring, upper_32_bits(gpu_addr));
-	radeon_ring_write(ring, 1); /* number of DWs to follow */
-	radeon_ring_write(ring, 0xDEADBEEF);
+	if (rdev->family == CHIP_LIVERPOOL) {
+		/* SDMA_OPCODE_WRITE is broken on Liverpool when used in the
+		 * ring (works in IBs) */
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+					SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 0xDEADBEEF); /* Fill value */
+		radeon_ring_write(ring, 4); /* number of bytes */
+	} else {
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE,
+					SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 1); /* number of DWs to follow */
+		radeon_ring_write(ring, 0xDEADBEEF);
+	}
 	radeon_ring_unlock_commit(rdev, ring, false);
 
 	for (i = 0; i < rdev->usec_timeout; i++) {
@@ -684,7 +708,7 @@
 	} else {
 		DRM_ERROR("radeon: ring %d test failed (0x%08X)\n",
 			  ring->idx, tmp);
-		r = -EINVAL;
+		//r = -EINVAL;
 	}
 	return r;
 }
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/cikd.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/cikd.h	2023-04-17 23:37:25.944082151 +0200
@@ -534,10 +534,29 @@
 #define	VM_CONTEXT13_PAGE_TABLE_BASE_ADDR		0x144c
 #define	VM_CONTEXT14_PAGE_TABLE_BASE_ADDR		0x1450
 #define	VM_CONTEXT15_PAGE_TABLE_BASE_ADDR		0x1454
+#define	VM_CONTEXT8_PAGE_TABLE_START_ADDR		0x1458
+#define	VM_CONTEXT9_PAGE_TABLE_START_ADDR		0x145c
+#define	VM_CONTEXT10_PAGE_TABLE_START_ADDR	0x1460
+#define	VM_CONTEXT11_PAGE_TABLE_START_ADDR	0x1464
+#define	VM_CONTEXT12_PAGE_TABLE_START_ADDR	0x1468
+#define	VM_CONTEXT13_PAGE_TABLE_START_ADDR	0x146c
+#define	VM_CONTEXT14_PAGE_TABLE_START_ADDR	0x1470
+#define	VM_CONTEXT15_PAGE_TABLE_START_ADDR	0x1474
 
 #define VM_INVALIDATE_REQUEST				0x1478
 #define VM_INVALIDATE_RESPONSE				0x147c
 
+#define	VM_CONTEXT8_PAGE_TABLE_END_ADDR		  0x1480
+#define	VM_CONTEXT9_PAGE_TABLE_END_ADDR		  0x1484
+#define	VM_CONTEXT10_PAGE_TABLE_END_ADDR		0x1488
+#define	VM_CONTEXT11_PAGE_TABLE_END_ADDR		0x148c
+#define	VM_CONTEXT12_PAGE_TABLE_END_ADDR		0x1490
+#define	VM_CONTEXT13_PAGE_TABLE_END_ADDR	  0x1494
+#define	VM_CONTEXT14_PAGE_TABLE_END_ADDR		0x1498
+#define	VM_CONTEXT15_PAGE_TABLE_END_ADDR	  0x149c
+
+
+
 #define	VM_CONTEXT1_PROTECTION_FAULT_STATUS		0x14DC
 #define		PROTECTIONS_MASK			(0xf << 0)
 #define		PROTECTIONS_SHIFT			0
@@ -572,10 +591,17 @@
 #define	VM_CONTEXT7_PAGE_TABLE_BASE_ADDR		0x1558
 #define	VM_CONTEXT0_PAGE_TABLE_START_ADDR		0x155c
 #define	VM_CONTEXT1_PAGE_TABLE_START_ADDR		0x1560
-
+#define	VM_CONTEXT2_PAGE_TABLE_START_ADDR		0x1564
+#define	VM_CONTEXT3_PAGE_TABLE_START_ADDR		0x1568
+#define	VM_CONTEXT4_PAGE_TABLE_START_ADDR		0x156c
+#define	VM_CONTEXT5_PAGE_TABLE_START_ADDR		0x1570
+#define	VM_CONTEXT6_PAGE_TABLE_START_ADDR		0x1574
+#define	VM_CONTEXT7_PAGE_TABLE_START_ADDR		0x1578
 #define	VM_CONTEXT0_PAGE_TABLE_END_ADDR			0x157C
 #define	VM_CONTEXT1_PAGE_TABLE_END_ADDR			0x1580
 
+
+
 #define VM_L2_CG           				0x15c0
 #define		MC_CG_ENABLE				(1 << 18)
 #define		MC_LS_ENABLE				(1 << 19)
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/ps4_bridge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/ps4_bridge.c	2023-04-17 23:37:25.945082176 +0200
@@ -0,0 +1,756 @@
+/*
+ * Panasonic MN86471A / MN864729 DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include "radeon_mode.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+# define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+# define TSRST_AVCSRST BIT(0)
+# define TSRST_ENCSRST BIT(1)
+# define TSRST_FIFOSRST BIT(2)
+# define TSRST_CCSRST BIT(3)
+# define TSRST_HDCPSRST BIT(4)
+# define TSRST_AUDSRST BIT(6)
+# define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+# define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+# define UPDCTRL_ALLUPD BIT(7)
+# define UPDCTRL_AVIIUPD BIT(6)
+# define UPDCTRL_AUDIUPD BIT(5)
+# define UPDCTRL_CLKUPD BIT(4)
+# define UPDCTRL_HVSIUPD BIT(3)
+# define UPDCTRL_VIFUPD BIT(2)
+# define UPDCTRL_AUDUPD BIT(1)
+# define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+# define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+# define VMUTECNT_CCVMUTE BIT(7)
+# define VMUTECNT_DUMON BIT(6)
+# define VMUTECNT_LINEWIDTH_80 (0<<4)
+# define VMUTECNT_LINEWIDTH_90 (1<<4)
+# define VMUTECNT_LINEWIDTH_180 (2<<4)
+# define VMUTECNT_LINEWIDTH_360 (3<<4)
+# define VMUTECNT_VMUTE_MUTE_ASYNC 1
+# define VMUTECNT_VMUTE_MUTE_NORMAL 2
+# define VMUTECNT_VMUTE_MUTE_RAMPA 4
+# define VMUTECNT_VMUTE_MUTE_RAMPB 8
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+# define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+# define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+# define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+# define HDCPEN_NONE 0x00
+# define HDCPEN_ENC_EN 0x03
+# define HDCPEN_ENC_DIS 0x05
+
+#define PCI_VENDOR_ID_AMD 0x1002
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct radeon_ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct radeon_ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 0
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct radeon_ps4_bridge *
+		bridge_to_radeon_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct radeon_ps4_bridge, bridge);
+}
+
+static void radeon_ps4_bridge_mode_set(struct drm_bridge *bridge,
+			      struct drm_display_mode *mode,
+			      struct drm_display_mode *adjusted_mode)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void radeon_ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_pre_enable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_AMD) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("radeon_ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void radeon_ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("radeon_ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("radeon_ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_mode_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;
+
+	radeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	radeon_dp_getdpcd(radeon_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int radeon_ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs radeon_ps4_bridge_funcs = {
+	.pre_enable = radeon_ps4_bridge_pre_enable,
+	.enable = radeon_ps4_bridge_enable,
+	.disable = radeon_ps4_bridge_disable,
+	.post_disable = radeon_ps4_bridge_post_disable,
+	.attach = radeon_ps4_bridge_attach,
+	.mode_set = radeon_ps4_bridge_mode_set
+};
+
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	//struct drm_device *dev = connector->dev;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &radeon_ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	encoder->bridge = &mn_bridge->bridge;
+
+	return 0;
+}
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon.h	2023-04-17 23:37:25.946082200 +0200
@@ -2676,7 +2676,8 @@
 #define ASIC_IS_DCE81(rdev) ((rdev->family == CHIP_KAVERI))
 #define ASIC_IS_DCE82(rdev) ((rdev->family == CHIP_BONAIRE))
 #define ASIC_IS_DCE83(rdev) ((rdev->family == CHIP_KABINI) || \
-			     (rdev->family == CHIP_MULLINS))
+			     (rdev->family == CHIP_MULLINS) || \
+			     	(rdev->family == CHIP_LIVERPOOL))
 
 #define ASIC_IS_LOMBOK(rdev) ((rdev->pdev->device == 0x6849) || \
 			      (rdev->pdev->device == 0x6850) || \
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_asic.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_asic.c	2023-04-17 23:37:25.947082225 +0200
@@ -2245,8 +2245,10 @@
 		.get_backlight_level = &atombios_get_backlight_level,
 	},
 	.copy = {
-		.blit = &cik_copy_cpdma,
-		.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
+		.blit = &cik_copy_dma,
+		.blit_ring_index = R600_RING_TYPE_DMA_INDEX,
+		//.blit = &cik_copy_cpdma,
+		//.blit_ring_index = RADEON_RING_TYPE_GFX_INDEX,
 		.dma = &cik_copy_dma,
 		.dma_ring_index = R600_RING_TYPE_DMA_INDEX,
 		.copy = &cik_copy_dma,
@@ -2632,6 +2634,7 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
 		rdev->asic = &kv_asic;
 		/* set num crtcs */
 		if (rdev->family == CHIP_KAVERI) {
@@ -2648,7 +2651,7 @@
 				RADEON_CG_SUPPORT_SDMA_LS |
 				RADEON_CG_SUPPORT_BIF_LS |
 				RADEON_CG_SUPPORT_VCE_MGCG |
-				RADEON_CG_SUPPORT_UVD_MGCG |
+				//RADEON_CG_SUPPORT_UVD_MGCG |
 				RADEON_CG_SUPPORT_HDP_LS |
 				RADEON_CG_SUPPORT_HDP_MGCG;
 			rdev->pg_flags = 0;
@@ -2676,7 +2679,7 @@
 				RADEON_CG_SUPPORT_SDMA_LS |
 				RADEON_CG_SUPPORT_BIF_LS |
 				RADEON_CG_SUPPORT_VCE_MGCG |
-				RADEON_CG_SUPPORT_UVD_MGCG |
+				//RADEON_CG_SUPPORT_UVD_MGCG |
 				RADEON_CG_SUPPORT_HDP_LS |
 				RADEON_CG_SUPPORT_HDP_MGCG;
 			rdev->pg_flags = 0;
@@ -2689,8 +2692,10 @@
 				RADEON_PG_SUPPORT_RLC_SMU_HS |
 				RADEON_PG_SUPPORT_SAMU;*/
 		}
-		rdev->has_uvd = true;
-		rdev->has_vce = true;
+		//rdev->has_uvd = true;
+		//rdev->has_vce = true;
+		rdev->has_uvd = false;
+		rdev->has_vce = false;
 		break;
 	default:
 		/* FIXME: not supported yet */
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_audio.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_audio.c	2023-04-17 23:37:25.948082249 +0200
@@ -274,8 +274,13 @@
 
 	/* disable audio.  it will be set up later */
 	for (i = 0; i < rdev->audio.num_pins; i++)
+	{
 		radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
-
+		/* LVP has standalone S/PDIF on the third pin, always enable */
+		if (rdev->family == CHIP_LIVERPOOL) {
+			radeon_audio_enable(rdev, &rdev->audio.pin[i], 0xf);
+		}
+	}
 	return 0;
 }
 
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_connectors.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_connectors.c	2023-04-17 23:37:25.949082274 +0200
@@ -1513,6 +1513,30 @@
 	.force = radeon_dvi_force,
 };
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector);
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+
+static const struct drm_connector_helper_funcs radeon_ps4_dp_connector_helper_funcs = {
+	.get_modes = radeon_ps4_bridge_get_modes,
+	.mode_valid = radeon_ps4_bridge_mode_valid,
+	.best_encoder = radeon_dvi_encoder,
+};
+
+static const struct drm_connector_funcs radeon_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = radeon_ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = radeon_connector_set_property,
+	.destroy = radeon_connector_destroy,
+	.force = radeon_dvi_force,
+};
+
+#endif
+
 static int radeon_dp_get_modes(struct drm_connector *connector)
 {
 	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
@@ -1846,6 +1870,7 @@
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1896,7 +1921,16 @@
 	radeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);
 	if (!radeon_connector)
 		return;
-
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (rdev->family == CHIP_LIVERPOOL) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &radeon_connector->base;
 
 	radeon_connector->connector_id = connector_id;
@@ -1956,12 +1990,17 @@
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
-			drm_connector_init_with_ddc(dev, &radeon_connector->base,
-						    &radeon_dp_connector_funcs,
-						    connector_type,
-						    ddc);
-			drm_connector_helper_add(&radeon_connector->base,
-						 &radeon_dp_connector_helper_funcs);
+			if (is_ps4_bridge) {
+ 				drm_connector_init(dev, &radeon_connector->base,
+ 						   &radeon_dp_connector_funcs, connector_type);
+ 				drm_connector_helper_add(&radeon_connector->base,
+ 							 &radeon_dp_connector_helper_funcs);
+ 			} else {
+ 				drm_connector_init(dev, &radeon_connector->base,
+ 						   &radeon_ps4_dp_connector_funcs, connector_type);
+ 				drm_connector_helper_add(&radeon_connector->base,
+ 							 &radeon_ps4_dp_connector_helper_funcs);
+ 			}
 			drm_object_attach_property(&radeon_connector->base.base,
 						      rdev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_device.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_device.c	2023-04-17 23:37:25.950082298 +0200
@@ -108,6 +108,7 @@
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
 	"HAWAII",
 	"MULLINS",
 	"LAST",
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_display.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_display.c	2023-04-17 23:37:25.952082347 +0200
@@ -694,7 +694,7 @@
 	radeon_crtc->flip_queue = alloc_workqueue("radeon-crtc", WQ_HIGHPRI, 0);
 	rdev->mode_info.crtcs[index] = radeon_crtc;
 
-	if (rdev->family >= CHIP_BONAIRE) {
+	if (rdev->family >= CHIP_BONAIRE) && rdev->family != CHIP_LIVERPOOL) {
 		radeon_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
 		radeon_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
 	} else {
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_drv.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_drv.c	2023-04-17 23:37:25.952082347 +0200
@@ -50,6 +50,11 @@
 #include <drm/radeon_drm.h>
 
 #include "radeon_drv.h"
+
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "radeon.h"
 #include "radeon_kms.h"
 #include "radeon_ttm.h"
@@ -315,6 +320,7 @@
 		case CHIP_HAWAII:
 		case CHIP_KABINI:
 		case CHIP_MULLINS:
+		case CHIP_LIVERPOOL:
 			dev_info(&pdev->dev,
 				 "CIK support disabled by module param\n");
 			return -ENODEV;
@@ -329,6 +335,16 @@
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
+
 	dev = drm_dev_alloc(&kms_driver, &pdev->dev);
 	if (IS_ERR(dev))
 		return PTR_ERR(dev);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_encoders.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_encoders.c	2023-04-17 23:37:25.953082372 +0200
@@ -204,6 +204,22 @@
 		acpi_video_register_backlight();
 }
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void radeon_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct radeon_device *rdev = dev->dev_private;
+
+	if (rdev->family == CHIP_LIVERPOOL) {
+		radeon_ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 radeon_link_encoder_connector(struct drm_device *dev)
 {
@@ -218,6 +234,9 @@
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			radeon_encoder = to_radeon_encoder(encoder);
 			if (radeon_encoder->devices & radeon_connector->devices) {
+#ifdef CONFIG_X86_PS4
+				radeon_maybe_add_bridge(connector, encoder);
+#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
 					radeon_encoder_add_backlight(radeon_encoder, connector);
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_family.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_family.h	2023-04-17 23:37:25.954082396 +0200
@@ -96,6 +96,7 @@
 	CHIP_BONAIRE,
 	CHIP_KAVERI,
 	CHIP_KABINI,
+	CHIP_LIVERPOOL,
 	CHIP_HAWAII,
 	CHIP_MULLINS,
 	CHIP_LAST,
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_ib.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_ib.c	2023-04-17 23:37:25.955082421 +0200
@@ -260,7 +260,8 @@
 	unsigned i;
 	int r;
 
-	for (i = 0; i < RADEON_NUM_RINGS; ++i) {
+	//for (i = 0; i < RADEON_NUM_RINGS; ++i) {
+	for (i = 0; i < 1; ++i) { // RADEON_NUM_RINGS
 		struct radeon_ring *ring = &rdev->ring[i];
 
 		if (!ring->ready)
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_pm.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_pm.c	2023-04-17 23:37:25.956082446 +0200
@@ -1555,6 +1555,7 @@
 	case CHIP_BONAIRE:
 	case CHIP_KABINI:
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		/* DPM requires the RLC, RV770+ dGPU requires SMC */
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_ucode.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_ucode.h	2023-04-17 23:37:25.957082470 +0200
@@ -38,6 +38,8 @@
 #define CIK_PFP_UCODE_SIZE           2144
 #define CIK_ME_UCODE_SIZE            2144
 #define CIK_CE_UCODE_SIZE            2144
+#define LIVERPOOL_PFP_UCODE_SIZE     4192
+#define LIVERPOOL_ME_UCODE_SIZE      4192
 
 /* MEC */
 #define CIK_MEC_UCODE_SIZE           4192
@@ -53,6 +55,7 @@
 #define KB_RLC_UCODE_SIZE            2560
 #define KV_RLC_UCODE_SIZE            2560
 #define ML_RLC_UCODE_SIZE            2560
+#define LIVERPOOL_RLC_UCODE_SIZE     1536
 
 /* MC */
 #define BTC_MC_UCODE_SIZE            6024
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_uvd.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_uvd.c	2023-04-17 23:37:25.957082470 +0200
@@ -50,6 +50,7 @@
 #define FIRMWARE_TAHITI		"radeon/TAHITI_uvd.bin"
 #define FIRMWARE_BONAIRE_LEGACY	"radeon/BONAIRE_uvd.bin"
 #define FIRMWARE_BONAIRE	"radeon/bonaire_uvd.bin"
+#define FIRMWARE_LIVERPOOL      "radeon/liverpool_uvd.bin"
 
 MODULE_FIRMWARE(FIRMWARE_R600);
 MODULE_FIRMWARE(FIRMWARE_RS780);
@@ -60,6 +61,7 @@
 MODULE_FIRMWARE(FIRMWARE_TAHITI);
 MODULE_FIRMWARE(FIRMWARE_BONAIRE_LEGACY);
 MODULE_FIRMWARE(FIRMWARE_BONAIRE);
+MODULE_FIRMWARE(FIRMWARE_LIVERPOOL);
 
 static void radeon_uvd_idle_work_handler(struct work_struct *work);
 
@@ -130,6 +132,10 @@
 		fw_name = FIRMWARE_BONAIRE;
 		break;
 
+	case CHIP_LIVERPOOL:
+                legacy_fw_name = FIRMWARE_LIVERPOOL;
+                break;
+
 	default:
 		return -EINVAL;
 	}
--- linux-6.1.13-xanmod-rt7/drivers/gpu/drm/radeon/radeon_vce.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/gpu/drm/radeon/radeon_vce.c	2023-04-17 23:37:25.958082495 +0200
@@ -39,10 +39,12 @@
 
 /* Firmware Names */
 #define FIRMWARE_TAHITI	"radeon/TAHITI_vce.bin"
-#define FIRMWARE_BONAIRE	"radeon/BONAIRE_vce.bin"
+#define FIRMWARE_BONAIRE "radeon/BONAIRE_vce.bin"
+#define FIRMWARE_BONAIRE "radeon/LIVERPOOL_vce.bin"
 
 MODULE_FIRMWARE(FIRMWARE_TAHITI);
 MODULE_FIRMWARE(FIRMWARE_BONAIRE);
+MODULE_FIRMWARE(FIRMWARE_LIVERPOOL);
 
 static void radeon_vce_idle_work_handler(struct work_struct *work);
 
@@ -80,6 +82,10 @@
 		fw_name = FIRMWARE_BONAIRE;
 		break;
 
+	case CHIP_LIVERPOOL:
+                fw_name = FIRMWARE_LIVERPOOL;
+                break;
+
 	default:
 		return -EINVAL;
 	}
--- linux-6.1.13-xanmod-rt7/drivers/hwmon/fam15h_power.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/hwmon/fam15h_power.c	2023-04-17 23:37:25.959082519 +0200
@@ -486,6 +486,7 @@
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F4) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
+	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M41H_F4) },
 	{}
 };
 MODULE_DEVICE_TABLE(pci, fam15h_power_id_table);
--- linux-6.1.13-xanmod-rt7/drivers/hwmon/k10temp.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/hwmon/k10temp.c	2023-04-17 23:37:25.960082544 +0200
@@ -493,6 +493,7 @@
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M70H_NB_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
+	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_M41H_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
--- linux-6.1.13-xanmod-rt7/drivers/iommu/amd/init.c	2023-05-10 20:56:44.412290205 +0200
+++ linux-6.1.13-PS4-rt7/drivers/iommu/amd/init.c	2023-04-17 23:37:25.962082593 +0200
@@ -2878,6 +2878,8 @@
 	free_pci_segments();
 }
 
+#ifndef CONFIG_X86_PS4 // TODO this should detect ps4-ness at runtime
+
 /* SB IOAPIC is always on this device in AMD systems */
 #define IOAPIC_SB_DEVID		((0x00 << 8) | PCI_DEVFN(0x14, 0))
 
@@ -2929,7 +2931,7 @@
 
 	return ret;
 }
-
+#endif
 static void __init free_dma_resources(void)
 {
 	free_pages((unsigned long)amd_iommu_pd_alloc_bitmap,
@@ -3029,8 +3031,9 @@
 	if (!is_kdump_kernel() || amd_iommu_disabled)
 		disable_iommus();
 
-	if (amd_iommu_irq_remap)
+	/*if (amd_iommu_irq_remap)
 		amd_iommu_irq_remap = check_ioapic_information();
+	*/
 
 	if (amd_iommu_irq_remap) {
 		struct amd_iommu_pci_seg *pci_seg;
--- linux-6.1.13-xanmod-rt7/drivers/mmc/host/sdhci-pci-core.c	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/mmc/host/sdhci-pci-core.c	2023-05-19 00:14:39.363025674 +0200
@@ -37,6 +37,10 @@
 
 #include "cqhci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "sdhci.h"
 #include "sdhci-pci.h"
 
@@ -340,6 +344,54 @@
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
 
+#ifdef CONFIG_X86_PS4
+static int aeolia_probe(struct sdhci_pci_chip *chip)
+{
+	chip->num_slots = 1;
+	chip->first_bar = 0;
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	chip->pdev->class &= ~0x0000FF;
+	chip->pdev->class |= PCI_SDHCI_IFDMA;
+	return 0;
+}
+
+static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	if (err <= 0) {
+		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
+		return -ENODEV;
+	}
+	slot->host->irq = slot->chip->pdev->irq;
+	return 0;
+}
+
+static void aeolia_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+	apcie_free_irqs(slot->chip->pdev->irq, 1);
+}
+
+/*static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
+{
+	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	return 0;
+}
+*/
+static const struct sdhci_pci_fixes sdhci_aeolia = {
+	.probe		= aeolia_probe,
+	.probe_slot	= aeolia_probe_slot,
+	.remove_slot	= aeolia_remove_slot,
+//	.enable_dma	= aeolia_enable_dma,
+};
+#endif
+
 static int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)
 {
 	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;
@@ -1905,6 +1957,11 @@
 	SDHCI_PCI_DEVICE(O2, SEABIRD1, o2),
 	SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
 	SDHCI_PCI_DEVICE(SYNOPSYS, DWC_MSHC, snps),
+	#ifdef CONFIG_X86_PS4
+	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
+	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
+	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+	#endif
 	SDHCI_PCI_DEVICE(GLI, 9750, gl9750),
 	SDHCI_PCI_DEVICE(GLI, 9755, gl9755),
 	SDHCI_PCI_DEVICE(GLI, 9763E, gl9763e),
@@ -1939,6 +1996,10 @@
 
 	pci_set_master(pdev);
 
+	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
+ 		return slot->chip->fixes->enable_dma(slot);
+ 	}
+
 	return 0;
 }
 
@@ -2034,12 +2095,14 @@
 \*****************************************************************************/
 
 static struct sdhci_pci_slot *sdhci_pci_probe_slot(
-	struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	//struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	struct pci_dev *pdev, struct sdhci_pci_chip *chip,
 	int slotno)
 {
 	struct sdhci_pci_slot *slot;
 	struct sdhci_host *host;
-	int ret, bar = first_bar + slotno;
+	int ret, bar = chip->first_bar + slotno;
+	//int ret, bar = first_bar + slotno;
 	size_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;
 
 	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
@@ -2235,6 +2298,7 @@
 		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
 	}
 	chip->num_slots = slots;
+	chip->first_bar = first_bar;
 	chip->pm_retune = true;
 	chip->rpm_retune = true;
 
@@ -2249,7 +2313,8 @@
 	slots = chip->num_slots;	/* Quirk may have changed this */
 
 	for (i = 0; i < slots; i++) {
-		slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
+		slot = sdhci_pci_probe_slot(pdev, chip, i);
+		//slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
 		if (IS_ERR(slot)) {
 			for (i--; i >= 0; i--)
 				sdhci_pci_remove_slot(chip->slots[i]);
--- linux-6.1.13-xanmod-rt7/drivers/mmc/host/sdhci-pci.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/mmc/host/sdhci-pci.h	2023-05-19 00:16:19.776498239 +0200
@@ -140,7 +140,7 @@
 	int			(*probe_slot) (struct sdhci_pci_slot *);
 	int			(*add_host) (struct sdhci_pci_slot *);
 	void			(*remove_slot) (struct sdhci_pci_slot *, int);
-
+	int			(*enable_dma) (struct sdhci_pci_slot *);
 #ifdef CONFIG_PM_SLEEP
 	int			(*suspend) (struct sdhci_pci_chip *);
 	int			(*resume) (struct sdhci_pci_chip *);
@@ -157,6 +157,11 @@
 struct sdhci_pci_slot {
 	struct sdhci_pci_chip	*chip;
 	struct sdhci_host	*host;
+	struct sdhci_pci_data   *data;
+
+	int                     rst_n_gpio;
+        int                     cd_gpio;
+        int                     cd_irq;
 
 	int			cd_idx;
 	bool			cd_override_level;
@@ -176,6 +181,7 @@
 	const struct sdhci_pci_fixes *fixes;
 
 	int			num_slots;	/* Slots on controller */
+	int			first_bar;	/* First valid BAR */
 	struct sdhci_pci_slot	*slots[MAX_SLOTS]; /* Pointers to host slots */
 };
 
--- linux-6.1.13-xanmod-rt7/drivers/net/ethernet/marvell/sky2.c	2023-05-10 20:56:44.679291469 +0200
+++ linux-6.1.13-PS4-rt7/drivers/net/ethernet/marvell/sky2.c	2023-05-13 05:01:00.455396878 +0200
@@ -38,6 +38,11 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#include "../../../ps4/aeolia.h"
+#endif
+
 #include "sky2.h"
 
 #define DRV_NAME		"sky2"
@@ -133,6 +138,9 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4380) }, /* 88E8057 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4381) }, /* 88E8059 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) }, /* 88E8079 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
 	{ 0 }
 };
 
@@ -153,7 +161,7 @@
 
 	gma_write16(hw, port, GM_SMI_DATA, val);
 	gma_write16(hw, port, GM_SMI_CTRL,
-		    GM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));
+		    GM_SMI_CT_PHY_AD(hw->phy_addr) | GM_SMI_CT_REG_AD(reg));
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -178,8 +186,11 @@
 {
 	int i;
 
-	gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)
-		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+	/* gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)
+		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD); */
+
+	gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(hw->phy_addr)
+   		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -1374,7 +1385,7 @@
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
-		data->phy_id = PHY_ADDR_MARV;
+		data->phy_id = hw->phy_addr;
 
 		fallthrough;
 	case SIOCGMIIREG: {
@@ -3233,6 +3244,24 @@
 	int i;
 	u32 hwe_mask = Y2_HWE_ALL_MASK;
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		u32 val1, val2;
+
+		sky2_write32(hw, 0x60, 0x32100);
+		sky2_write32(hw, 0x64, 6);
+		sky2_write32(hw, 0x68, 0x63b9c);
+		sky2_write32(hw, 0x6c, 0x300);
+		val1 = sky2_read32(hw, 0x158);
+		val2 = sky2_read32(hw, 0x160);
+		val1 &= ~0x33333333;
+		val2 &= ~0xCC00000;
+		sky2_write32(hw, 0x158, val1);
+		sky2_write32(hw, 0x160, val2);
+	}
+	#endif
+
 	/* disable ASF */
 	if (hw->chip_id == CHIP_ID_YUKON_EX
 	    || hw->chip_id == CHIP_ID_YUKON_SUPR) {
@@ -3297,6 +3326,13 @@
 		sky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);
 	}
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		; /* Do not perform phy resets on aeolia, it will hang */
+	} else
+	#endif
+
 	if (hw->chip_id == CHIP_ID_YUKON_OPT ||
 	    hw->chip_id == CHIP_ID_YUKON_PRM ||
 	    hw->chip_id == CHIP_ID_YUKON_OP_2) {
@@ -3581,7 +3617,7 @@
 	u32 supported, advertising;
 
 	supported = sky2_supported_modes(hw);
-	cmd->base.phy_address = PHY_ADDR_MARV;
+	cmd->base.phy_address = hw->phy_addr;
 	if (sky2_is_copper(hw)) {
 		cmd->base.port = PORT_TP;
 		cmd->base.speed = sky2->speed;
@@ -4587,6 +4623,44 @@
   },
 };
 
+#ifdef CONFIG_X86_PS4
+/* NOTE: This region is no longer referenced by current ps4 x86 code. */
+/* However it still contains the mac address. */
+static void aeolia_get_mac_address(struct sky2_hw *hw, unsigned char *addr) {
+        u8 default_addr[ETH_ALEN] = { 0x52, 0x54, 0x00, 0xf0, 0xff, 0x0f };
+        unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(hw->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+        struct pci_dev *mem_dev;
+        phys_addr_t bp_base;
+        void __iomem *bp;
+
+        memcpy(addr, default_addr, sizeof(default_addr));
+
+        mem_dev = pci_get_slot(hw->pdev->bus, mem_devfn);
+        if (!mem_dev) {
+                dev_err(&hw->pdev->dev, "sky2: could not get handle to mem device\n");
+                return;
+        }
+
+	bp_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_BP_BASE;
+        if (!request_mem_region(bp_base, APCIE_SPM_BP_SIZE, "spm.bp")) {
+                dev_err(&hw->pdev->dev, "sky2: failed to request bootparam SPM region\n");
+                return;
+        }
+
+	bp = ioremap(bp_base, APCIE_SPM_BP_SIZE);
+        if (!bp) {
+                dev_err(&hw->pdev->dev, "sky2: failed to map bootparam portion of SPM\n");
+                goto release_bp;
+        }
+
+	memcpy_fromio(addr, bp, ETH_ALEN);
+
+        iounmap(bp);
+release_bp:
+	release_mem_region(bp_base, APCIE_SPM_BP_SIZE);
+}
+#endif
+
 /* Initialize network device */
 static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 					   int highmem, int wol)
@@ -4659,16 +4733,26 @@
 	else
 		dev->max_mtu = ETH_JUMBO_MTU;
 
+	#ifdef CONFIG_X86_PS4
+	if (hw->pdev->vendor == PCI_VENDOR_ID_SONY) {
+		aeolia_get_mac_address(hw, dev->dev_addr);
+	} else
+	#endif
+	{
 	/* try to get mac address in the following order:
 	 * 1) from device tree data
 	 * 2) from internal registers set by bootloader
 	 */
-	ret = of_get_ethdev_address(hw->pdev->dev.of_node, dev);
-	if (ret) {
+	ret = of_get_mac_address(hw->pdev->dev.of_node, dev->dev_addr);
+	// ret = of_get_ethdev_address(hw->pdev->dev.of_node, dev);
+	if (ret)
+                        memcpy_fromio(dev->dev_addr,
+                                      hw->regs + B2_MAC_1 + port * 8, ETH_ALEN);
+	/* if (ret) {
 		u8 addr[ETH_ALEN];
 
 		memcpy_fromio(addr, hw->regs + B2_MAC_1 + port * 8, ETH_ALEN);
-		eth_hw_addr_set(dev, addr);
+		eth_hw_addr_set(dev, addr); */
 	}
 
 	/* if the address is invalid, use a random value */
@@ -4821,6 +4905,12 @@
 	u32 reg;
 	char buf1[16];
 
+	#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+	#endif
+
 	err = pci_enable_device(pdev);
 	if (err) {
 		dev_err(&pdev->dev, "cannot enable PCI device\n");
@@ -4851,7 +4941,17 @@
 	}
 
 	pci_set_master(pdev);
-
+/*
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(31)) < 0 ||
+		    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(31)) < 0) {
+			dev_err(&pdev->dev, "no usable DMA configuration\n");
+			goto err_out_free_regions;
+		}
+	} else
+#endif
+*/
 	if (sizeof(dma_addr_t) > sizeof(u32) &&
 	    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
 		using_dac = 1;
@@ -4900,6 +5000,16 @@
 		goto err_out_free_hw;
 	}
 
+	hw->phy_addr = PHY_ADDR_MARV;
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		/* aeolia supports some sort of "l2 switch" */
+		/* it has normal phy at addr 1 with a possibly-active switch at addr 2 */
+		hw->phy_addr = 1;
+	}
+	#endif
+
 	err = sky2_init(hw);
 	if (err)
 		goto err_out_iounmap;
@@ -4928,6 +5038,19 @@
 	if (disable_msi == -1)
 		disable_msi = !!dmi_check_system(msi_blacklist);
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+		apcie_assign_irqs(pdev, 1) > 0) {
+		err = sky2_test_msi(hw);
+		if (err) {
+			apcie_free_irqs(pdev->irq, 1);
+			/* PS4 requires MSI, so if it fails, bail out. */
+			goto err_out_free_netdev;
+               }
+		hw->flags |= SKY2_HW_USE_AEOLIA_MSI;
+	} else
+	#endif
+
 	if (!disable_msi && pci_enable_msi(pdev) == 0) {
 		err = sky2_test_msi(hw);
 		if (err) {
@@ -4984,8 +5107,13 @@
 err_out_unregister:
 	unregister_netdev(dev);
 err_out_free_netdev:
-	if (hw->flags & SKY2_HW_USE_MSI)
-		pci_disable_msi(pdev);
+	#ifdef CONFIG_X86_PS4
+	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+		apcie_free_irqs(pdev->irq, 1);
+	else
+	#endif
+		if (hw->flags & SKY2_HW_USE_MSI)
+			pci_disable_msi(pdev);
 	free_netdev(dev);
 err_out_free_pci:
 	dma_free_coherent(&pdev->dev,
@@ -5032,6 +5160,12 @@
 		free_irq(pdev->irq, hw);
 	}
 
+	#ifdef CONFIG_X86_PS4
+  	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+  		apcie_free_irqs(pdev->irq, 1);
+  	else
+	#endif
+
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	dma_free_coherent(&pdev->dev,
--- linux-6.1.13-xanmod-rt7/drivers/net/ethernet/marvell/sky2.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/net/ethernet/marvell/sky2.h	2023-05-11 21:38:49.652293952 +0200
@@ -2289,6 +2289,8 @@
 #define SKY2_HW_RSS_CHKSUM	0x00000400	/* RSS requires chksum */
 #define SKY2_HW_IRQ_SETUP	0x00000800
 
+#define SKY2_HW_USE_AEOLIA_MSI  0x00001000
+
 	u8	     	     chip_id;
 	u8		     chip_rev;
 	u8		     pmd_type;
@@ -2303,6 +2305,7 @@
 	struct work_struct   restart_work;
 	wait_queue_head_t    msi_wait;
 
+	u8                   phy_addr;
 	char		     irq_name[];
 };
 
--- linux-6.1.13-xanmod-rt7/drivers/pci/probe.c	2023-05-10 20:56:44.886292450 +0200
+++ linux-6.1.13-PS4-rt7/drivers/pci/probe.c	2023-04-17 23:37:25.969082764 +0200
@@ -2637,6 +2637,9 @@
 	return 0;
 }
 
+// It can be arbitrary (above 2). Freebsd uses 20, so use that too.
+#define AEOLIA_SLOT_NUM 20
+
 /**
  * pci_scan_slot - Scan a PCI slot on a bus for devices
  * @bus: PCI bus to scan
@@ -2648,15 +2651,23 @@
  *
  * Returns the number of new devices found.
  */
+
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 	int fn = 0, nr = 0;
+	u32 l;
 
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
 
 	do {
+		// skip phantom Aeolia devices that bleed through the PCI space
+		if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+			pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000) &&
+			(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+			return 0;
+		}
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
 			if (!pci_dev_is_added(dev))
@@ -2673,6 +2684,11 @@
 				break;
 		}
 		fn = next_fn(bus, dev, fn);
+		if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+			pci_bus_read_dev_vendor_id(bus, devfn + fn, &l, 60*1000) &&
+			(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+			continue;
+		}
 	} while (fn >= 0);
 
 	/* Only one slot has PCIe device */
--- linux-6.1.13-xanmod-rt7/drivers/ps4/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/Makefile	2023-04-26 23:13:29.143943384 +0200
@@ -0,0 +1,9 @@
+# Aeolia PCI devices
+# LISTED IN INIT ORDER \o/ ...  ._.
+# N.B. this driver must be init'd before pretty much everything, but actual dependants are:
+# drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
+obj-y += ps4-apcie.o \
+	ps4-apcie-uart.o \
+	ps4-apcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o \
--- linux-6.1.13-xanmod-rt7/drivers/ps4/aeolia.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/aeolia.h	2023-04-26 23:43:58.196915111 +0200
@@ -0,0 +1,172 @@
+#ifndef _AEOLIA_H
+#define _AEOLIA_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+enum aeolia_func_id {
+	AEOLIA_FUNC_ID_ACPI = 0,
+	AEOLIA_FUNC_ID_GBE,
+	AEOLIA_FUNC_ID_AHCI,
+	AEOLIA_FUNC_ID_SDHCI,
+	AEOLIA_FUNC_ID_PCIE,
+	AEOLIA_FUNC_ID_DMAC,
+	AEOLIA_FUNC_ID_MEM,
+	AEOLIA_FUNC_ID_XHCI,
+
+	AEOLIA_NUM_FUNCS
+};
+
+/* MSI registers for up to 31, but only 23 known. */
+#define APCIE_NUM_SUBFUNC		23
+
+/* Sub-functions, aka MSI vectors */
+enum apcie_subfunc {
+	APCIE_SUBFUNC_GLUE	= 0,
+	APCIE_SUBFUNC_ICC	= 3,
+	APCIE_SUBFUNC_HPET	= 5,
+	APCIE_SUBFUNC_SFLASH	= 11,
+	APCIE_SUBFUNC_RTC	= 13,
+	APCIE_SUBFUNC_UART0	= 19,
+	APCIE_SUBFUNC_UART1	= 20,
+	APCIE_SUBFUNC_TWSI	= 21,
+
+	APCIE_NUM_SUBFUNCS	= 23
+};
+
+#define APCIE_NR_UARTS 2
+
+/* Relative to BAR2 */
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+
+#define APCIE_RGN_CHIPID_BASE		0x1000
+#define APCIE_RGN_CHIPID_SIZE		0x1000
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Relative to BAR4 */
+#define APCIE_RGN_UART_BASE		0x140000
+#define APCIE_RGN_UART_SIZE		0x1000
+
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+
+#define APCIE_RGN_ICC_BASE		0x184000
+#define APCIE_RGN_ICC_SIZE		0x1000
+
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+/* This register has non-uniform structure per function, dealt with in code */
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+/* Not sure what the two individual bits do */
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+/* Enable for the entire function, 4 is special */
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+
+#define APCIE_REG_ICC(x)		(APCIE_RGN_ICC_BASE + (x))
+#define APCIE_REG_ICC_DOORBELL		APCIE_REG_ICC(0x804)
+#define APCIE_REG_ICC_STATUS		APCIE_REG_ICC(0x814)
+#define APCIE_REG_ICC_IRQ_MASK		APCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define APCIE_ICC_SEND			0x01
+#define APCIE_ICC_ACK			0x02
+
+/* Relative to func6 BAR5 */
+#define APCIE_SPM_ICC_BASE		0x2c000
+#define APCIE_SPM_ICC_SIZE		0x1000
+
+/* Boot params passed from southbridge */
+#define APCIE_SPM_BP_BASE		0x2f000
+#define APCIE_SPM_BP_SIZE		0x20
+
+#define APCIE_SPM_ICC_REQUEST		0x0
+#define APCIE_SPM_ICC_REPLY		0x800
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+struct apcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct apcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct apcie_icc_dev icc;
+};
+
+#define sc_err(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+
+static inline int apcie_irqnum(struct apcie_dev *sc, int index)
+{
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#endif
--- linux-6.1.13-xanmod-rt7/drivers/ps4/icc/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/icc/i2c.c	2023-04-26 23:13:29.144943264 +0200
@@ -0,0 +1,156 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "../aeolia.h"
+
+#define ICC_MAX_READ_DATA 0xff
+#define ICC_MAX_WRITE_DATA 0xf8
+
+/* This is actually multiple nested variable length structures, but since we
+ * currently only support one op per transaction, we hardcode it. */
+struct icc_i2c_msg {
+	/* Header */
+	u8 code;
+	u16 length;
+	u8 count;
+	struct {
+		u8 major;
+		u8 length;
+		u8 minor;
+		u8 count;
+		struct {
+			u8 length;
+			u8 slave_addr;
+			u8 reg_addr;
+			u8 data[ICC_MAX_WRITE_DATA];
+		} xfer;
+	} cmd;
+} __packed;
+
+static int icc_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags,
+			  char read_write, u8 command, int size,
+			  union i2c_smbus_data *data)
+{
+	struct apcie_dev *sc = i2c_get_adapdata(adapter);
+	int ret;
+	struct icc_i2c_msg msg;
+	u8 resultbuf[8 + ICC_MAX_READ_DATA];
+
+	msg.code = 4; /* Don't really know what this is */
+	msg.count = 1;
+	msg.cmd.count = 1;
+	msg.cmd.xfer.slave_addr = addr << 1;
+	msg.cmd.xfer.reg_addr = command;
+	if (read_write == I2C_SMBUS_READ) {
+		msg.cmd.major = 1;
+		msg.cmd.minor = 1;
+		msg.cmd.length = 8;
+		msg.cmd.xfer.data[0] = 0; /* unknown */
+	} else {
+		msg.cmd.major = 2;
+		msg.cmd.minor = 2;
+	}
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		msg.cmd.xfer.length = 1;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 8;
+			msg.cmd.xfer.data[0] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		msg.cmd.xfer.length = 2;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 9;
+			msg.cmd.xfer.data[0] = data->word & 0xff;
+			msg.cmd.xfer.data[1] = data->word >> 8;
+		}
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		msg.cmd.xfer.length = data->block[0];
+		if (read_write == I2C_SMBUS_WRITE) {
+			if (data->block[0] > ICC_MAX_WRITE_DATA) {
+				sc_err("icc-i2c: transaction too large: %d\n",
+				       data->block[0]);
+				return -E2BIG;
+			}
+			msg.cmd.length = 7 + data->block[0];
+			memcpy(msg.cmd.xfer.data, &data->block[1],
+			       data->block[0]);
+		}
+		break;
+	default:
+		sc_err("icc-i2c: unsupported transaction %d\n", size);
+		return -ENOTSUPP;
+	}
+
+	msg.length = msg.cmd.length + 4;
+	ret = apcie_icc_cmd(0x10, 0x0, &msg, msg.length, resultbuf,
+		      sizeof(resultbuf));
+	if (ret < 2 || ret > sizeof(resultbuf)) {
+		sc_err("icc-i2c: icc command failed: %d\n", ret);
+		return -EIO;
+	}
+	if (resultbuf[0] != 0 || resultbuf[1] != 0) {
+		sc_err("icc-i2c: i2c command failed: %d, %d\n",
+		       resultbuf[0], resultbuf[1]);
+		return -EIO;
+	}
+
+	if (read_write == I2C_SMBUS_READ)
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = resultbuf[8];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = resultbuf[8] | (resultbuf[9] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			memcpy(&data->block[1], &resultbuf[8],
+			       data->block[0]);
+			break;
+		}
+
+	return 0;
+}
+
+u32 icc_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm icc_i2c_algo = {
+	.smbus_xfer   = &icc_i2c_smbus_xfer,
+	.functionality = &icc_i2c_functionality,
+};
+
+
+int icc_i2c_init(struct apcie_dev *sc)
+{
+	struct i2c_adapter *i2c;
+	int ret;
+
+	i2c = &sc->icc.i2c;
+	i2c->owner = THIS_MODULE;
+	i2c->algo = &icc_i2c_algo;
+	i2c->algo_data = NULL;
+	i2c->dev.parent = &sc->pdev->dev;
+	strlcpy(i2c->name, "icc", sizeof(i2c->name));
+	i2c_set_adapdata(i2c, sc);
+	ret = i2c_add_adapter(i2c);
+	if (ret < 0) {
+		sc_err("failed to add i2c adapter\n");
+		return ret;
+	}
+	return 0;
+}
+
+void icc_i2c_remove(struct apcie_dev *sc)
+{
+	i2c_del_adapter(&sc->icc.i2c);
+}
--- linux-6.1.13-xanmod-rt7/drivers/ps4/ps4-apcie-icc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/ps4-apcie-icc.c	2023-04-26 23:13:48.243553077 +0200
@@ -0,0 +1,602 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "aeolia.h"
+
+/* There should normally be only one Aeolia device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct apcie_dev *icc_sc;
+DEFINE_MUTEX(icc_mutex);
+
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+#define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+int icc_timeout = 15;
+
+int icc_i2c_init(struct apcie_dev *sc);
+void icc_i2c_remove(struct apcie_dev *sc);
+int icc_pwrbutton_init(struct apcie_dev *sc);
+void icc_pwrbutton_remove(struct apcie_dev *sc);
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct apcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct apcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct apcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, APCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct apcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar4 + APCIE_REG_ICC_STATUS);
+
+		if (status & APCIE_ICC_ACK) {
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & APCIE_ICC_SEND) {
+			iowrite32(APCIE_ICC_SEND,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(APCIE_ICC_SEND, sc->bar4 + APCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _apcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apcie_icc_cmd);
+
+void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	//Turn OFF Usb
+	ret = apcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	
+	//Turn ON Usb
+	ret = apcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = apcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = apcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = apcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = apcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = apcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = apcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = apcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int apcie_icc_init(struct apcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Aeolia, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE,
+				"apcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_STATUS);
+
+	ret = request_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	
+	resetBtWlan();
+//	resetUsbPort();
+	
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+free_irq:
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void apcie_icc_remove(struct apcie_dev *sc)
+{
+	sc_err("apcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+}
+
+void apcie_icc_resume(struct apcie_dev *sc)
+{
+}
+#endif
--- linux-6.1.13-xanmod-rt7/drivers/ps4/ps4-apcie-pwrbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/ps4-apcie-pwrbutton.c	2023-04-26 23:13:48.243553077 +0200
@@ -0,0 +1,69 @@
+#include <linux/input.h>
+#include "aeolia.h"
+
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+{
+	if (sc->icc.pwrbutton_dev) {
+		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
+		input_sync(sc->icc.pwrbutton_dev);
+	}
+}
+
+int icc_pwrbutton_init(struct apcie_dev *sc)
+{
+	int ret = 0;
+	u16 button;
+	struct input_dev *dev;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		sc_err("%s: Not enough memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(KEY_POWER, dev->keybit);
+
+	dev->name = "Power Button";
+	dev->id.bustype = BUS_HOST;
+
+	/* this makes the button look like an acpi power button
+	 * no clue whether anyone relies on that though */
+	dev->id.product = 0x02;
+	dev->phys = "LNXPWRBN/button/input0";
+
+	dev->dev.parent = &sc->pdev->dev;
+	ret = input_register_device(dev);
+	if (ret) {
+		sc_err("%s: Failed to register device\n", __func__);
+		input_free_device(dev);
+		return ret;
+	}
+
+	sc->icc.pwrbutton_dev = dev;
+
+	// enable power button notifications
+	button = 0x100;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable power notifications (%d)\n",
+			__func__, ret);
+	}
+
+	// enable reset button notifications (?)
+	button = 0x102;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable reset notifications (%d)\n",
+		        __func__, ret);
+	}
+
+	return 0;
+}
+
+void icc_pwrbutton_remove(struct apcie_dev *sc)
+{
+	if (sc->icc.pwrbutton_dev)
+		input_free_device(sc->icc.pwrbutton_dev);
+	sc->icc.pwrbutton_dev = NULL;
+}
--- linux-6.1.13-xanmod-rt7/drivers/ps4/ps4-apcie-uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/ps4-apcie-uart.c	2023-05-19 02:40:59.594670553 +0200
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "aeolia.h"
+
+void apcie_uart_remove(struct apcie_dev *sc);
+
+int apcie_uart_init(struct apcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		uint32_t off = APCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= apcie_irqnum(sc, APCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 4) + off;
+		uart.port.membase	= sc->bar4 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			apcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void apcie_uart_remove(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void apcie_uart_resume(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
--- linux-6.1.13-xanmod-rt7/drivers/ps4/ps4-apcie.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/ps4/ps4-apcie.c	2023-05-07 20:04:31.374411773 +0200
@@ -0,0 +1,682 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "aeolia.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[AEOLIA_NUM_FUNCS] = {
+	4, 4, 4, 4, 31, 2, 2, 4
+};
+
+static inline u32 glue_read32(struct apcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar4 + offset);
+}
+
+static inline void glue_write32(struct apcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar4 + offset);
+}
+
+static inline void glue_set_region(struct apcie_dev *sc, u32 func, u32 bar,
+			    u32 base, u32 mask) {
+	glue_write32(sc, APCIE_REG_BAR_MASK(func, bar), mask);
+	glue_write32(sc, APCIE_REG_BAR_ADDR(func, bar), base);
+}
+
+static inline void glue_set_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) | mask, ptr);
+}
+
+static inline void glue_clear_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) & ~mask, ptr);
+}
+
+static inline void glue_mask_and_set(struct apcie_dev *sc, u32 offset, u32 mask, u32 set) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32((ioread32(ptr) & ~mask) | set, ptr);
+}
+
+static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
+			     u32 addr, u32 data) {
+	u32 offset;
+
+	sc_dbg("apcie_config_msi: func: %u, subfunc: %u, addr %08x data: 0x%08x (%u)\n",
+		func, subfunc, addr, data, data);
+
+	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
+
+	if (func < 4) {
+		/* First 4 functions have 4 IRQs/subfuncs each */
+		offset = (func << 4) | (subfunc << 2);
+	} else if (func == 4) {
+		/* Function 4 gets 24 consecutive slots,
+		 * then 7 more at the end. */
+		if (subfunc < 24)
+			offset = 0x40 + (subfunc << 2);
+		else
+			offset = 0xe0 + ((subfunc - 24) << 2);
+	} else {
+		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
+	}
+	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
+
+	if (func == AEOLIA_FUNC_ID_PCIE)
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC4);
+	else
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC);
+
+	glue_set_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+}
+
+static void apcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	/* Linux likes to unconfigure MSIs like this, but since we share the
+	 * address between subfunctions, we can't do that. The IRQ should be
+	 * masked via apcie_msi_mask anyway, so just do nothing. */
+	if (!msg->address_lo) {
+		return;
+	}
+
+	sc_dbg("apcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	if (subfunc == 0xff) {
+		int i;
+		for (i = 0; i < subfuncs_per_func[func]; i++)
+			apcie_config_msi(sc, func, i, msg->address_lo, msg->data);
+	} else {
+		apcie_config_msi(sc, func, subfunc, msg->address_lo, msg->data);
+	}
+}
+
+static void apcie_msi_unmask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_set_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_mask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_clear_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_calc_mask(struct irq_data *data) {
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	if (subfunc == 0xff) {
+		data->mask = (1 << subfuncs_per_func[func]) - 1;
+	} else {
+		data->mask = 1 << subfunc;
+	}
+}
+
+static void apcie_irq_msi_compose_msg(struct irq_data *data,
+                                       struct msi_msg *msg)
+{
+        struct irq_cfg *cfg = irqd_cfg(data);
+
+        memset(msg, 0, sizeof(*msg));
+        msg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;
+        msg->address_lo = 0xfee00000;// Just do it like this for now
+
+        // I know this is absolute horseshit, but it matches a known working kernel
+        msg->data = data->irq - 1;
+
+        pr_err("apcie_irq_msi_compose_msg\n");
+}
+
+static struct irq_chip apcie_msi_controller = {
+	.name = "Aeolia-MSI",
+	.irq_unmask = apcie_msi_unmask,
+	.irq_mask = apcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = apcie_irq_msi_compose_msg,
+	.irq_write_msi_msg = apcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->hwirq;
+}
+
+static int apcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			    handle_edge_irq, NULL, "edge");
+	apcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void apcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("apcie_msi_free(%d)\n", virq);
+}
+
+/*
+static void apcie_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
+{
+        arg->desc = desc;
+        struct pci_dev* device = msi_desc_to_pci_dev(desc);
+
+        arg->hwirq = PCI_FUNC(device->devfn) << 8;
+
+#ifndef QEMU_HACK_NO_IOMMU
+        arg->hwirq |= 0xFF;
+#endif
+}
+*/
+
+static struct msi_domain_ops apcie_msi_domain_ops = {
+	.get_hwirq	= apcie_msi_get_hwirq,
+//	.set_desc       = apcie_set_desc,
+	.msi_init	= apcie_msi_init,
+	.msi_free	= apcie_msi_free,
+};
+
+static struct msi_domain_info apcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,
+	.ops		= &apcie_msi_domain_ops,
+	.chip		= &apcie_msi_controller,
+	.handler	= handle_edge_irq,
+};
+
+/* struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+	struct irq_domain *parent;
+	struct irq_alloc_info info;
+
+	sc_dbg("apcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL)
+		return NULL;
+
+	apcie_msi_domain_info.chip_data = (void *)sc;
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	info.msi_dev = sc->pdev;
+	parent = irq_remapping_get_ir_irq_domain(&info);
+	if (parent == NULL) {
+		parent = x86_vector_domain;
+	} else {
+		apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+		apcie_msi_controller.name = "IR-Aeolia-MSI";
+	}
+
+	return msi_create_irq_domain(NULL, &apcie_msi_domain_info, parent);
+}
+*/
+
+static struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+        struct irq_domain *domain, *parent;
+        struct fwnode_handle *fn;
+        struct irq_fwspec fwspec;
+
+        sc_dbg("apcie_create_irq_domain\n");
+        if (x86_vector_domain == NULL)
+                return NULL;
+
+        apcie_msi_domain_info.chip_data = (void *)sc;
+
+        fn = irq_domain_alloc_named_id_fwnode(apcie_msi_controller.name, pci_dev_id(sc->pdev));
+        if (!fn) {
+                return NULL;
+        }
+
+        sc_dbg("devid = %d\n", pci_dev_id(sc->pdev));
+
+        fwspec.fwnode = fn;
+        fwspec.param_count = 1;
+
+        // It should be correct to put the pci device id in here
+        fwspec.param[0] = pci_dev_id(sc->pdev);
+
+        parent = irq_find_matching_fwspec(&fwspec, DOMAIN_BUS_ANY);
+        if (!parent) {
+                sc_dbg("no parent \n");
+                parent = x86_vector_domain;
+        } else if (parent == x86_vector_domain) {
+                sc_dbg("no parent \n");
+        } else {
+                apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+                apcie_msi_controller.name = "IR-Aeolia-MSI";
+        }
+
+	domain = msi_create_irq_domain(fn, &apcie_msi_domain_info, parent);
+        if (!domain) {
+                irq_domain_free_fwnode(fn);
+                pr_warn("Failed to initialize Aeolia-MSI irqdomain.\n");
+        }
+
+        return domain;
+}
+
+static int apcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct apcie_dev *sc;
+	struct irq_alloc_info info;
+
+	sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!apcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
+	// IRQs "come from" function 4 as far as the IOMMU/system see
+	//info.msi_dev = sc->pdev;
+	info.devid = pci_dev_id(sc->pdev);
+	// Our hwirq number is function << 8 plus subfunction.
+	// Subfunction is usually 0 and implicitly increments per hwirq,
+	// but can also be 0xff to indicate that this is a shared IRQ.
+	info.hwirq = PCI_FUNC(dev->devfn) << 8;
+
+	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		info.hwirq |= 0xff; // Shared IRQ for all subfunctions
+	}
+#endif
+
+	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+	if (ret >= 0) {
+		dev->irq = ret;
+		ret = nvec;
+	}
+
+fail:
+	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(apcie_assign_irqs);
+
+
+/*
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+        int ret;
+        unsigned int sc_devfn;
+        struct pci_dev *sc_dev;
+        struct apcie_dev *sc;
+        struct irq_alloc_info info;
+
+        sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+        sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+        if (!apcie_is_compatible_device(sc_dev)) {
+                dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+                ret = -ENODEV;
+                goto fail;
+        }
+        sc = pci_get_drvdata(sc_dev);
+        if (!sc) {
+                dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+                ret = -ENODEV;
+                goto fail;
+        }
+
+	init_irq_alloc_info(&info, NULL);
+        info.type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
+        // IRQs "come from" function 4 as far as the IOMMU/system see //
+        //info.msi_dev = sc->pdev;
+        info.devid = pci_dev_id(sc->pdev);
+
+        int i, base = 0;
+        struct msi_desc *desc;
+        struct device* bare_dev = &sc->pdev->dev;
+
+        // Our hwirq number is function << 8 plus subfunction.
+        // Subfunction is usually 0 and implicitly increments per hwirq,
+        // but can also be 0xff to indicate that this is a shared IRQ.
+        info.hwirq = PCI_FUNC(dev->devfn) << 8;
+
+#ifndef QEMU_HACK_NO_IOMMU
+        info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+        if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+                nvec = 1;
+                info.hwirq |= 0xff; // Shared IRQ for all subfunctions
+        }
+#endif
+
+        desc = alloc_msi_entry(bare_dev, nvec, NULL);
+
+        info.desc = desc;
+        info.data = sc;
+
+        dev_info(&dev->dev, "apcie_assign_irqs(%d) (%d)\n", nvec, info.hwirq);
+
+        ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+        if (ret >= 0) {
+                dev_info(&dev->dev, "irq_domain_alloc_irqs = %x\n", ret);
+                dev->irq = ret;
+                desc->irq = ret;
+                ret = nvec;
+        }
+
+fail:
+        dev_info(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+        if (sc_dev)
+                pci_dev_put(sc_dev);
+        return ret;
+}
+*/
+
+void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+}
+EXPORT_SYMBOL(apcie_free_irqs);
+
+static void apcie_glue_remove(struct apcie_dev *sc);
+
+static int apcie_glue_init(struct apcie_dev *sc)
+{
+	int i;
+
+	sc_info("apcie glue probe\n");
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE,
+				"apcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE,
+				"apcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		release_mem_region(pci_resource_start(sc->pdev, 4) +
+				   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+		return -EBUSY;
+	}
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_PCIE, 2, 0xbf018000, 0x7fff);
+
+	sc_info("Aeolia chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_0),
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_1),
+		ioread32(sc->bar2 + APCIE_REG_CHIPREV));
+
+	/* Mask all MSIs first, to avoid spurious IRQs */
+	for (i = 0; i < AEOLIA_NUM_FUNCS; i++) {
+		glue_write32(sc, APCIE_REG_MSI_MASK(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_ADDR(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_DATA_HI(i), 0);
+	}
+
+	for (i = 0; i < 0xfc; i += 4)
+		glue_write32(sc, APCIE_REG_MSI_DATA_LO(i), 0);
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_GBE, 0, 0xbfa00000, 0x3fff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_AHCI, 5, 0xbfa04000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 0, 0xbfa80000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 0, 0xbfa05000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 2, 0xbfa06000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 2, 0xc0000000, 0x3fffffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 0, 0xbf400000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 2, 0xbf600000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 4, 0xbf800000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 5, 0, 0);
+
+	sc->irqdomain = apcie_create_irq_domain(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc->nvec = apcie_assign_irqs(sc->pdev, APCIE_NUM_SUBFUNC);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+
+	return 0;
+}
+
+static void apcie_glue_remove(struct apcie_dev *sc) {
+	sc_info("apcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		apcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);
+		sc->irqdomain = NULL;
+	}
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+}
+
+#ifdef CONFIG_PM
+static int apcie_glue_suspend(struct apcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int apcie_glue_resume(struct apcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int apcie_uart_init(struct apcie_dev *sc);
+int apcie_icc_init(struct apcie_dev *sc);
+void apcie_uart_remove(struct apcie_dev *sc);
+void apcie_icc_remove(struct apcie_dev *sc);
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_uart_resume(struct apcie_dev *sc);
+void apcie_icc_resume(struct apcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool apcie_initialized;
+
+static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct apcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "apcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"apcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1 - misc peripherals
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = apcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = apcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = apcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	apcie_initialized = true;
+	return 0;
+
+remove_uart:
+	apcie_uart_remove(sc);
+remove_glue:
+	apcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void apcie_remove(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_remove(sc);
+	apcie_uart_remove(sc);
+	apcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int apcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_suspend(sc, state);
+	apcie_uart_suspend(sc, state);
+	apcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int apcie_resume(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_resume(sc);
+	apcie_glue_resume(sc);
+	apcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id apcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
+
+static struct pci_driver apcie_driver = {
+	.name		= "aeolia_pcie",
+	.id_table	= apcie_pci_tbl,
+	.probe		= apcie_probe,
+	.remove		= apcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= apcie_suspend,
+	.resume		= apcie_resume,
+#endif
+};
+module_pci_driver(apcie_driver);
--- linux-6.1.13-xanmod-rt7/drivers/usb/host/Kconfig	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/usb/host/Kconfig	2023-04-17 23:37:25.974082887 +0200
@@ -104,6 +104,13 @@
 	  Say 'Y' to enable the support for the xHCI host controller
 	  found in NVIDIA Tegra124 and later SoCs.
 
+config USB_XHCI_AEOLIA
+	tristate "xHCI support for Sony PS4 (Aeolia)"
+	depends on X86_PS4
+	help
+	  Say 'Y' to enable the support for the xHCI host controller
+	  found in the Sony PlayStation 4.
+
 endif # USB_XHCI_HCD
 
 config USB_EHCI_BRCMSTB
--- linux-6.1.13-xanmod-rt7/drivers/usb/host/Makefile	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/usb/host/Makefile	2023-04-17 23:37:25.974082887 +0200
@@ -74,6 +74,7 @@
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
 obj-$(CONFIG_USB_XHCI_MTK)	+= xhci-mtk-hcd.o
 obj-$(CONFIG_USB_XHCI_TEGRA)	+= xhci-tegra.o
+obj-$(CONFIG_USB_XHCI_AEOLIA)	+= xhci-aeolia.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
--- linux-6.1.13-xanmod-rt7/drivers/usb/host/xhci-aeolia.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/usb/host/xhci-aeolia.c	2023-05-13 07:09:05.160958909 +0200
@@ -0,0 +1,579 @@
+/*
+ * xhci-aeoliat.c - xHCI host controller driver for Aeolia (Sony PS4)
+ *
+ * Borrows code from xhci-pci.c, hcd-pci.c, and xhci-plat.c.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <asm/ps4.h>
+#include "xhci-aeolia.h"
+#include "../../ps4/aeolia.h"
+
+#include "xhci.h"
+
+static const char hcd_name[] = "xhci_aeolia";
+
+static struct hc_driver __read_mostly xhci_aeolia_hc_driver;
+
+#define NR_DEVICES 3
+
+struct aeolia_xhci {
+	struct ata_host *host;
+	int nr_irqs;
+	struct usb_hcd *hcd[NR_DEVICES];
+};
+
+static int xhci_aeolia_setup(struct usb_hcd *hcd);
+
+static const struct xhci_driver_overrides xhci_aeolia_overrides __initconst = {
+	.extra_priv_size = sizeof(struct xhci_hcd),
+	.reset = xhci_aeolia_setup,
+};
+
+static void xhci_aeolia_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * Do not try to enable MSIs, we provide the MSIs ourselves
+	 * Do not touch DMA mask, we need a custom one
+	 */
+	//xhci->quirks |= XHCI_PLAT | XHCI_PLAT_DMA;
+	xhci->quirks |= XHCI_PLAT;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_aeolia_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_aeolia_quirks);
+}
+
+static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
+{
+	int retval;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct hc_driver *driver = &xhci_aeolia_hc_driver;
+	struct usb_hcd *hcd;
+	struct xhci_hcd *xhci;
+	int irq = (axhci->nr_irqs > 1) ? (dev->irq + index) : dev->irq;
+
+	// ok...adding this printk appears to have introduced a delay that fixed
+	// bringup of the middle host controller, so w/e for now...
+
+	printk("xhci_aeolia_probe_one %d, controller is %x\n", index, dev->device);
+
+	hcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));
+	pci_set_drvdata(dev, axhci); /* usb_create_hcd clobbers this */
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pci_resource_start(dev, 2 * index);
+	hcd->rsrc_len = pci_resource_len(dev, 2 * index);
+
+	if (!devm_request_mem_region(&dev->dev, hcd->rsrc_start, hcd->rsrc_len,
+			driver->description)) {
+		dev_dbg(&dev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto put_hcd;
+	}
+	hcd->regs = pci_ioremap_bar(dev, 2 * index);
+	if (hcd->regs == NULL) {
+		dev_dbg(&dev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto release_mem_region;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+
+	xhci = hcd_to_xhci(hcd);
+	xhci->main_hcd = hcd;
+	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
+			pci_name(dev), hcd);
+	if (!xhci->shared_hcd) {
+		retval = -ENOMEM;
+		goto unmap_registers;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto put_usb3_hcd;
+
+	retval = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto dealloc_usb2_hcd;
+
+	axhci->hcd[index] = hcd;
+
+	return 0;
+
+dealloc_usb2_hcd:
+	usb_remove_hcd(hcd);
+put_usb3_hcd:
+	usb_put_hcd(xhci->shared_hcd);
+unmap_registers:
+	iounmap(hcd->regs);
+release_mem_region:
+	devm_release_mem_region(&dev->dev, hcd->rsrc_start, hcd->rsrc_len);
+put_hcd:
+	usb_put_hcd(hcd);
+	dev_err(&dev->dev, "init %s(%d) fail, %d\n",
+			pci_name(dev), index, retval);
+	return retval;
+}
+
+static void xhci_aeolia_remove_one(struct pci_dev *dev, int index)
+{
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct usb_hcd *hcd = axhci->hcd[index];
+	struct xhci_hcd *xhci;
+
+	if (!hcd)
+		return;
+	xhci = hcd_to_xhci(hcd);
+
+	usb_remove_hcd(xhci->shared_hcd);
+	usb_remove_hcd(hcd);
+	usb_put_hcd(xhci->shared_hcd);
+
+	// TODO (ps4patches): Does this really need to be disabled?
+	if(dev->device == PCI_DEVICE_ID_SONY_BELIZE_XHCI) {
+		iounmap(hcd->regs);
+	}
+	usb_put_hcd(hcd);
+	axhci->hcd[index] = NULL;
+}
+
+#define DRV_VERSION	"3.0"
+#define DRV_NAME	"ahci"
+static const struct ata_port_info ahci_port_info = {
+	.flags		= AHCI_FLAG_COMMON,
+	.pio_mask	= ATA_PIO4,
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &ahci_ops,
+};
+
+static struct scsi_host_template ahci_sht = {
+	AHCI_SHT(DRV_NAME),
+};
+
+static bool bus_master;
+static int ahci_init_one(struct pci_dev *pdev)
+{
+	struct f_resource* r_mem;
+	struct ahci_controller* ctlr;
+	struct aeolia_xhci *axhci = pci_get_drvdata(pdev);
+	struct ata_port_info pi = ahci_port_info;
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct ahci_host_priv *hpriv;
+      struct ata_host *host;
+	int n_ports, i, rc;
+	int ahci_pci_bar = 2;
+	resource_size_t		rsrc_start;
+	resource_size_t		rsrc_len;
+
+	// VPRINTK("ENTER\n");
+
+	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
+
+	ata_print_version_once(&pdev->dev, DRV_VERSION);
+
+	/*
+	rc = pcim_iomap_regions_request_all(pdev, 1 << ahci_pci_bar, DRV_NAME);
+	if (rc == -EBUSY)
+		pcim_pin_device(pdev);
+	if (rc)
+		return rc;
+	*/
+
+	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
+	//hpriv = kzalloc(sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	//hpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];
+	rsrc_start = pci_resource_start(pdev, ahci_pci_bar);
+	rsrc_len = pci_resource_len(pdev, ahci_pci_bar);
+	//if (!request_mem_region(rsrc_start, rsrc_len, "xhci-ahci.mem")) {
+	if (!devm_request_mem_region(&pdev->dev, rsrc_start, rsrc_len, "xhci-ahci.mem")) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		rc = -EBUSY;
+		goto put_hpriv;
+	}
+
+
+	hpriv->mmio = pci_ioremap_bar(pdev, ahci_pci_bar);
+	if (hpriv->mmio == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		rc = -EFAULT;
+		goto release_mem_region;
+	}
+
+	r_mem = kzalloc(sizeof(*r_mem), GFP_KERNEL);
+	if (r_mem) {
+		r_mem->r_bustag = 1;//mem
+		r_mem->r_bushandle = hpriv->mmio;
+
+		ctlr = kzalloc(sizeof(*ctlr), GFP_KERNEL);
+		if (ctlr) {
+			ctlr->r_mem = r_mem;
+			ctlr->dev_id = 0; //or 0x90ca104d;
+			ctlr->trace_len = 6;
+			bpcie_sata_phy_init(&pdev->dev, ctlr);
+			kfree(ctlr);
+		}
+		kfree(r_mem);
+	}
+	device_wakeup_enable(&pdev->dev);
+
+	/* save initial config */
+	ahci_save_initial_config(&pdev->dev, hpriv);
+
+	/* prepare host */
+	if (hpriv->cap & HOST_CAP_NCQ) {
+		pi.flags |= ATA_FLAG_NCQ;
+		/*
+		 * Auto-activate optimization is supposed to be
+		 * supported on all AHCI controllers indicating NCQ
+		 * capability, but it seems to be broken on some
+		 * chipsets including NVIDIAs.
+		 */
+		if (!(hpriv->flags & AHCI_HFLAG_NO_FPDMA_AA))
+			pi.flags |= ATA_FLAG_FPDMA_AA;
+
+		/*
+		 * All AHCI controllers should be forward-compatible
+		 * with the new auxiliary field. This code should be
+		 * conditionalized if any buggy AHCI controllers are
+		 * encountered.
+		 */
+		pi.flags |= ATA_FLAG_FPDMA_AUX;
+	}
+
+	if (hpriv->cap & HOST_CAP_PMP)
+		pi.flags |= ATA_FLAG_PMP;
+
+	ahci_set_em_messages(hpriv, &pi);
+
+	/* CAP.NP sometimes indicate the index of the last enabled
+	 * port, at other times, that of the last possible port, so
+	 * determining the maximum port number requires looking at
+	 * both CAP.NP and port_map.
+	 */
+	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host) {
+		rc = -ENOMEM;
+		goto unmap_registers;
+	}
+	axhci->host = host;
+	pci_set_drvdata(pdev, axhci);
+
+	host->private_data = hpriv;
+
+	{
+		int index = 1;
+		int irq = (axhci->nr_irqs > 1) ? (pdev->irq + index) : pdev->irq;
+		hpriv->irq = irq;
+	}
+
+	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
+		host->flags |= ATA_HOST_PARALLEL_SCAN;
+	else
+		dev_info(&pdev->dev, "SSS flag set, parallel bus scan disabled\n");
+
+	if (pi.flags & ATA_FLAG_EM)
+		ahci_reset_em(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		ata_port_pbar_desc(ap, ahci_pci_bar, -1, "abar");
+		ata_port_pbar_desc(ap, ahci_pci_bar,
+				   0x100 + ap->port_no * 0x80, "port");
+
+		/* set enclosure management message type */
+		if (ap->flags & ATA_FLAG_EM)
+			ap->em_message_type = hpriv->em_msg_type;
+
+
+		/* disabled/not-implemented port */
+		if (!(hpriv->port_map & (1 << i)))
+			ap->ops = &ata_dummy_port_ops;
+	}
+
+	rc = ahci_reset_controller(host);
+	dev_dbg(&pdev->dev, "ahci_reset_controller returned %d\n", rc);
+	if (rc)
+		goto release_host;
+
+	ahci_init_controller(host);
+	ahci_print_info(host, "ATA");
+
+	if (!bus_master) {
+		pci_set_master(pdev);
+		bus_master = true;
+	}
+
+	rc = ahci_host_activate(host, &ahci_sht);
+	dev_dbg(&pdev->dev, "ahci_host_activate returned %d\n", rc);
+	if (rc) {
+		goto host_deactivate;
+	}
+
+	pm_runtime_put_noidle(&pdev->dev);
+	return 0;
+
+	host_deactivate:
+	release_host:
+	unmap_registers:
+		iounmap(hpriv->mmio);
+	release_mem_region:
+		devm_release_mem_region(&pdev->dev, rsrc_start, rsrc_len);
+	put_hpriv:
+		//kfree(hpriv);
+		devm_kfree(&pdev->dev, hpriv);
+		dev_err(&pdev->dev, "init %s fail, %d\n",
+				pci_name(pdev), rc);
+	return rc;
+}
+
+static void ahci_remove_one(struct pci_dev *pdev)
+{
+	pm_runtime_get_noresume(&pdev->dev);
+
+	struct aeolia_xhci *axhci = pci_get_drvdata(pdev);
+	if (axhci && axhci->host) {
+		ata_host_detach(axhci->host);
+		struct ahci_host_priv *hpriv = axhci->host->private_data;
+		if (hpriv) {
+			iounmap(hpriv->mmio);
+		}
+		axhci->host = NULL;
+	}
+}
+
+static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int idx;
+	int retval;
+	struct aeolia_xhci *axhci;
+
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	if (pci_enable_device(dev) < 0)
+		return -ENODEV;
+
+	axhci = devm_kzalloc(&dev->dev, sizeof(*axhci), GFP_KERNEL);
+	if (!axhci) {
+		retval = -ENOMEM;
+		goto disable_device;
+	}
+	pci_set_drvdata(dev, axhci);
+
+	axhci->nr_irqs = retval = apcie_assign_irqs(dev, NR_DEVICES);
+	if (retval < 0) {
+		goto free_axhci;
+	}
+
+	if(dev->device != PCI_DEVICE_ID_SONY_BELIZE_XHCI) {
+		pci_set_master(dev);
+	}
+/*
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(31)) ||
+		pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(31))) {
+		return -ENODEV;
+	}
+*/
+	if(dev->device == PCI_DEVICE_ID_SONY_BELIZE_XHCI) {
+		retval = ahci_init_one(dev);
+		dev_dbg(&dev->dev, "ahci_init_one returned %d", retval);
+		if (!bus_master) {
+			pci_set_master(dev);
+			bus_master = true;
+		}
+	}
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1){ //this is for Belize and Baikal
+			continue;
+		}
+		retval = xhci_aeolia_probe_one(dev, idx);
+		if (retval)
+			goto remove_hcds;
+	}
+
+	return 0;
+
+remove_hcds:
+	while (idx--)
+		xhci_aeolia_remove_one(dev, idx);
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+free_axhci:
+	devm_kfree(&dev->dev, axhci);
+
+	// TODO (ps4patches): Don't aeolia and baikal also need this?
+	if(dev->device == PCI_DEVICE_ID_SONY_BELIZE_XHCI) {
+		pci_set_drvdata(dev, NULL);
+	}
+disable_device:
+	pci_disable_device(dev);
+	return retval;
+}
+
+static void xhci_aeolia_remove(struct pci_dev *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	if (!axhci)
+		return;
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1)
+				xhci_aeolia_remove_one(dev, idx);
+			else if (dev->device == PCI_DEVICE_ID_SONY_BELIZE_XHCI)
+				ahci_remove_one(dev);
+		}
+		else
+			xhci_aeolia_remove_one(dev, idx);
+	}
+
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+
+	// TODO (ps4patches): Belize, remove in ahci commit
+	kfree(axhci);
+
+	pci_disable_device(dev);
+}
+
+static void xhci_hcd_pci_shutdown(struct pci_dev *dev){
+
+	// We want to use the normal shutdown if we aren't belize
+	if (dev->device != PCI_DEVICE_ID_SONY_BELIZE_XHCI)
+	{
+		usb_hcd_pci_shutdown(dev);
+		return;
+	}
+
+	struct aeolia_xhci *axhci;
+	struct usb_hcd	   *hcd;
+	int idx;
+
+	axhci = pci_get_drvdata(dev);
+	if (!axhci)
+		return;
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1) {
+				hcd = axhci->hcd[idx];
+				if (hcd) {
+					if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) && hcd->driver->shutdown) {
+						hcd->driver->shutdown(hcd);
+						if (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)
+							free_irq(hcd->irq, hcd);
+					}
+				}
+			}
+		}
+	}
+}
+
+static const struct pci_device_id pci_ids[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_XHCI) },
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+#ifdef CONFIG_PM_SLEEP
+static int xhci_aeolia_suspend(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
+			continue;
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_suspend(xhci, device_may_wakeup(dev));
+		if (retval < 0)
+			goto resume;
+	}
+	return 0;
+
+resume:
+	while (idx--) {
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		xhci_resume(xhci, 0);
+	}
+	return retval;
+}
+
+static int xhci_aeolia_resume(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
+			continue;
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_resume(xhci, 0);
+		if (retval < 0)
+			return retval;
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops xhci_aeolia_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xhci_aeolia_suspend, xhci_aeolia_resume)
+};
+#endif
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver xhci_aeolia_driver = {
+	.name =		"xhci_aeolia",
+	.id_table =	pci_ids,
+
+	.probe =	xhci_aeolia_probe,
+	.remove =	xhci_aeolia_remove,
+	/* suspend and resume implemented later */
+	.shutdown = 	xhci_hcd_pci_shutdown,
+#ifdef CONFIG_PM_SLEEP
+	.driver = {
+		.pm = &xhci_aeolia_pm_ops
+	},
+#endif
+};
+
+static int __init xhci_aeolia_init(void)
+{
+	xhci_init_driver(&xhci_aeolia_hc_driver, &xhci_aeolia_overrides);
+	return pci_register_driver(&xhci_aeolia_driver);
+}
+module_init(xhci_aeolia_init);
+
+static void __exit xhci_aeolia_exit(void)
+{
+	pci_unregister_driver(&xhci_aeolia_driver);
+}
+module_exit(xhci_aeolia_exit);
+
+MODULE_DESCRIPTION("xHCI Aeolia Host Controller Driver");
+MODULE_LICENSE("GPL");
--- linux-6.1.13-xanmod-rt7/drivers/usb/host/xhci-aeolia.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1.13-PS4-rt7/drivers/usb/host/xhci-aeolia.h	2023-05-08 15:06:34.735291769 +0200
@@ -0,0 +1,14 @@
+/*
+ * xhci-aeolia.h
+ *
+ *  Created on: 31 Oct 2019
+ *      Author: visicva
+ */
+
+#ifndef DRIVERS_USB_HOST_XHCI_AEOLIA_H_
+#define DRIVERS_USB_HOST_XHCI_AEOLIA_H_
+
+#include "../../ata/ahci.h"
+#include <linux/irqdomain.h>
+
+#endif /* DRIVERS_USB_HOST_XHCI_AEOLIA_H_ */
--- linux-6.1.13-xanmod-rt7/include/drm/amd_asic_type.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/include/drm/amd_asic_type.h	2023-04-17 23:37:25.979083009 +0200
@@ -34,6 +34,8 @@
 	CHIP_BONAIRE,	/* 5 */
 	CHIP_KAVERI,	/* 6 */
 	CHIP_KABINI,	/* 7 */
+	CHIP_LIVERPOOL,
+	CHIP_GLADIUS,
 	CHIP_HAWAII,	/* 8 */
 	CHIP_MULLINS,	/* 9 */
 	CHIP_TOPAZ,	/* 10 */
--- linux-6.1.13-xanmod-rt7/include/linux/pci_ids.h	2022-12-11 23:15:18.000000000 +0100
+++ linux-6.1.13-PS4-rt7/include/linux/pci_ids.h	2023-04-17 23:37:25.981083058 +0200
@@ -555,6 +555,8 @@
 #define PCI_DEVICE_ID_AMD_16H_NB_F4	0x1534
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F3 0x1583
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F4 0x1584
+#define PCI_DEVICE_ID_AMD_16H_M41H_F3  0x1431
+#define PCI_DEVICE_ID_AMD_16H_M41H_F4  0x1432
 #define PCI_DEVICE_ID_AMD_17H_DF_F3	0x1463
 #define PCI_DEVICE_ID_AMD_17H_M10H_DF_F3 0x15eb
 #define PCI_DEVICE_ID_AMD_17H_M30H_DF_F3 0x1493
@@ -901,6 +903,30 @@
 #define PCI_DEVICE_ID_TI_DRA72x		0xb501
 
 #define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_AEOLIA_ACPI	0x908f
+#define PCI_DEVICE_ID_SONY_AEOLIA_GBE	0x909e
+#define PCI_DEVICE_ID_SONY_AEOLIA_AHCI	0x909f
+#define PCI_DEVICE_ID_SONY_AEOLIA_SDHCI	0x90a0
+#define PCI_DEVICE_ID_SONY_AEOLIA_PCIE	0x90a1
+#define PCI_DEVICE_ID_SONY_AEOLIA_DMAC	0x90a2
+#define PCI_DEVICE_ID_SONY_AEOLIA_MEM	0x90a3
+#define PCI_DEVICE_ID_SONY_AEOLIA_XHCI	0x90a4
+#define PCI_DEVICE_ID_SONY_BELIZE_ACPI	0x90c8
+#define PCI_DEVICE_ID_SONY_BELIZE_GBE	0x90c9
+#define PCI_DEVICE_ID_SONY_BELIZE_AHCI	0x90ca
+#define PCI_DEVICE_ID_SONY_BELIZE_SDHCI	0x90cb
+#define PCI_DEVICE_ID_SONY_BELIZE_PCIE	0x90cc
+#define PCI_DEVICE_ID_SONY_BELIZE_DMAC	0x90cd
+#define PCI_DEVICE_ID_SONY_BELIZE_MEM	0x90ce
+#define PCI_DEVICE_ID_SONY_BELIZE_XHCI	0x90cf
+#define PCI_DEVICE_ID_SONY_BAIKAL_ACPI	0x90d7
+#define PCI_DEVICE_ID_SONY_BAIKAL_GBE	0x90d8
+#define PCI_DEVICE_ID_SONY_BAIKAL_AHCI	0x90d9
+#define PCI_DEVICE_ID_SONY_BAIKAL_SDHCI	0x90da
+#define PCI_DEVICE_ID_SONY_BAIKAL_PCIE	0x90db
+#define PCI_DEVICE_ID_SONY_BAIKAL_DMAC	0x90dc
+#define PCI_DEVICE_ID_SONY_BAIKAL_MEM	0x90dd
+#define PCI_DEVICE_ID_SONY_BAIKAL_XHCI	0x90de
 
 /* Winbond have two vendor IDs! See 0x10ad as well */
 #define PCI_VENDOR_ID_WINBOND2		0x1050
