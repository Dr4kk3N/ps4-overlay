diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index 658a87adb14..92e7462c11e 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -61,13 +61,6 @@ init_shaders(struct vl_compositor *c)
          debug_printf("Unable to create YCbCr i-to-YCbCr p deint fragment shader.\n");
          return false;
       }
-
-      c->fs_rgb_yuv.y = create_frag_shader_rgb_yuv(c, true);
-      c->fs_rgb_yuv.uv = create_frag_shader_rgb_yuv(c, false);
-      if (!c->fs_rgb_yuv.y || !c->fs_rgb_yuv.uv) {
-         debug_printf("Unable to create RGB-to-YUV fragment shader.\n");
-         return false;
-      }
    }
 
    if (c->pipe_gfx_supported) {
@@ -89,6 +82,13 @@ init_shaders(struct vl_compositor *c)
          return false;
       }
 
+      c->fs_rgb_yuv.y = create_frag_shader_rgb_yuv(c, true);
+      c->fs_rgb_yuv.uv = create_frag_shader_rgb_yuv(c, false);
+      if (!c->fs_rgb_yuv.y || !c->fs_rgb_yuv.uv) {
+         debug_printf("Unable to create RGB-to-YUV fragment shader.\n");
+         return false;
+      }
+
       c->fs_rgba = create_frag_shader_rgba(c);
       if (!c->fs_rgba) {
          debug_printf("Unable to create RGB-to-RGB fragment shader.\n");
@@ -112,14 +112,14 @@ static void cleanup_shaders(struct vl_compositor *c)
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.weave.uv);
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.bob.y);
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.bob.uv);
-      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.y);
-      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.uv);
    }
 
    if (c->pipe_gfx_supported) {
       c->pipe->delete_vs_state(c->pipe, c->vs);
       c->pipe->delete_fs_state(c->pipe, c->fs_palette.yuv);
       c->pipe->delete_fs_state(c->pipe, c->fs_palette.rgb);
+      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.y);
+      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.uv);
       c->pipe->delete_fs_state(c->pipe, c->fs_rgba);
    }
 }
@@ -243,23 +243,21 @@ init_buffers(struct vl_compositor *c)
    /*
     * Create our vertex buffer and vertex buffer elements
     */
+   /* removed */
    c->vertex_buf.buffer_offset = 0;
    c->vertex_buf.buffer.resource = NULL;
    c->vertex_buf.is_user_buffer = false;
 
    if (c->pipe_gfx_supported) {
            vertex_elems[0].src_offset = 0;
-           vertex_elems[0].src_stride = VL_COMPOSITOR_VB_STRIDE;
            vertex_elems[0].instance_divisor = 0;
            vertex_elems[0].vertex_buffer_index = 0;
            vertex_elems[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
            vertex_elems[1].src_offset = sizeof(struct vertex2f);
-           vertex_elems[1].src_stride = VL_COMPOSITOR_VB_STRIDE;
            vertex_elems[1].instance_divisor = 0;
            vertex_elems[1].vertex_buffer_index = 0;
            vertex_elems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
            vertex_elems[2].src_offset = sizeof(struct vertex2f) + sizeof(struct vertex4f);
-           vertex_elems[1].src_stride = VL_COMPOSITOR_VB_STRIDE;
            vertex_elems[2].instance_divisor = 0;
            vertex_elems[2].vertex_buffer_index = 0;
            vertex_elems[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
@@ -330,6 +328,7 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
 
    assert(layer < VL_COMPOSITOR_MAX_LAYERS);
 
+   s->interlaced = buffer->interlaced;
    s->used_layers |= 1 << layer;
    sampler_views = buffer->get_sampler_view_components(buffer);
    for (i = 0; i < 3; ++i) {
@@ -351,7 +350,7 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
       if (c->pipe_gfx_supported)
           s->layers[layer].fs = (y) ? c->fs_yuv.bob.y : c->fs_yuv.bob.uv;
       if (c->pipe_cs_composit_supported)
-          s->layers[layer].cs = (y) ? c->cs_yuv.progressive.y : c->cs_yuv.progressive.uv;
+          s->layers[layer].cs = (y) ? c->cs_yuv.bob.y : c->cs_yuv.bob.uv;
       break;
 
    case VL_COMPOSITOR_BOB_BOTTOM:
@@ -361,7 +360,7 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
       if (c->pipe_gfx_supported)
           s->layers[layer].fs = (y) ? c->fs_yuv.bob.y : c->fs_yuv.bob.uv;
       if (c->pipe_cs_composit_supported)
-          s->layers[layer].cs = (y) ? c->cs_yuv.progressive.y : c->cs_yuv.progressive.uv;
+          s->layers[layer].cs = (y) ? c->cs_yuv.bob.y : c->cs_yuv.bob.uv;
       break;
 
    case VL_COMPOSITOR_NONE:
@@ -385,16 +384,18 @@ set_rgb_to_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
                      unsigned layer, struct pipe_sampler_view *v,
                      struct u_rect *src_rect, struct u_rect *dst_rect, bool y)
 {
+   vl_csc_matrix csc_matrix;
+
    assert(s && c && v);
 
    assert(layer < VL_COMPOSITOR_MAX_LAYERS);
 
    s->used_layers |= 1 << layer;
 
-   if (c->pipe_cs_composit_supported)
-      s->layers[layer].cs = y ? c->cs_rgb_yuv.y : c->cs_rgb_yuv.uv;
-   else if (c->pipe_gfx_supported)
-      s->layers[layer].fs = y ? c->fs_rgb_yuv.y : c->fs_rgb_yuv.uv;
+   s->layers[layer].fs = y? c->fs_rgb_yuv.y : c->fs_rgb_yuv.uv;
+
+   vl_csc_get_matrix(VL_CSC_COLOR_STANDARD_BT_709_REV, NULL, false, &csc_matrix);
+   vl_compositor_set_csc_matrix(s, (const vl_csc_matrix *)&csc_matrix, 1.0f, 0.0f);
 
    s->layers[layer].samplers[0] = c->sampler_linear;
    s->layers[layer].samplers[1] = NULL;
@@ -442,6 +443,7 @@ vl_compositor_clear_layers(struct vl_compositor_state *s)
    unsigned i, j;
 
    assert(s);
+   s->interlaced = false;
    s->used_layers = 0;
    for ( i = 0; i < VL_COMPOSITOR_MAX_LAYERS; ++i) {
       struct vertex4f v_one = { 1.0f, 1.0f, 1.0f, 1.0f };
@@ -479,11 +481,24 @@ vl_compositor_set_csc_matrix(struct vl_compositor_state *s,
                              vl_csc_matrix const *matrix,
                              float luma_min, float luma_max)
 {
+   struct pipe_transfer *buf_transfer;
+
    assert(s);
 
-   memcpy(&s->csc_matrix, matrix, sizeof(vl_csc_matrix));
-   s->luma_min = luma_min;
-   s->luma_max = luma_max;
+   float *ptr = pipe_buffer_map(s->pipe, s->shader_params,
+                               PIPE_MAP_WRITE | PIPE_MAP_DISCARD_RANGE,
+                               &buf_transfer);
+
+   if (!ptr)
+      return false;
+
+   memcpy(ptr, matrix, sizeof(vl_csc_matrix));
+
+   ptr += sizeof(vl_csc_matrix)/sizeof(float);
+   ptr[0] = luma_min;
+   ptr[1] = luma_max;
+
+   pipe_buffer_unmap(s->pipe, buf_transfer);
 
    return true;
 }
@@ -548,6 +563,7 @@ vl_compositor_set_buffer_layer(struct vl_compositor_state *s,
 
    assert(layer < VL_COMPOSITOR_MAX_LAYERS);
 
+   s->interlaced = buffer->interlaced;
    s->used_layers |= 1 << layer;
    sampler_views = buffer->get_sampler_view_components(buffer);
    for (i = 0; i < 3; ++i) {
@@ -691,8 +707,6 @@ vl_compositor_yuv_deint_full(struct vl_compositor_state *s,
    vl_compositor_render(s, c, dst_surfaces[0], NULL, false);
 
    if (dst_rect) {
-      dst_rect->x0 /= 2;
-      dst_rect->y0 /= 2;
       dst_rect->x1 /= 2;
       dst_rect->y1 /= 2;
    }
@@ -729,8 +743,6 @@ vl_compositor_convert_rgb_to_yuv(struct vl_compositor_state *s,
    vl_compositor_render(s, c, dst_surfaces[0], NULL, false);
 
    if (dst_rect) {
-      dst_rect->x0 /= 2;
-      dst_rect->y0 /= 2;
       dst_rect->x1 /= 2;
       dst_rect->y1 /= 2;
    }
@@ -818,7 +830,7 @@ vl_compositor_init_state(struct vl_compositor_state *s, struct pipe_context *pip
       pipe->screen,
       PIPE_BIND_CONSTANT_BUFFER,
       PIPE_USAGE_DEFAULT,
-      sizeof(csc_matrix) + 16*sizeof(float) + 2*sizeof(int)
+      sizeof(csc_matrix) + 6*sizeof(float) + 10*sizeof(int)
    );
 
    if (!s->shader_params)
