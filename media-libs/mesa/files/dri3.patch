diff --git a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
index f764916b630..c4f34c6ea5f 100644
--- a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
+++ b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
@@ -21,8 +21,6 @@ DRI_CONF_SECTION_DEBUG
    DRI_CONF_DISABLE_BLEND_FUNC_EXTENDED(false)
    DRI_CONF_DISABLE_ARB_GPU_SHADER5(false)
    DRI_CONF_DISABLE_UNIFORM_ARRAY_RESIZE(false)
-   DRI_CONF_ALIAS_SHADER_EXTENSION()
-   DRI_CONF_ALLOW_VERTEX_TEXTURE_BIAS(false)
    DRI_CONF_FORCE_GLSL_VERSION(0)
    DRI_CONF_ALLOW_EXTRA_PP_TOKENS(false)
    DRI_CONF_ALLOW_GLSL_EXTENSION_DIRECTIVE_MIDSHADER(false)
diff --git a/src/gallium/auxiliary/pipe-loader/meson.build b/src/gallium/auxiliary/pipe-loader/meson.build
index 7927515cf98..1c768e73b62 100644
--- a/src/gallium/auxiliary/pipe-loader/meson.build
+++ b/src/gallium/auxiliary/pipe-loader/meson.build
@@ -34,29 +34,6 @@ if dep_libdrm.found()
   libpipe_loader_links += libloader
 endif
 
-renderonly_drivers_c_args = []
-if with_gallium_etnaviv
-  renderonly_drivers_c_args += '-DGALLIUM_ETNAVIV'
-endif
-if with_gallium_lima
-  renderonly_drivers_c_args += '-DGALLIUM_LIMA'
-endif
-if with_gallium_v3d
-  renderonly_drivers_c_args += '-DGALLIUM_V3D'
-endif
-if with_gallium_vc4
-  renderonly_drivers_c_args += '-DGALLIUM_VC4'
-endif
-if with_gallium_freedreno
-  renderonly_drivers_c_args += '-DGALLIUM_FREEDRENO'
-endif
-if with_gallium_panfrost
-  renderonly_drivers_c_args += '-DGALLIUM_PANFROST'
-endif
-if with_gallium_asahi
-  renderonly_drivers_c_args += '-DGALLIUM_ASAHI'
-endif
-
 libpipe_loader_static = static_library(
   'pipe_loader_static',
   files_pipe_loader,
@@ -64,7 +41,7 @@ libpipe_loader_static = static_library(
     inc_util, inc_loader, inc_gallium, inc_include, inc_src, inc_gallium_aux,
     inc_gallium_winsys, inc_gallium_drivers,
   ],
-  c_args : [libpipe_loader_defines, '-DGALLIUM_STATIC_TARGETS=1', renderonly_drivers_c_args],
+  c_args : [libpipe_loader_defines, '-DGALLIUM_STATIC_TARGETS=1'],
   gnu_symbol_visibility : 'hidden',
   link_with : [libpipe_loader_links],
   dependencies : [dep_libdrm, idep_xmlconfig, idep_mesautil],
diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader.c b/src/gallium/auxiliary/pipe-loader/pipe_loader.c
index ec8a0e0b28d..5b69599ee4f 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader.c
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader.c
@@ -56,18 +56,13 @@ const driOptionDescription gallium_driconf[] = {
 };
 
 int
-pipe_loader_probe(struct pipe_loader_device **devs, int ndev, bool with_zink)
+pipe_loader_probe(struct pipe_loader_device **devs, int ndev)
 {
    int i, n = 0;
 
    for (i = 0; i < ARRAY_SIZE(backends); i++)
       n += backends[i](&devs[n], MAX2(0, ndev - n));
 
-#if defined(HAVE_ZINK) && defined(HAVE_LIBDRM)
-   if (with_zink)
-      n += pipe_loader_drm_zink_probe(&devs[n], MAX2(0, ndev - n));
-#endif
-
    return n;
 }
 
diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader.h b/src/gallium/auxiliary/pipe-loader/pipe_loader.h
index 9a5cb3b00e6..eb3c691c702 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader.h
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader.h
@@ -74,14 +74,13 @@ struct pipe_loader_device {
 /**
  * Get a list of known devices.
  *
- * \param devs      Array that will be filled with pointers to the devices
- *                  available in the system.
- * \param ndev      Maximum number of devices to return.
- * \param with_zink If devices should also be loaded with zink.
+ * \param devs Array that will be filled with pointers to the devices
+ *             available in the system.
+ * \param ndev Maximum number of devices to return.
  * \return Number of devices available in the system.
  */
 int
-pipe_loader_probe(struct pipe_loader_device **devs, int ndev, bool with_zink);
+pipe_loader_probe(struct pipe_loader_device **devs, int ndev);
 
 /**
  * Create a pipe_screen for the specified device.
@@ -214,25 +213,6 @@ pipe_loader_sw_probe_wrapped(struct pipe_loader_device **dev,
 int
 pipe_loader_drm_probe(struct pipe_loader_device **devs, int ndev);
 
-#ifdef HAVE_ZINK
-/**
- * Get a list of known DRM devices compatible with zink.
- *
- * This function is platform-specific.
- *
- * \sa pipe_loader_probe
- */
-int
-pipe_loader_drm_zink_probe(struct pipe_loader_device **devs, int ndev);
-#endif
-
-/**
- * Get the fd of a render-capable device compatible with a given display-only
- * device fd.
- */
-int
-pipe_loader_get_compatible_render_capable_device_fd(int kms_only_fd);
-
 /**
  * Initialize a DRM device in an already opened fd.
  *
@@ -241,7 +221,7 @@ pipe_loader_get_compatible_render_capable_device_fd(int kms_only_fd);
  * \sa pipe_loader_probe
  */
 bool
-pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd, bool zink);
+pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd);
 
 /**
  * Get the dri options used for the DRM driver of the given name, if any.
diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c b/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
index 055c637199d..b27858ab467 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
@@ -121,7 +121,7 @@ get_driver_descriptor(const char *driver_name, struct util_dl_library **plib)
 }
 
 static bool
-pipe_loader_drm_probe_fd_nodup(struct pipe_loader_device **dev, int fd, bool zink)
+pipe_loader_drm_probe_fd_nodup(struct pipe_loader_device **dev, int fd)
 {
    struct pipe_loader_drm_device *ddev = CALLOC_STRUCT(pipe_loader_drm_device);
    int vendor_id, chip_id;
@@ -139,10 +139,7 @@ pipe_loader_drm_probe_fd_nodup(struct pipe_loader_device **dev, int fd, bool zin
    ddev->base.ops = &pipe_loader_drm_ops;
    ddev->fd = fd;
 
-   if (zink)
-      ddev->base.driver_name = strdup("zink");
-   else
-      ddev->base.driver_name = loader_get_driver_for_fd(fd);
+   ddev->base.driver_name = loader_get_driver_for_fd(fd);
    if (!ddev->base.driver_name)
       goto fail;
 
@@ -166,7 +163,7 @@ pipe_loader_drm_probe_fd_nodup(struct pipe_loader_device **dev, int fd, bool zin
       goto fail;
 
    /* kmsro supports lots of drivers, try as a fallback */
-   if (!ddev->dd && !zink)
+   if (!ddev->dd)
       ddev->dd = get_driver_descriptor("kmsro", plib);
 
    if (!ddev->dd)
@@ -186,7 +183,7 @@ pipe_loader_drm_probe_fd_nodup(struct pipe_loader_device **dev, int fd, bool zin
 }
 
 bool
-pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd, bool zink)
+pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd)
 {
    bool ret;
    int new_fd;
@@ -194,7 +191,7 @@ pipe_loader_drm_probe_fd(struct pipe_loader_device **dev, int fd, bool zink)
    if (fd < 0 || (new_fd = os_dupfd_cloexec(fd)) < 0)
      return false;
 
-   ret = pipe_loader_drm_probe_fd_nodup(dev, new_fd, zink);
+   ret = pipe_loader_drm_probe_fd_nodup(dev, new_fd);
    if (!ret)
       close(new_fd);
 
@@ -210,8 +207,8 @@ open_drm_render_node_minor(int minor)
    return loader_open_device(path);
 }
 
-static int
-pipe_loader_drm_probe_internal(struct pipe_loader_device **devs, int ndev, bool zink)
+int
+pipe_loader_drm_probe(struct pipe_loader_device **devs, int ndev)
 {
    int i, j, fd;
 
@@ -223,7 +220,7 @@ pipe_loader_drm_probe_internal(struct pipe_loader_device **devs, int ndev, bool
       if (fd < 0)
          continue;
 
-      if (!pipe_loader_drm_probe_fd_nodup(&dev, fd, zink)) {
+      if (!pipe_loader_drm_probe_fd_nodup(&dev, fd)) {
          close(fd);
          continue;
       }
@@ -240,20 +237,6 @@ pipe_loader_drm_probe_internal(struct pipe_loader_device **devs, int ndev, bool
    return j;
 }
 
-int
-pipe_loader_drm_probe(struct pipe_loader_device **devs, int ndev)
-{
-   return pipe_loader_drm_probe_internal(devs, ndev, false);
-}
-
-#ifdef HAVE_ZINK
-int
-pipe_loader_drm_zink_probe(struct pipe_loader_device **devs, int ndev)
-{
-   return pipe_loader_drm_probe_internal(devs, ndev, true);
-}
-#endif
-
 static void
 pipe_loader_drm_release(struct pipe_loader_device **dev)
 {
@@ -269,54 +252,6 @@ pipe_loader_drm_release(struct pipe_loader_device **dev)
    pipe_loader_base_release(dev);
 }
 
-int
-pipe_loader_get_compatible_render_capable_device_fd(int kms_only_fd)
-{
-   bool is_platform_device;
-   struct pipe_loader_device *dev;
-   const char * const drivers[] = {
-#if defined GALLIUM_ASAHI
-      "asahi",
-#endif
-#if defined GALLIUM_ETNAVIV
-      "etnaviv",
-#endif
-#if defined GALLIUM_FREEDRENO
-      "msm",
-#endif
-#if defined GALLIUM_LIMA
-      "lima",
-#endif
-#if defined GALLIUM_PANFROST
-      "panfrost",
-#endif
-#if defined GALLIUM_V3D
-      "v3d",
-#endif
-#if defined GALLIUM_VC4
-      "vc4",
-#endif
-   };
-
-   if (!pipe_loader_drm_probe_fd(&dev, kms_only_fd, false))
-      return -1;
-   is_platform_device = (dev->type == PIPE_LOADER_DEVICE_PLATFORM);
-   pipe_loader_release(&dev, 1);
-
-   /* For display-only devices that are not on the platform bus, we can't assume
-    * that any of the rendering devices are compatible. */
-   if (!is_platform_device)
-      return -1;
-
-   /* For platform display-only devices, we try to find a render-capable device
-    * on the platform bus and that should be compatible with the display-only
-    * device. */
-   if (ARRAY_SIZE(drivers) == 0)
-      return -1;
-
-   return loader_open_render_node_platform_device(drivers, ARRAY_SIZE(drivers));
-}
-
 static const struct driOptionDescription *
 pipe_loader_drm_get_driconf(struct pipe_loader_device *dev, unsigned *count)
 {
diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c b/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
index c002fb1b139..d7b73f89e76 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
@@ -31,7 +31,6 @@
 
 #include "pipe_loader_priv.h"
 
-#include "util/detect_os.h"
 #include "util/os_file.h"
 #include "util/u_memory.h"
 #include "util/u_dl.h"
@@ -79,7 +78,7 @@ static const struct sw_driver_descriptor driver_descriptors = {
          .create_winsys_kms_dri = kms_dri_create_winsys,
       },
 #endif
-#if !DETECT_OS_ANDROID
+#ifndef __ANDROID__
       {
          .name = "null",
          .create_winsys = null_sw_create,
@@ -108,7 +107,7 @@ static const struct sw_driver_descriptor kopper_driver_descriptors = {
          .create_winsys_kms_dri = kms_dri_create_winsys,
       },
 #endif
-#if !DETECT_OS_ANDROID
+#ifndef __ANDROID__
       {
          .name = "null",
          .create_winsys = null_sw_create,
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.c b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
index 582aec7e904..f092fcaeff3 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.c
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
@@ -305,7 +305,6 @@ vl_bicubic_filter_init(struct vl_bicubic_filter *filter, struct pipe_context *pi
    ve.instance_divisor = 0;
    ve.vertex_buffer_index = 0;
    ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   ve.src_stride = sizeof(struct vertex2f);
    filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
    if (!filter->ves)
       goto error_ves;
diff --git a/src/gallium/auxiliary/vl/vl_codec.c b/src/gallium/auxiliary/vl/vl_codec.c
index b7876f6e645..ce140fedcff 100644
--- a/src/gallium/auxiliary/vl/vl_codec.c
+++ b/src/gallium/auxiliary/vl/vl_codec.c
@@ -32,20 +32,6 @@ bool vl_codec_supported(struct pipe_screen *screen,
                         enum pipe_video_profile profile,
                         bool encode)
 {
-   static_assert(PIPE_VIDEO_PROFILE_MAX == 26, "Update table below when adding new video profiles");
-   if (profile == PIPE_VIDEO_PROFILE_AV1_MAIN) {
-      if (encode) {
-         if (!VIDEO_CODEC_AV1ENC)
-            return false;
-      } else if (!VIDEO_CODEC_AV1DEC) {
-         return false;
-      }
-   }
-   if (profile == PIPE_VIDEO_PROFILE_VP9_PROFILE0 ||
-       profile == PIPE_VIDEO_PROFILE_VP9_PROFILE2) {
-      if (!VIDEO_CODEC_VP9DEC)
-         return false;
-   }
    if (profile == PIPE_VIDEO_PROFILE_VC1_SIMPLE ||
        profile == PIPE_VIDEO_PROFILE_VC1_MAIN ||
        profile == PIPE_VIDEO_PROFILE_VC1_ADVANCED) {
diff --git a/src/gallium/auxiliary/vl/vl_compositor.h b/src/gallium/auxiliary/vl/vl_compositor.h
index 8e49008be44..be82e156cbc 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.h
+++ b/src/gallium/auxiliary/vl/vl_compositor.h
@@ -68,17 +66,6 @@ enum vl_compositor_rotation
    VL_COMPOSITOR_ROTATE_270
 };
 
-/* chroma sample location */
-enum vl_compositor_chroma_location
-{
-   VL_COMPOSITOR_LOCATION_NONE               = 0,
-   VL_COMPOSITOR_LOCATION_VERTICAL_TOP       = (1 << 0),
-   VL_COMPOSITOR_LOCATION_VERTICAL_CENTER    = (1 << 1),
-   VL_COMPOSITOR_LOCATION_VERTICAL_BOTTOM    = (1 << 2),
-   VL_COMPOSITOR_LOCATION_HORIZONTAL_LEFT    = (1 << 3),
-   VL_COMPOSITOR_LOCATION_HORIZONTAL_CENTER  = (1 << 4)
-};
-
 struct vl_compositor_layer
 {
    bool clearing;
@@ -113,10 +100,6 @@ struct vl_compositor_state
    unsigned used_layers:VL_COMPOSITOR_MAX_LAYERS;
    struct vl_compositor_layer layers[VL_COMPOSITOR_MAX_LAYERS];
    bool interlaced;
-   unsigned chroma_location;
-
-   vl_csc_matrix csc_matrix;
-   float luma_min, luma_max;
 };
 
 struct vl_compositor
@@ -162,6 +145,10 @@ struct vl_compositor
          void *y;
          void *uv;
       } weave;
+      struct {
+         void *y;
+         void *uv;
+      } bob;
       struct {
          void *y;
          void *uv;
@@ -177,11 +164,6 @@ struct vl_compositor
       void *y;
       void *uv;
    } fs_rgb_yuv;
-
-   struct {
-      void *y;
-      void *uv;
-   } cs_rgb_yuv;
 };
 
 /**
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index b74d3884286..0685073b518 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -29,540 +29,673 @@
 
 #include <assert.h>
 
-#include "nir/nir_builder.h"
+#include "tgsi/tgsi_text.h"
 #include "vl_compositor_cs.h"
 
 struct cs_viewport {
    float scale_x;
    float scale_y;
    struct u_rect area;
-   float crop_x; /* src */
-   float crop_y;
+   int crop_x; /* src */
+   int crop_y;
    int translate_x; /* dst */
    int translate_y;
    float sampler0_w;
    float sampler0_h;
-   float clamp_x;
-   float clamp_y;
-   float chroma_clamp_x;
-   float chroma_clamp_y;
-   float chroma_offset_x;
-   float chroma_offset_y;
 };
 
-struct cs_shader {
-   nir_builder b;
-   const char *name;
-   bool array;
-   unsigned num_samplers;
-   nir_variable *samplers[3];
-   nir_variable *image;
-   nir_def *params[8];
-   nir_def *fone;
-   nir_def *fzero;
-};
+const char *compute_shader_video_buffer =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
 
-enum coords_flags {
-   COORDS_LUMA          = 0x0,
-   COORDS_CHROMA        = 0x1,
-   COORDS_CHROMA_OFFSET = 0x2,
-};
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
 
-static nir_def *cs_create_shader(struct vl_compositor *c, struct cs_shader *s)
-{
-   /*
-      #version 450
-
-      layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
-      layout (binding = 0) uniform sampler2DRect samplers[3]; // or sampler2DArray
-      layout (binding = 0) uniform image2D image;
-
-      layout (std140, binding = 0) uniform ubo
-      {
-         vec4 csc_mat[3];      // params[0-2]
-         float luma_min;       // params[3].x
-         float luma_max;       // params[3].y
-         vec2 scale;           // params[3].zw
-         vec2 crop;            // params[4].xy
-         ivec2 translate;      // params[4].zw
-         vec2 sampler0_wh;     // params[5].xy
-         vec2 subsample_ratio; // params[5].zw
-         vec2 coord_clamp;     // params[6].xy
-         vec2 chroma_clamp;    // params[6].zw
-         vec2 chroma_offset;   // params[7].xy
-      };
-
-      void main()
-      {
-         ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
-      }
-   */
-   enum glsl_sampler_dim sampler_dim = s->array ? GLSL_SAMPLER_DIM_2D : GLSL_SAMPLER_DIM_RECT;
-   const struct glsl_type *sampler_type =
-      glsl_sampler_type(sampler_dim, /*is_shadow*/ false, s->array, GLSL_TYPE_FLOAT);
-   const struct glsl_type *image_type =
-      glsl_image_type(GLSL_SAMPLER_DIM_2D, /*is_array*/ false, GLSL_TYPE_FLOAT);
-   const nir_shader_compiler_options *options =
-      c->pipe->screen->get_compiler_options(c->pipe->screen, PIPE_SHADER_IR_NIR, PIPE_SHADER_COMPUTE);
-
-   s->b = nir_builder_init_simple_shader(MESA_SHADER_COMPUTE, options, "vl:%s", s->name);
-   nir_builder *b = &s->b;
-   b->shader->info.workgroup_size[0] = 8;
-   b->shader->info.workgroup_size[1] = 8;
-   b->shader->info.workgroup_size[2] = 1;
-   b->shader->info.num_ubos = 1;
-   b->shader->num_uniforms = ARRAY_SIZE(s->params);
-
-   nir_def *zero = nir_imm_int(b, 0);
-   for (unsigned i = 0; i < b->shader->num_uniforms; ++i)
-      s->params[i] = nir_load_ubo(b, 4, 32, zero, nir_imm_int(b, i * 16), .align_mul = 4, .range = ~0);
-
-   for (unsigned i = 0; i < s->num_samplers; ++i) {
-      s->samplers[i] = nir_variable_create(b->shader, nir_var_uniform, sampler_type, "sampler");
-      s->samplers[i]->data.binding = i;
-      BITSET_SET(b->shader->info.textures_used, i);
-      BITSET_SET(b->shader->info.samplers_used, i);
-   }
+      "DCL CONST[0..6]\n"
+      "DCL SVIEW[0..2], RECT, FLOAT\n"
+      "DCL SAMP[0..2]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..7]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 0.0, 0.0, 0.0}\n"
+
+      "UMAD TEMP[0].xy, SV[1].xyyy, IMM[0].xyyy, SV[0].xyyy\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1].xxxx\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0].xyyy, -CONST[5].xyxy\n"
+         "U2F TEMP[2].xy, TEMP[2].xyyy\n"
+         "MUL TEMP[3].xy, TEMP[2].xyyy, CONST[6].xyyy\n"
+
+         /* Scale */
+         "DIV TEMP[2].xy, TEMP[2].xyyy, CONST[3].zwww\n"
+         "DIV TEMP[3].xy, TEMP[3].xyyy, CONST[3].zwww\n"
+
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].x, TEMP[2].xyyy, SAMP[0], RECT\n"
+         "TEX_LZ TEMP[4].y, TEMP[3].xyyy, SAMP[1], RECT\n"
+         "TEX_LZ TEMP[4].z, TEMP[3].xyyy, SAMP[2], RECT\n"
+
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
+
+         /* Color Space Conversion */
+         "DP4 TEMP[7].x, CONST[0], TEMP[4]\n"
+         "DP4 TEMP[7].y, CONST[1], TEMP[4]\n"
+         "DP4 TEMP[7].z, CONST[2], TEMP[4]\n"
+
+         "MOV TEMP[5].w, TEMP[4].zzzz\n"
+         "SLE TEMP[6].w, TEMP[5].wwww, CONST[3].xxxx\n"
+         "SGT TEMP[5].w, TEMP[5].wwww, CONST[3].yyyy\n"
+
+         "MAX TEMP[7].w, TEMP[5].wwww, TEMP[6].wwww\n"
+
+         "STORE IMAGE[0], TEMP[0].xyyy, TEMP[7], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+const char *compute_shader_weave =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0..2], 2D_ARRAY, FLOAT\n"
+      "DCL SAMP[0..2]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..15]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
+      "IMM[2] UINT32 { 1, 2, 4, 0}\n"
+      "IMM[3] FLT32 { 0.25, 0.5, 0.125, 0.125}\n"
+
+      "UMAD TEMP[0].xy, SV[1].xyyy, IMM[0].xyyy, SV[0].xyyy\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1].xxxx\n"
+         "MOV TEMP[2].xy, TEMP[0].xyyy\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[2].xyyy, -CONST[5].xyxy\n"
+
+         /* Top Y */
+         "U2F TEMP[2].xy, TEMP[2].xyyy\n"
+         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
+         /* Down Y */
+         "MOV TEMP[12].xy, TEMP[2].xyyy\n"
+
+         /* Top UV */
+         "MOV TEMP[3].xy, TEMP[2].xyyy\n"
+         "DIV TEMP[3].xy, TEMP[3], IMM[1].yyyy\n"
+         /* Down UV */
+         "MOV TEMP[13].xy, TEMP[3].xyyy\n"
+
+         /* Texture offset */
+         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+
+         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].wwww\n"
+         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].wwww\n"
+
+         /* Scale */
+         "DIV TEMP[2].xy, TEMP[2].xyyy, CONST[3].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12].xyyy, CONST[3].zwzw\n"
+         "DIV TEMP[3].xy, TEMP[3].xyyy, CONST[3].zwzw\n"
+         "DIV TEMP[13].xy, TEMP[13].xyyy, CONST[3].zwzw\n"
+
+         /* Weave offset */
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, -IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, -IMM[3].xxxx\n"
+
+         /* Texture layer */
+         "MOV TEMP[14].x, TEMP[2].yyyy\n"
+         "MOV TEMP[14].yz, TEMP[3].yyyy\n"
+         "ROUND TEMP[15].xyz, TEMP[14].xyzz\n"
+         "ADD TEMP[14].xyz, TEMP[14].xyzz, -TEMP[15].xyzz\n"
+         "MOV TEMP[14].xyz, |TEMP[14].xyzz|\n"
+         "MUL TEMP[14].xyz, TEMP[14].xyzz, IMM[1].yyyy\n"
+
+         /* Normalize */
+         "DIV TEMP[2].xy, TEMP[2].xyyy, CONST[5].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12].xyyy, CONST[5].zwzw\n"
+         "DIV TEMP[15].xy, CONST[5].zwzw, IMM[1].yyyy\n"
+         "DIV TEMP[3].xy, TEMP[3].xyyy, TEMP[15].xyxy\n"
+         "DIV TEMP[13].xy, TEMP[13].xyyy, TEMP[15].xyxy\n"
+
+         /* Fetch texels */
+         "MOV TEMP[2].z, IMM[1].wwww\n"
+         "MOV TEMP[3].z, IMM[1].wwww\n"
+         "TEX_LZ TEMP[10].x, TEMP[2].xyzz, SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].y, TEMP[3].xyzz, SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].z, TEMP[3].xyzz, SAMP[2], 2D_ARRAY\n"
+
+         "MOV TEMP[12].z, IMM[1].xxxx\n"
+         "MOV TEMP[13].z, IMM[1].xxxx\n"
+         "TEX_LZ TEMP[11].x, TEMP[12].xyzz, SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].y, TEMP[13].xyzz, SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].z, TEMP[13].xyzz, SAMP[2], 2D_ARRAY\n"
+
+         "LRP TEMP[6].xyz, TEMP[14].xyzz, TEMP[10].xyzz, TEMP[11].xyzz\n"
+         "MOV TEMP[6].w, IMM[1].xxxx\n"
+
+         /* Color Space Conversion */
+         "DP4 TEMP[9].x, CONST[0], TEMP[6]\n"
+         "DP4 TEMP[9].y, CONST[1], TEMP[6]\n"
+         "DP4 TEMP[9].z, CONST[2], TEMP[6]\n"
+
+         "MOV TEMP[7].w, TEMP[6].zzzz\n"
+         "SLE TEMP[8].w, TEMP[7].wwww, CONST[3].xxxx\n"
+         "SGT TEMP[7].w, TEMP[7].wwww, CONST[3].yyyy\n"
+
+         "MAX TEMP[9].w, TEMP[7].wwww, TEMP[8].wwww\n"
+
+         "STORE IMAGE[0], TEMP[0].xyyy, TEMP[9], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+const char *compute_shader_rgba =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0], RECT, FLOAT\n"
+      "DCL SAMP[0]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..3]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
+
+      "UMAD TEMP[0].xy, SV[1].xyyy, IMM[0].xyyy, SV[0].xyyy\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1].xxxx\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0].xyyy, -CONST[5].xyxy\n"
+         "U2F TEMP[2].xy, TEMP[2].xyyy\n"
+
+         /* Scale */
+         "DIV TEMP[2].xy, TEMP[2].xyyy, CONST[3].zwzw\n"
+
+         /* Fetch texels */
+         "TEX_LZ TEMP[3], TEMP[2].xyyy, SAMP[0], RECT\n"
+
+         "STORE IMAGE[0], TEMP[0].xyyy, TEMP[3], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+static const char *compute_shader_yuv_weave_y =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0..2], 2D_ARRAY, FLOAT\n"
+      "DCL SAMP[0..2]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..15]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
+      "IMM[2] UINT32 { 1, 2, 4, 0}\n"
+      "IMM[3] FLT32 { 0.25, 0.5, 0.125, 0.125}\n"
+
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1]\n"
+         "MOV TEMP[2], TEMP[0]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[2], -CONST[5].xyxy\n"
+
+         /* Top Y */
+         "U2F TEMP[2], TEMP[2]\n"
+         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
+         /* Down Y */
+         "MOV TEMP[12], TEMP[2]\n"
+
+         /* Top UV */
+         "MOV TEMP[3], TEMP[2]\n"
+         "DIV TEMP[3].xy, TEMP[3], IMM[1].yyyy\n"
+         /* Down UV */
+         "MOV TEMP[13], TEMP[3]\n"
+
+         /* Texture offset */
+         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+
+         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].wwww\n"
+         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].wwww\n"
+
+         /* Scale */
+         "DIV TEMP[2].xy, TEMP[2], CONST[3].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12], CONST[3].zwzw\n"
+         "DIV TEMP[3].xy, TEMP[3], CONST[3].zwzw\n"
+         "DIV TEMP[13].xy, TEMP[13], CONST[3].zwzw\n"
+
+         /* Weave offset */
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, -IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, -IMM[3].xxxx\n"
+
+         /* Texture layer */
+         "MOV TEMP[14].x, TEMP[2].yyyy\n"
+         "MOV TEMP[14].yz, TEMP[3].yyyy\n"
+         "ROUND TEMP[15], TEMP[14]\n"
+         "ADD TEMP[14], TEMP[14], -TEMP[15]\n"
+         "MOV TEMP[14], |TEMP[14]|\n"
+         "MUL TEMP[14], TEMP[14], IMM[1].yyyy\n"
+
+         /* Normalize */
+         "DIV TEMP[2].xy, TEMP[2], CONST[5].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12], CONST[5].zwzw\n"
+         "DIV TEMP[15].xy, CONST[5].zwzw, IMM[1].yyyy\n"
+         "DIV TEMP[3].xy, TEMP[3], TEMP[15].xyxy\n"
+         "DIV TEMP[13].xy, TEMP[13], TEMP[15].xyxy\n"
+
+         /* Fetch texels */
+         "MOV TEMP[2].z, IMM[1].wwww\n"
+         "MOV TEMP[3].z, IMM[1].wwww\n"
+         "TEX_LZ TEMP[10].x, TEMP[2], SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].y, TEMP[3], SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].z, TEMP[3], SAMP[2], 2D_ARRAY\n"
+
+         "MOV TEMP[12].z, IMM[1].xxxx\n"
+         "MOV TEMP[13].z, IMM[1].xxxx\n"
+         "TEX_LZ TEMP[11].x, TEMP[12], SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].y, TEMP[13], SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].z, TEMP[13], SAMP[2], 2D_ARRAY\n"
+
+         "LRP TEMP[6], TEMP[14], TEMP[10], TEMP[11]\n"
+         "MOV TEMP[6].w, IMM[1].xxxx\n"
+
+         "STORE IMAGE[0], TEMP[0], TEMP[6], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+static const char *compute_shader_yuv_weave_uv =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0..2], 2D_ARRAY, FLOAT\n"
+      "DCL SAMP[0..2]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..15]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
+      "IMM[2] UINT32 { 1, 2, 4, 0}\n"
+      "IMM[3] FLT32 { 0.25, 0.5, 0.125, 0.125}\n"
+
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1]\n"
+         "MOV TEMP[2], TEMP[0]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[2], -CONST[5].xyxy\n"
+
+         /* Top Y */
+         "U2F TEMP[2], TEMP[2]\n"
+         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
+         /* Down Y */
+         "MOV TEMP[12], TEMP[2]\n"
+
+         /* Top UV */
+         "MOV TEMP[3], TEMP[2]\n"
+         "DIV TEMP[3].xy, TEMP[3], IMM[1].yyyy\n"
+         /* Down UV */
+         "MOV TEMP[13], TEMP[3]\n"
+
+         /* Texture offset */
+         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+
+         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].wwww\n"
+         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].wwww\n"
+
+         /* Scale */
+         "DIV TEMP[2].xy, TEMP[2], CONST[3].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12], CONST[3].zwzw\n"
+         "DIV TEMP[3].xy, TEMP[3], CONST[3].zwzw\n"
+         "DIV TEMP[13].xy, TEMP[13], CONST[3].zwzw\n"
+
+         /* Weave offset */
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[12].y, TEMP[12].yyyy, -IMM[3].xxxx\n"
+         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].y, TEMP[13].yyyy, -IMM[3].xxxx\n"
+
+         /* Texture layer */
+         "MOV TEMP[14].x, TEMP[2].yyyy\n"
+         "MOV TEMP[14].yz, TEMP[3].yyyy\n"
+         "ROUND TEMP[15], TEMP[14]\n"
+         "ADD TEMP[14], TEMP[14], -TEMP[15]\n"
+         "MOV TEMP[14], |TEMP[14]|\n"
+         "MUL TEMP[14], TEMP[14], IMM[1].yyyy\n"
+
+         /* Normalize */
+         "DIV TEMP[2].xy, TEMP[2], CONST[5].zwzw\n"
+         "DIV TEMP[12].xy, TEMP[12], CONST[5].zwzw\n"
+         "DIV TEMP[15].xy, CONST[5].zwzw, IMM[1].yyyy\n"
+         "DIV TEMP[3].xy, TEMP[3], TEMP[15].xyxy\n"
+         "DIV TEMP[13].xy, TEMP[13], TEMP[15].xyxy\n"
+
+         /* Fetch texels */
+         "MOV TEMP[2].z, IMM[1].wwww\n"
+         "MOV TEMP[3].z, IMM[1].wwww\n"
+         "TEX_LZ TEMP[10].x, TEMP[2], SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].y, TEMP[3], SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[10].z, TEMP[3], SAMP[2], 2D_ARRAY\n"
+
+         "MOV TEMP[12].z, IMM[1].xxxx\n"
+         "MOV TEMP[13].z, IMM[1].xxxx\n"
+         "TEX_LZ TEMP[11].x, TEMP[12], SAMP[0], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].y, TEMP[13], SAMP[1], 2D_ARRAY\n"
+         "TEX_LZ TEMP[11].z, TEMP[13], SAMP[2], 2D_ARRAY\n"
+
+         "LRP TEMP[6], TEMP[14], TEMP[10], TEMP[11]\n"
+         "MOV TEMP[6].w, IMM[1].xxxx\n"
+
+         "MOV TEMP[7].xy, TEMP[6].yzww\n"
+
+         "STORE IMAGE[0], TEMP[0], TEMP[7], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+static const char *compute_shader_yuv_bob_y =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0..2], RECT, FLOAT\n"
+      "DCL SAMP[0..2]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..4]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
+
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
+         "DIV TEMP[3], TEMP[2], IMM[1].yyyy\n"
+
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
+         "DIV TEMP[2], TEMP[2], IMM[1].xyxy\n"
+         "DIV TEMP[3], TEMP[3], CONST[3].zwzw\n"
+         "DIV TEMP[3], TEMP[3], IMM[1].xyxy\n"
+
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].x, TEMP[2], SAMP[0], RECT\n"
+         "TEX_LZ TEMP[4].y, TEMP[3], SAMP[1], RECT\n"
+         "TEX_LZ TEMP[4].z, TEMP[3], SAMP[2], RECT\n"
+
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
+
+         "STORE IMAGE[0], TEMP[0], TEMP[4], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+static const char *compute_shader_yuv_bob_uv =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
 
-   s->image = nir_variable_create(b->shader, nir_var_image, image_type, "image");
-   s->image->data.binding = 0;
-   BITSET_SET(b->shader->info.images_used, 0);
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
 
-   s->fone = nir_imm_float(b, 1.0f);
-   s->fzero = nir_imm_float(b, 0.0f);
+      "DCL CONST[0..5]\n"
+      "DCL SVIEW[0..2], RECT, FLOAT\n"
+      "DCL SAMP[0..2]\n"
 
-   nir_def *block_ids = nir_load_workgroup_id(b);
-   nir_def *local_ids = nir_load_local_invocation_id(b);
-   return nir_iadd(b, nir_imul(b, block_ids, nir_imm_ivec3(b, 8, 8, 1)), local_ids);
-}
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..5]\n"
 
-static void *cs_create_shader_state(struct vl_compositor *c, struct cs_shader *s)
-{
-   c->pipe->screen->finalize_nir(c->pipe->screen, s->b.shader);
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
 
-   struct pipe_compute_state state = {0};
-   state.ir_type = PIPE_SHADER_IR_NIR;
-   state.prog = s->b.shader;
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
 
-   /* create compute shader */
-   return c->pipe->create_compute_state(c->pipe, &state);
-}
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
 
-static inline nir_def *cs_translate(struct cs_shader *s, nir_def *src)
-{
-   /*
-      return src.xy + params[4].zw;
-   */
-   nir_builder *b = &s->b;
-   return nir_iadd(b, src, nir_channels(b, s->params[4], 0x3 << 2));
-}
+      "UIF TEMP[1]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
+         "DIV TEMP[3], TEMP[2], IMM[1].yyyy\n"
 
-static inline nir_def *cs_texture_offset(struct cs_shader *s, nir_def *src)
-{
-   /*
-      return src.xy + 0.5;
-   */
-   nir_builder *b = &s->b;
-   return nir_fadd_imm(b, src, 0.5f);
-}
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
+         "DIV TEMP[2], TEMP[2], IMM[1].xyxy\n"
+         "DIV TEMP[3], TEMP[3], CONST[3].zwzw\n"
+         "DIV TEMP[3], TEMP[3], IMM[1].xyxy\n"
 
-static inline nir_def *cs_chroma_subsampling(struct cs_shader *s, nir_def *src)
-{
-   /*
-      return src.xy * params[5].zw;
-   */
-   nir_builder *b = &s->b;
-   return nir_fmul(b, src, nir_channels(b, s->params[5], 0x3 << 2));
-}
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].x, TEMP[2], SAMP[0], RECT\n"
+         "TEX_LZ TEMP[4].y, TEMP[3], SAMP[1], RECT\n"
+         "TEX_LZ TEMP[4].z, TEMP[3], SAMP[2], RECT\n"
 
-static inline nir_def *cs_scale(struct cs_shader *s, nir_def *src)
-{
-   /*
-      return src.xy / params[3].zw;
-   */
-   nir_builder *b = &s->b;
-   return nir_fdiv(b, src, nir_channels(b, s->params[3], 0x3 << 2));
-}
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
 
-static inline nir_def *cs_luma_key(struct cs_shader *s, nir_def *src)
-{
-   /*
-      bool luma_min = params[3].x >= src;
-      bool luma_max = params[3].y < src;
-      return float(luma_min || luma_max);
-   */
-   nir_builder *b = &s->b;
-   nir_def *luma_min = nir_fge(b, nir_channel(b, s->params[3], 0), src);
-   nir_def *luma_max = nir_flt(b, nir_channel(b, s->params[3], 1), src);
-   return nir_b2f32(b, nir_ior(b, luma_min, luma_max));
-}
+         "MOV TEMP[5].xy, TEMP[4].yzww\n"
 
-static inline nir_def *cs_chroma_offset(struct cs_shader *s, nir_def *src, unsigned flags)
-{
-   /*
-      vec2 offset = params[7].xy;
-      if (flags & COORDS_CHROMA)
-         return src.xy + offset;
-      return offset * -0.5 + src.xy;
-   */
-   nir_builder *b = &s->b;
-   nir_def *offset = nir_channels(b, s->params[7], 0x3);
-   if (flags & COORDS_CHROMA)
-      return nir_fadd(b, src, offset);
-   return nir_ffma_imm1(b, offset, -0.5f, src);
-}
+         "STORE IMAGE[0], TEMP[0], TEMP[5], 2D\n"
+      "ENDIF\n"
 
-static inline nir_def *cs_clamp(struct cs_shader *s, nir_def *src, unsigned flags)
-{
-   /*
-      vec2 coord_max;
-      if (flags & COORDS_CHROMA)
-         coord_max = params[6].zw;
-      else
-         coord_max = params[6].xy;
-      return min(src.xy, coord_max);
-   */
-   nir_builder *b = &s->b;
-   nir_component_mask_t mask = flags & COORDS_CHROMA ? 0x3 << 2 : 0x3;
-   return nir_fmin(b, src, nir_channels(b, s->params[6], mask));
-}
+      "END\n";
 
-static inline nir_def *cs_normalize(struct cs_shader *s, nir_def *src, unsigned flags)
-{
-   /*
-      vec2 div = params[5].xy;
-      if (flags & COORDS_CHROMA)
-         div = cs_chroma_subsampling(div);
-      return src.xy / div;
-   */
-   nir_builder *b = &s->b;
-   nir_def *div = nir_channels(b, s->params[5], 0x3);
-   if (flags & COORDS_CHROMA)
-      div = cs_chroma_subsampling(s, div);
-   return nir_fdiv(b, src, div);
-}
+static const char *compute_shader_yuv_y =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
 
-static inline nir_def *cs_crop(struct cs_shader *s, nir_def *src, unsigned flags)
-{
-   /*
-      vec2 crop = params[4].xy;
-      if (flags & COORDS_CHROMA)
-         crop = cs_chroma_subsampling(crop);
-      return src.xy + crop;
-   */
-   nir_builder *b = &s->b;
-   nir_def *crop = nir_channels(b, s->params[4], 0x3);
-   if (flags & COORDS_CHROMA)
-      crop = cs_chroma_subsampling(s, crop);
-   return nir_fadd(b, src, crop);
-}
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
 
-static inline nir_def *cs_color_space_conversion(struct cs_shader *s, nir_def *src, unsigned comp)
-{
-   /*
-      return dot(src, params[comp]);
-   */
-   nir_builder *b = &s->b;
-   return nir_fdot4(b, src, s->params[comp]);
-}
+      "DCL CONST[0..6]\n"
+      "DCL SVIEW[0..2], RECT, FLOAT\n"
+      "DCL SAMP[0..2]\n"
 
-static inline nir_def *cs_fetch_texel(struct cs_shader *s, nir_def *coords, unsigned sampler)
-{
-   /*
-      return texture(samplers[sampler], s->array ? coords.xyz : coords.xy);
-   */
-   nir_builder *b = &s->b;
-   nir_deref_instr *tex_deref = nir_build_deref_var(b, s->samplers[sampler]);
-   nir_component_mask_t mask = s->array ? 0x7 : 0x3;
-   return nir_tex_deref(b, tex_deref, tex_deref, nir_channels(b, coords, mask));
-}
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..4]\n"
 
-static inline void cs_image_store(struct cs_shader *s, nir_def *pos, nir_def *color)
-{
-   /*
-      imageStore(image, pos.xy, color);
-   */
-   nir_builder *b = &s->b;
-   nir_def *zero = nir_imm_int(b, 0);
-   nir_def *undef32 = nir_undef(b, 1, 32);
-   pos = nir_pad_vector_imm_int(b, pos, 0, 4);
-   nir_image_deref_store(b, &nir_build_deref_var(b, s->image)->def, pos, undef32, color, zero);
-}
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
 
-static nir_def *cs_tex_coords(struct cs_shader *s, nir_def *coords, unsigned flags)
-{
-   nir_builder *b = &s->b;
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
 
-   coords = nir_u2f32(b, coords);
-   coords = cs_texture_offset(s, coords);
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
 
-   if (flags & COORDS_CHROMA_OFFSET)
-      coords = cs_chroma_offset(s, coords, flags);
+      "UIF TEMP[1]\n"
+         "MOV TEMP[2], TEMP[0]\n"
 
-   if (flags & COORDS_CHROMA)
-      coords = cs_chroma_subsampling(s, coords);
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[2], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
 
-   coords = cs_scale(s, coords);
-   coords = cs_crop(s, coords, flags);
-   coords = cs_clamp(s, coords, flags);
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
 
-   return coords;
-}
+         /* Crop */
+         "MOV TEMP[4].xy, CONST[6].zwww\n"
+         "I2F TEMP[4], TEMP[4]\n"
+         "ADD TEMP[2], TEMP[2], TEMP[4]\n"
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[1].xxxx\n"
 
-static void *create_video_buffer_shader(struct vl_compositor *c)
-{
-   struct cs_shader s = {
-      .name = "video_buffer",
-      .num_samplers = 3,
-   };
-   nir_builder *b = &s.b;
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].x, TEMP[2], SAMP[0], RECT\n"
 
-   nir_def *ipos = cs_create_shader(c, &s);
-   nir_def *pos[2] = {
-      cs_tex_coords(&s, ipos, COORDS_LUMA),
-      cs_tex_coords(&s, ipos, COORDS_CHROMA | COORDS_CHROMA_OFFSET),
-   };
+         "MOV TEMP[4].yzw, IMM[1].xxxx\n"
 
-   nir_def *col[3];
-   for (unsigned i = 0; i < 3; ++i)
-      col[i] = cs_fetch_texel(&s, pos[MIN2(i, 1)], i);
+         "STORE IMAGE[0], TEMP[0], TEMP[4], 2D\n"
+      "ENDIF\n"
 
-   nir_def *alpha = cs_luma_key(&s, col[2]);
+      "END\n";
 
-   nir_def *color = nir_vec4(b, col[0], col[1], col[2], s.fone);
-   for (unsigned i = 0; i < 3; ++i)
-      col[i] = cs_color_space_conversion(&s, color, i);
+static const char *compute_shader_yuv_uv =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
 
-   color = nir_vec4(b, col[0], col[1], col[2], alpha);
-   cs_image_store(&s, cs_translate(&s, ipos), color);
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
 
-   return cs_create_shader_state(c, &s);
-}
+      "DCL CONST[0..6]\n"
+      "DCL SVIEW[0..2], RECT, FLOAT\n"
+      "DCL SAMP[0..2]\n"
 
-static void *create_yuv_progressive_shader(struct vl_compositor *c, bool y)
-{
-   struct cs_shader s = {
-      .name = y ? "yuv_progressive_y" : "yuv_progressive_uv",
-      .num_samplers = 3,
-   };
-   nir_builder *b = &s.b;
-
-   nir_def *ipos = cs_create_shader(c, &s);
-   nir_def *pos = cs_tex_coords(&s, ipos, y ? COORDS_LUMA : COORDS_CHROMA);
-
-   nir_def *color;
-   if (y) {
-      color = nir_channel(b, cs_fetch_texel(&s, pos, 0), 0);
-   } else {
-      nir_def *col1 = cs_fetch_texel(&s, pos, 1);
-      nir_def *col2 = cs_fetch_texel(&s, pos, 2);
-      color = nir_vec2(b, col1, col2);
-   }
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..5]\n"
 
-   cs_image_store(&s, cs_translate(&s, ipos), color);
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
 
-   return cs_create_shader_state(c, &s);
-}
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
 
-static void *create_rgb_yuv_shader(struct vl_compositor *c, bool y)
-{
-   struct cs_shader s = {
-      .name = y ? "rgb_yuv_y" : "rgb_yuv_uv",
-      .num_samplers = 1,
-   };
-   nir_builder *b = &s.b;
-
-   nir_def *ipos = cs_create_shader(c, &s);
-   nir_def *color = NULL;
-
-   if (y) {
-      nir_def *pos = cs_tex_coords(&s, ipos, COORDS_LUMA);
-      color = cs_fetch_texel(&s, pos, 0);
-   } else {
-      /*
-         vec2 pos[4];
-         pos[0] = vec2(ipos);
-         pos[0] = cs_texture_offset(pos[0]);
-         pos[0] = cs_chroma_offset(pos[0], COORDS_LUMA);
-
-         // Sample offset
-         pos[3] = pos[0] + vec2( 0.25, -0.25);
-         pos[2] = pos[0] + vec2(-0.25,  0.25);
-         pos[1] = pos[0] + vec2(-0.25, -0.25);
-         pos[0] = pos[0] + vec2( 0.25,  0.25);
-
-         vec4 col[4];
-         for (uint i = 0; i < 4; ++i) {
-            pos[i] = cs_scale(pos[i]);
-            pos[i] = cs_crop(pos[i], COORDS_LUMA);
-            pos[i] = cs_clamp(pos[i], COORDS_LUMA);
-            col[i] = texture(samp[0], pos[i]);
-         }
-         color = (col[0] + col[1] + col[2] + col[3]) * 0.25;
-      */
-      nir_def *pos[4];
-      pos[0] = nir_u2f32(b, ipos);
-      pos[0] = cs_texture_offset(&s, pos[0]);
-      pos[0] = cs_chroma_offset(&s, pos[0], COORDS_LUMA);
-
-      /* Sample offset */
-      nir_def *o_plus = nir_imm_float(b, 0.25f);
-      nir_def *o_minus = nir_imm_float(b, -0.25f);
-      pos[3] = nir_fadd(b, pos[0], nir_vec2(b, o_plus, o_minus));
-      pos[2] = nir_fadd(b, pos[0], nir_vec2(b, o_minus, o_plus));
-      pos[1] = nir_fadd(b, pos[0], nir_vec2(b, o_minus, o_minus));
-      pos[0] = nir_fadd(b, pos[0], nir_vec2(b, o_plus, o_plus));
-
-      for (unsigned i = 0; i < 4; ++i) {
-         pos[i] = cs_scale(&s, pos[i]);
-         pos[i] = cs_crop(&s, pos[i], COORDS_LUMA);
-         pos[i] = cs_clamp(&s, pos[i], COORDS_LUMA);
-
-         nir_def *c = cs_fetch_texel(&s, pos[i], 0);
-         color = color ? nir_fadd(b, color, c) : c;
-      }
-      color = nir_fmul_imm(b, color, 0.25f);
-   }
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
 
-   color = nir_vector_insert_imm(b, color, s.fone, 3);
+      "UIF TEMP[1]\n"
+         "MOV TEMP[2], TEMP[0]\n"
 
-   if (y) {
-      color = cs_color_space_conversion(&s, color, 0);
-   } else {
-      nir_def *col1 = cs_color_space_conversion(&s, color, 1);
-      nir_def *col2 = cs_color_space_conversion(&s, color, 2);
-      color = nir_vec2(b, col1, col2);
-   }
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[2], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
 
-   cs_image_store(&s, cs_translate(&s, ipos), color);
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
 
-   return cs_create_shader_state(c, &s);
-}
+         /* Crop */
+         "MOV TEMP[4].xy, CONST[6].zwww\n"
+         "I2F TEMP[4], TEMP[4]\n"
+         "ADD TEMP[2], TEMP[2], TEMP[4]\n"
+         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[1].xxxx\n"
 
-static nir_def *create_weave_shader(struct vl_compositor *c, bool rgb, bool y)
-{
-   struct cs_shader s = {
-      .name = rgb ? "weave" : y ? "yuv_weave_y" : "yuv_weave_uv",
-      .array = true,
-      .num_samplers = 3,
-   };
-   nir_builder *b = &s.b;
-
-   nir_def *ipos = cs_create_shader(c, &s);
-
-   /*
-      vec2 top_y = cs_texture_offset(vec2(ipos));
-      vec2 top_uv = rgb ? cs_chroma_offset(top_y, COORDS_CHROMA) : top_y;
-      top_uv = cs_chroma_subsampling(top_uv);
-      vec2 down_y = top_y;
-      vec2 down_uv = top_uv;
-
-      top_y = cs_crop(cs_scale(top_y), COORDS_LUMA);
-      top_uv = cs_crop(cs_scale(top_uv), COORDS_CHROMA);
-      down_y = cs_crop(cs_scale(down_y), COORDS_LUMA);
-      down_uv = cs_crop(cs_scale(down_uv), COORDS_CHROMA);
-
-      // Weave offset
-      top_y = top_y + vec2(0.0, 0.25);
-      top_uv = top_uv + vec2(0.0, 0.25);
-      down_y = down_y + vec2(0.0, -0.25);
-      down_uv = down_uv + vec2(0.0, -0.25);
-
-      // Texture layer
-      vec3 tex_layer = vec3(top_y.y, top_uv.y, top_uv.y);
-      tex_layer = tex_layer + round(tex_layer) * -1.0;
-      tex_layer = abs(tex_layer) * 2.0;
-
-      top_y = cs_clamp(top_y, COORDS_LUMA);
-      top_y = cs_normalize(top_y, COORDS_LUMA);
-      top_uv = cs_clamp(top_uv, COORDS_CHROMA);
-      top_uv = cs_normalize(top_uv, COORDS_CHROMA);
-      down_y = cs_clamp(down_y, COORDS_LUMA);
-      down_y = cs_normalize(down_y, COORDS_LUMA);
-      down_uv = cs_clamp(down_uv, COORDS_CHROMA);
-      down_uv = cs_normalize(down_uv, COORDS_CHROMA);
-
-      vec4 top_col, down_col;
-      top_col.x = texture(samp[0], vec3(top_y, 0.0)).x;
-      top_col.y = texture(samp[1], vec3(top_uv, 0.0)).x;
-      top_col.z = texture(samp[2], vec3(top_uv, 0.0)).x;
-      top_col.w = 1.0;
-      down_col.x = texture(samp[0], vec3(down_y, 1.0)).x;
-      down_col.y = texture(samp[1], vec3(down_uv, 1.0)).x;
-      down_col.z = texture(samp[2], vec3(down_uv, 1.0)).x;
-      down_col.w = 1.0;
-
-      vec4 color = mix(down_col, top_col, tex_layer);
-   */
-   nir_def *pos[4];
-   /* Top Y */
-   pos[0] = nir_u2f32(b, ipos);
-   pos[0] = cs_texture_offset(&s, pos[0]);
-   /* Top UV */
-   pos[1] = rgb ? cs_chroma_offset(&s, pos[0], COORDS_CHROMA) : pos[0];
-   pos[1] = cs_chroma_subsampling(&s, pos[1]);
-   /* Down Y */
-   pos[2] = pos[0];
-   /* Down UV */
-   pos[3] = pos[1];
-
-   /* Weave offset */
-   nir_def *o_plus = nir_imm_vec2(b, 0.0f, 0.25f);
-   nir_def *o_minus = nir_imm_vec2(b, 0.0f, -0.25f);
-   for (unsigned i = 0; i < 4; ++i) {
-      pos[i] = cs_scale(&s, pos[i]);
-      pos[i] = cs_crop(&s, pos[i], i % 2 ? COORDS_CHROMA : COORDS_LUMA);
-      pos[i] = nir_fadd(b, pos[i], i < 2 ? o_plus : o_minus);
-   }
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].y, TEMP[2], SAMP[1], RECT\n"
+         "TEX_LZ TEMP[4].z, TEMP[2], SAMP[2], RECT\n"
 
-   /* Texture layer */
-   nir_def *tex_layer = nir_vec3(b,
-                                 nir_channel(b, pos[0], 1),
-                                 nir_channel(b, pos[1], 1),
-                                 nir_channel(b, pos[1], 1));
-   tex_layer = nir_fadd(b, tex_layer,
-                        nir_fneg(b, nir_fround_even(b, tex_layer)));
-   tex_layer = nir_fabs(b, tex_layer);
-   tex_layer = nir_fmul_imm(b, tex_layer, 2.0f);
-
-   nir_def *col[6];
-   for (unsigned i = 0; i < 4; ++i) {
-      bool top = i < 2;
-      unsigned j = top ? 0 : 3;
-      unsigned flags = i % 2 ? COORDS_CHROMA : COORDS_LUMA;
-      pos[i] = cs_clamp(&s, pos[i], flags);
-      pos[i] = cs_normalize(&s, pos[i], flags);
-      pos[i] = nir_vector_insert_imm(b, pos[i],
-                                     top ? s.fzero : s.fone, 2);
-      if (flags == COORDS_LUMA) {
-         col[j] = cs_fetch_texel(&s, pos[i], 0);
-      } else {
-         col[j + 1] = cs_fetch_texel(&s, pos[i], 1);
-         col[j + 2] = cs_fetch_texel(&s, pos[i], 2);
-      }
-   }
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
 
-   nir_def *color_top = nir_vec4(b, col[0], col[1], col[2], s.fone);
-   nir_def *color_down = nir_vec4(b, col[3], col[4], col[5], s.fone);
-   nir_def *color = nir_flrp(b, color_down, color_top, tex_layer);
-
-   if (rgb) {
-      nir_def *alpha = cs_luma_key(&s, nir_channel(b, color, 2));
-      for (unsigned i = 0; i < 3; ++i)
-         col[i] = cs_color_space_conversion(&s, color, i);
-      color = nir_vec4(b, col[0], col[1], col[2], alpha);
-   } else if (y) {
-      color = nir_channel(b, color, 0);
-   } else {
-      nir_def *col1 = nir_channel(b, color, 1);
-      nir_def *col2 = nir_channel(b, color, 2);
-      color = nir_vec2(b, col1, col2);
-   }
+         "MOV TEMP[5].xy, TEMP[4].yzww\n"
 
-   cs_image_store(&s, cs_translate(&s, ipos), color);
+         "STORE IMAGE[0], TEMP[0], TEMP[5], 2D\n"
+      "ENDIF\n"
 
-   return cs_create_shader_state(c, &s);
-}
+      "END\n";
 
 static void
 cs_launch(struct vl_compositor *c,
@@ -570,10 +703,6 @@ cs_launch(struct vl_compositor *c,
           const struct u_rect  *draw_area)
 {
    struct pipe_context *ctx = c->pipe;
-   unsigned width, height;
-
-   width = draw_area->x1 - draw_area->x0;
-   height = draw_area->y1 - draw_area->y0;
 
    /* Bind the image */
    struct pipe_image_view image = {0};
@@ -589,12 +718,10 @@ cs_launch(struct vl_compositor *c,
    /* Dispatch compute */
    struct pipe_grid_info info = {0};
    info.block[0] = 8;
-   info.last_block[0] = width % info.block[0];
    info.block[1] = 8;
-   info.last_block[1] = height % info.block[1];
    info.block[2] = 1;
-   info.grid[0] = DIV_ROUND_UP(width, info.block[0]);
-   info.grid[1] = DIV_ROUND_UP(height, info.block[1]);
+   info.grid[0] = DIV_ROUND_UP(draw_area->x1, info.block[0]);
+   info.grid[1] = DIV_ROUND_UP(draw_area->y1, info.block[1]);
    info.grid[2] = 1;
 
    ctx->launch_grid(ctx, &info);
@@ -630,26 +757,6 @@ calc_drawn_area(struct vl_compositor_state *s,
    return result;
 }
 
-static inline float
-chroma_offset_x(unsigned location)
-{
-   if (location & VL_COMPOSITOR_LOCATION_HORIZONTAL_LEFT)
-      return 0.5f;
-   else
-      return 0.0f;
-}
-
-static inline float
-chroma_offset_y(unsigned location)
-{
-   if (location & VL_COMPOSITOR_LOCATION_VERTICAL_TOP)
-      return 0.5f;
-   else if (location & VL_COMPOSITOR_LOCATION_VERTICAL_BOTTOM)
-      return -0.5f;
-   else
-      return 0.0f;
-}
-
 static bool
 set_viewport(struct vl_compositor_state *s,
              struct cs_viewport         *drawn,
@@ -660,24 +767,22 @@ set_viewport(struct vl_compositor_state *s,
    assert(s && drawn);
 
    void *ptr = pipe_buffer_map(s->pipe, s->shader_params,
-                               PIPE_MAP_WRITE | PIPE_MAP_DISCARD_WHOLE_RESOURCE,
+                               PIPE_MAP_READ | PIPE_MAP_WRITE,
                                &buf_transfer);
 
    if (!ptr)
      return false;
 
-   memcpy(ptr, &s->csc_matrix, sizeof(vl_csc_matrix));
-
    float *ptr_float = (float *)ptr;
-   ptr_float += sizeof(vl_csc_matrix) / sizeof(float);
-   *ptr_float++ = s->luma_min;
-   *ptr_float++ = s->luma_max;
+   ptr_float += sizeof(vl_csc_matrix)/sizeof(float) + 2;
    *ptr_float++ = drawn->scale_x;
    *ptr_float++ = drawn->scale_y;
-   *ptr_float++ = drawn->crop_x;
-   *ptr_float++ = drawn->crop_y;
 
    int *ptr_int = (int *)ptr_float;
+   *ptr_int++ = drawn->area.x0;
+   *ptr_int++ = drawn->area.y0;
+   *ptr_int++ = drawn->area.x1;
+   *ptr_int++ = drawn->area.y1;
    *ptr_int++ = drawn->translate_x;
    *ptr_int++ = drawn->translate_y;
 
@@ -697,17 +802,12 @@ set_viewport(struct vl_compositor_state *s,
       *ptr_float++ = v_ratio;
    }
    else {
-      *ptr_float++ = 1.0f;
-      *ptr_float++ = 1.0f;
+      ptr_float++;
+      ptr_float++;
    }
-
-
-   *ptr_float++ = drawn->clamp_x;
-   *ptr_float++ = drawn->clamp_y;
-   *ptr_float++ = drawn->chroma_clamp_x;
-   *ptr_float++ = drawn->chroma_clamp_y;
-   *ptr_float++ = drawn->chroma_offset_x;
-   *ptr_float++ = drawn->chroma_offset_y;
+   ptr_int = (int *)ptr_float;
+   *ptr_int++ = drawn->crop_x;
+   *ptr_int++ = drawn->crop_y;
 
    pipe_buffer_unmap(s->pipe, buf_transfer);
 
@@ -728,7 +828,6 @@ draw_layers(struct vl_compositor       *c,
          struct vl_compositor_layer *layer = &s->layers[i];
          struct pipe_sampler_view **samplers = &layer->sampler_views[0];
          unsigned num_sampler_views = !samplers[1] ? 1 : !samplers[2] ? 2 : 3;
-         struct pipe_sampler_view *sampler1 = samplers[1] ? samplers[1] : samplers[0];
          struct cs_viewport drawn;
 
          drawn.area = calc_drawn_area(s, layer);
@@ -737,19 +836,14 @@ draw_layers(struct vl_compositor       *c,
              (layer->src.br.x - layer->src.tl.x));
          drawn.scale_y  = layer->viewport.scale[1] /
             ((float)layer->sampler_views[0]->texture->height0 *
+             (s->interlaced ? 2.0 : 1.0) *
              (layer->src.br.y - layer->src.tl.y));
-         drawn.crop_x = layer->src.tl.x * layer->sampler_views[0]->texture->width0;
+         drawn.crop_x = (int)(layer->src.tl.x * layer->sampler_views[0]->texture->width0);
          drawn.translate_x = layer->viewport.translate[0];
-         drawn.crop_y = layer->src.tl.y * layer->sampler_views[0]->texture->height0;
+         drawn.crop_y = (int)(layer->src.tl.y * layer->sampler_views[0]->texture->height0);
          drawn.translate_y = layer->viewport.translate[1];
          drawn.sampler0_w = (float)layer->sampler_views[0]->texture->width0;
          drawn.sampler0_h = (float)layer->sampler_views[0]->texture->height0;
-         drawn.clamp_x = (float)samplers[0]->texture->width0 * layer->src.br.x - 0.5;
-         drawn.clamp_y = (float)samplers[0]->texture->height0 * layer->src.br.y - 0.5;
-         drawn.chroma_clamp_x = (float)sampler1->texture->width0 * layer->src.br.x - 0.5;
-         drawn.chroma_clamp_y = (float)sampler1->texture->height0 * layer->src.br.y - 0.5;
-         drawn.chroma_offset_x = chroma_offset_x(s->chroma_location);
-         drawn.chroma_offset_y = chroma_offset_y(s->chroma_location);
          set_viewport(s, &drawn, samplers);
 
          c->pipe->bind_sampler_states(c->pipe, PIPE_SHADER_COMPUTE, 0,
@@ -779,6 +873,26 @@ draw_layers(struct vl_compositor       *c,
    }
 }
 
+void *
+vl_compositor_cs_create_shader(struct vl_compositor *c,
+                               const char           *compute_shader_text)
+{
+   assert(c && compute_shader_text);
+
+   struct tgsi_token tokens[1024];
+   if (!tgsi_text_translate(compute_shader_text, tokens, ARRAY_SIZE(tokens))) {
+      assert(0);
+      return NULL;
+   }
+
+   struct pipe_compute_state state = {0};
+   state.ir_type = PIPE_SHADER_IR_TGSI;
+   state.prog = tokens;
+
+   /* create compute shader */
+   return c->pipe->create_compute_state(c->pipe, &state);
+}
+
 void
 vl_compositor_cs_render(struct vl_compositor_state *s,
                         struct vl_compositor       *c,
@@ -818,23 +932,26 @@ bool vl_compositor_cs_init_shaders(struct vl_compositor *c)
 {
         assert(c);
 
-        c->cs_video_buffer = create_video_buffer_shader(c);
+        c->cs_video_buffer = vl_compositor_cs_create_shader(c, compute_shader_video_buffer);
         if (!c->cs_video_buffer) {
                 debug_printf("Unable to create video_buffer compute shader.\n");
                 return false;
         }
 
-        c->cs_weave_rgb = create_weave_shader(c, true, false);
+        c->cs_weave_rgb = vl_compositor_cs_create_shader(c, compute_shader_weave);
         if (!c->cs_weave_rgb) {
                 debug_printf("Unable to create weave_rgb compute shader.\n");
                 return false;
         }
 
-        c->cs_yuv.weave.y = create_weave_shader(c, false, true);
-        c->cs_yuv.weave.uv = create_weave_shader(c, false, false);
-        c->cs_yuv.progressive.y = create_yuv_progressive_shader(c, true);
-        c->cs_yuv.progressive.uv = create_yuv_progressive_shader(c, false);
-        if (!c->cs_yuv.weave.y || !c->cs_yuv.weave.uv) {
+        c->cs_yuv.weave.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_weave_y);
+        c->cs_yuv.weave.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_weave_uv);
+        c->cs_yuv.bob.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_bob_y);
+        c->cs_yuv.bob.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_bob_uv);
+        c->cs_yuv.progressive.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_y);
+        c->cs_yuv.progressive.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_uv);
+        if (!c->cs_yuv.weave.y || !c->cs_yuv.weave.uv ||
+            !c->cs_yuv.bob.y || !c->cs_yuv.bob.uv) {
                 debug_printf("Unable to create YCbCr i-to-YCbCr p deint compute shader.\n");
                 return false;
         }
@@ -843,13 +960,6 @@ bool vl_compositor_cs_init_shaders(struct vl_compositor *c)
                 return false;
         }
 
-        c->cs_rgb_yuv.y = create_rgb_yuv_shader(c, true);
-        c->cs_rgb_yuv.uv = create_rgb_yuv_shader(c, false);
-        if (!c->cs_rgb_yuv.y || !c->cs_rgb_yuv.uv) {
-                debug_printf("Unable to create RGB-to-NV12 compute shader.\n");
-                return false;
-        }
-
         return true;
 }
 
@@ -865,12 +975,12 @@ void vl_compositor_cs_cleanup_shaders(struct vl_compositor *c)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.weave.y);
         if (c->cs_yuv.weave.uv)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.weave.uv);
+        if (c->cs_yuv.bob.y)
+                c->pipe->delete_compute_state(c->pipe, c->cs_yuv.bob.y);
+        if (c->cs_yuv.bob.uv)
+                c->pipe->delete_compute_state(c->pipe, c->cs_yuv.bob.uv);
         if (c->cs_yuv.progressive.y)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.progressive.y);
         if (c->cs_yuv.progressive.uv)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.progressive.uv);
-        if (c->cs_rgb_yuv.y)
-                c->pipe->delete_compute_state(c->pipe, c->cs_rgb_yuv.y);
-        if (c->cs_rgb_yuv.uv)
-                c->pipe->delete_compute_state(c->pipe, c->cs_rgb_yuv.uv);
 }
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.h b/src/gallium/auxiliary/vl/vl_compositor_cs.h
index 6ade287b504..28059b6b6e3 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.h
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.h
@@ -32,6 +32,13 @@
 
 #include "vl_compositor.h"
 
+/**
+ * create compute shader
+ */
+void *
+vl_compositor_cs_create_shader(struct vl_compositor *c,
+                               const char           *compute_shader_text);
+
 /**
  * render the layers to the frontbuffer with compute shader
  */
diff --git a/src/gallium/auxiliary/vl/vl_compositor_gfx.c b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
index ed598c2e70f..b7080c344d9 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_gfx.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
@@ -645,27 +645,6 @@ gen_vertex_data(struct vl_compositor *c, struct vl_compositor_state *s, struct u
    u_upload_unmap(c->pipe->stream_uploader);
 }
 
-static void
-set_csc_matrix(struct vl_compositor_state *s)
-{
-   struct pipe_transfer *buf_transfer;
-
-   float *ptr = pipe_buffer_map(s->pipe, s->shader_params,
-                                PIPE_MAP_WRITE | PIPE_MAP_DISCARD_WHOLE_RESOURCE,
-                                &buf_transfer);
-
-   if (!ptr)
-     return;
-
-   memcpy(ptr, &s->csc_matrix, sizeof(vl_csc_matrix));
-
-   ptr += sizeof(vl_csc_matrix) / sizeof(float);
-   *ptr++ = s->luma_min;
-   *ptr++ = s->luma_max;
-
-   pipe_buffer_unmap(s->pipe, buf_transfer);
-}
-
 static void
 draw_layers(struct vl_compositor *c, struct vl_compositor_state *s, struct u_rect *dirty)
 {
@@ -726,7 +705,6 @@ vl_compositor_gfx_render(struct vl_compositor_state *s,
    c->pipe->set_scissor_states(c->pipe, 0, 1, &s->scissor);
 
    gen_vertex_data(c, s, dirty_area);
-   set_csc_matrix(s);
 
    if (clear_dirty && dirty_area &&
        (dirty_area->x0 < dirty_area->x1 || dirty_area->y0 < dirty_area->y1)) {
diff --git a/src/gallium/auxiliary/vl/vl_csc.c b/src/gallium/auxiliary/vl/vl_csc.c
index d1a88b36d55..861eda683a6 100644
--- a/src/gallium/auxiliary/vl/vl_csc.c
+++ b/src/gallium/auxiliary/vl/vl_csc.c
@@ -119,18 +119,6 @@ static const vl_csc_matrix bt_709 =
    { 1.0f,  1.816f,  0.0f,   0.0f, }
 };
 
-/*
- * Converts ITU-R BT.709 YCbCr pixels to RGB pixels where:
- * Y, Cb, and Cr are in [0,255]
- * R, G, and B are in [16,235]
- */
-static const vl_csc_matrix bt_709_full =
-{
-   { 0.859f,  0.0f,    1.352f, 0.0625f, },
-   { 0.859f, -0.161f, -0.402f, 0.0625f, },
-   { 0.859f,  1.594f,  0.0f,   0.0625f, }
-};
-
 /*
  * Converts SMPTE 240M YCbCr pixels to RGB pixels where:
  * Y is in [16,235], Cb and Cr are in [16,240]
@@ -149,12 +137,6 @@ static const vl_csc_matrix bt_709_rev  = {
    { 0.439f, -0.399f, -0.040f, 0.5f   }
 };
 
-static const vl_csc_matrix bt_709_rev_full = {
-   { 0.213f,  0.715f,  0.072f, 0.0f },
-   {-0.115f, -0.385f,  0.5f,   0.5f },
-   { 0.5f,   -0.454f, -0.046f, 0.5f }
-};
-
 static const vl_csc_matrix identity =
 {
    { 1.0f, 0.0f, 0.0f, 0.0f, },
@@ -205,14 +187,11 @@ void vl_csc_get_matrix(enum VL_CSC_COLOR_STANDARD cs,
       case VL_CSC_COLOR_STANDARD_BT_709:
          cstd = &bt_709;
          break;
-      case VL_CSC_COLOR_STANDARD_BT_709_FULL:
-         cstd = &bt_709_full;
-         break;
       case VL_CSC_COLOR_STANDARD_SMPTE_240M:
          cstd = &smpte240m;
          break;
       case VL_CSC_COLOR_STANDARD_BT_709_REV:
-         memcpy(matrix, full_range ? bt_709_rev_full : bt_709_rev, sizeof(vl_csc_matrix));
+         memcpy(matrix, bt_709_rev, sizeof(vl_csc_matrix));
          return;
       case VL_CSC_COLOR_STANDARD_IDENTITY:
       default:
diff --git a/src/gallium/auxiliary/vl/vl_csc.h b/src/gallium/auxiliary/vl/vl_csc.h
index 43de802c11a..b640b4e8fde 100644
--- a/src/gallium/auxiliary/vl/vl_csc.h
+++ b/src/gallium/auxiliary/vl/vl_csc.h
@@ -45,7 +45,6 @@ enum VL_CSC_COLOR_STANDARD
    VL_CSC_COLOR_STANDARD_IDENTITY,
    VL_CSC_COLOR_STANDARD_BT_601,
    VL_CSC_COLOR_STANDARD_BT_709,
-   VL_CSC_COLOR_STANDARD_BT_709_FULL,
    VL_CSC_COLOR_STANDARD_SMPTE_240M,
    VL_CSC_COLOR_STANDARD_BT_709_REV
 };
diff --git a/src/gallium/auxiliary/vl/vl_deint_filter.c b/src/gallium/auxiliary/vl/vl_deint_filter.c
index 04dd888d0a8..91ffa839614 100644
--- a/src/gallium/auxiliary/vl/vl_deint_filter.c
+++ b/src/gallium/auxiliary/vl/vl_deint_filter.c
@@ -84,8 +84,7 @@ create_vert_shader(struct vl_deint_filter *filter)
 }
 
 static void *
-create_copy_frag_shader(struct vl_deint_filter *filter, unsigned field,
-                        struct vertex2f *sizes)
+create_copy_frag_shader(struct vl_deint_filter *filter, unsigned field)
 {
    struct ureg_program *shader;
    struct ureg_src i_vtex;
@@ -105,15 +104,9 @@ create_copy_frag_shader(struct vl_deint_filter *filter, unsigned field,
 
    ureg_MOV(shader, t_tex, i_vtex);
    if (field) {
-      if (filter->interleaved)
-         ureg_ADD(shader, t_tex, ureg_src(t_tex),
-                  ureg_imm4f(shader, 0, sizes->y * 0.5f, 0, 0));
       ureg_MOV(shader, ureg_writemask(t_tex, TGSI_WRITEMASK_ZW),
                ureg_imm4f(shader, 0, 0, 1.0f, 0));
    } else {
-      if (filter->interleaved)
-         ureg_ADD(shader, t_tex, ureg_src(t_tex),
-                  ureg_imm4f(shader, 0, sizes->y * -0.5f, 0, 0));
       ureg_MOV(shader, ureg_writemask(t_tex, TGSI_WRITEMASK_ZW),
                ureg_imm1f(shader, 0));
    }
@@ -203,24 +196,16 @@ create_deint_frag_shader(struct vl_deint_filter *filter, unsigned field,
 
    if (field == 0) {
       /* weave with prev top field */
-      if (filter->interleaved)
-         ureg_ADD(shader, t_tex, ureg_src(t_tex),
-                  ureg_imm4f(shader, 0, sizes->y * -0.5f, 0, 0));
       ureg_TEX(shader, t_weave, TGSI_TEXTURE_2D_ARRAY, ureg_src(t_tex), sampler_prev);
       /* get linear interpolation from current bottom field */
-      ureg_ADD(shader, t_comp_top, ureg_src(t_tex),
-               ureg_imm4f(shader, 0, sizes->y * (filter->interleaved ? 1.0f : -1.0f), 1.0f, 0));
+      ureg_ADD(shader, t_comp_top, ureg_src(t_tex), ureg_imm4f(shader, 0, sizes->y * -1.0f, 1.0f, 0));
       ureg_TEX(shader, t_linear, TGSI_TEXTURE_2D_ARRAY, ureg_src(t_comp_top), sampler_cur);
    } else {
       /* weave with prev bottom field */
-      if (filter->interleaved)
-         ureg_ADD(shader, t_tex, ureg_src(t_tex),
-                  ureg_imm4f(shader, 0, sizes->y * 0.5f, 0, 0));
       ureg_ADD(shader, t_comp_bot, ureg_src(t_tex), ureg_imm4f(shader, 0, 0, 1.0f, 0));
       ureg_TEX(shader, t_weave, TGSI_TEXTURE_2D_ARRAY, ureg_src(t_comp_bot), sampler_prev);
       /* get linear interpolation from current top field */
-      ureg_ADD(shader, t_comp_bot, ureg_src(t_tex),
-               ureg_imm4f(shader, 0, sizes->y * (filter->interleaved ? -1.0f : 1.0f), 0, 0));
+      ureg_ADD(shader, t_comp_bot, ureg_src(t_tex), ureg_imm4f(shader, 0, sizes->y * 1.0f, 0, 0));
       ureg_TEX(shader, t_linear, TGSI_TEXTURE_2D_ARRAY, ureg_src(t_comp_bot), sampler_cur);
    }
 
@@ -250,7 +235,7 @@ create_deint_frag_shader(struct vl_deint_filter *filter, unsigned field,
 bool
 vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
                      unsigned video_width, unsigned video_height,
-                     bool skip_chroma, bool spatial_filter, bool interleaved)
+                     bool skip_chroma, bool spatial_filter)
 {
    struct pipe_rasterizer_state rs_state;
    struct pipe_blend_state blend;
@@ -265,7 +250,6 @@ vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
    memset(filter, 0, sizeof(*filter));
    filter->pipe = pipe;
    filter->skip_chroma = skip_chroma;
-   filter->interleaved = interleaved;
    filter->video_width = video_width;
    filter->video_height = video_height;
 
@@ -329,7 +313,6 @@ vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
 
    memset(&ve, 0, sizeof(ve));
    ve.src_offset = 0;
-   ve.src_stride = sizeof(struct vertex2f);
    ve.instance_divisor = 0;
    ve.vertex_buffer_index = 0;
    ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
@@ -344,11 +327,11 @@ vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
    if (!filter->vs)
       goto error_vs;
 
-   filter->fs_copy_top = create_copy_frag_shader(filter, 0, &sizes);
+   filter->fs_copy_top = create_copy_frag_shader(filter, 0);
    if (!filter->fs_copy_top)
       goto error_fs_copy_top;
 
-   filter->fs_copy_bottom = create_copy_frag_shader(filter, 1, &sizes);
+   filter->fs_copy_bottom = create_copy_frag_shader(filter, 1);
    if (!filter->fs_copy_bottom)
       goto error_fs_copy_bottom;
 
@@ -440,7 +423,7 @@ vl_deint_filter_check_buffers(struct vl_deint_filter *filter,
       if (bufs[i]->width < filter->video_width ||
           bufs[i]->height < filter->video_height)
          return false;
-      if (bufs[i]->interlaced != !filter->interleaved)
+      if (!bufs[i]->interlaced)
          return false;
    }
 
diff --git a/src/gallium/auxiliary/vl/vl_deint_filter.h b/src/gallium/auxiliary/vl/vl_deint_filter.h
index ee376bbeb65..49cc96c20b9 100644
--- a/src/gallium/auxiliary/vl/vl_deint_filter.h
+++ b/src/gallium/auxiliary/vl/vl_deint_filter.h
@@ -47,7 +47,6 @@ struct vl_deint_filter
 
    unsigned video_width, video_height;
    bool skip_chroma;
-   bool interleaved;
 
    struct pipe_video_buffer *video_buffer;
 };
@@ -55,7 +54,7 @@ struct vl_deint_filter
 bool
 vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
                      unsigned video_width, unsigned video_height,
-                     bool skip_chroma, bool spatial_filter, bool interleaved);
+                     bool skip_chroma, bool spatial_filter);
 
 void
 vl_deint_filter_cleanup(struct vl_deint_filter *filter);
diff --git a/src/gallium/auxiliary/vl/vl_matrix_filter.c b/src/gallium/auxiliary/vl/vl_matrix_filter.c
index 0c9bc757e00..4ef1be7f6e1 100644
--- a/src/gallium/auxiliary/vl/vl_matrix_filter.c
+++ b/src/gallium/auxiliary/vl/vl_matrix_filter.c
@@ -193,7 +193,6 @@ vl_matrix_filter_init(struct vl_matrix_filter *filter, struct pipe_context *pipe
       goto error_quad;
 
    memset(&ve, 0, sizeof(ve));
-   ve.src_stride = sizeof(struct vertex2f);
    ve.src_offset = 0;
    ve.instance_divisor = 0;
    ve.vertex_buffer_index = 0;
diff --git a/src/gallium/auxiliary/vl/vl_median_filter.c b/src/gallium/auxiliary/vl/vl_median_filter.c
index 978c58fe1ca..a3aad7b5a8d 100644
--- a/src/gallium/auxiliary/vl/vl_median_filter.c
+++ b/src/gallium/auxiliary/vl/vl_median_filter.c
@@ -326,7 +326,6 @@ vl_median_filter_init(struct vl_median_filter *filter, struct pipe_context *pipe
    ve.instance_divisor = 0;
    ve.vertex_buffer_index = 0;
    ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   ve.src_stride = sizeof(struct vertex2f);
    filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
    if (!filter->ves)
       goto error_ves;
diff --git a/src/gallium/auxiliary/vl/vl_vertex_buffers.c b/src/gallium/auxiliary/vl/vl_vertex_buffers.c
index 69221987d31..be02b82734a 100644
--- a/src/gallium/auxiliary/vl/vl_vertex_buffers.c
+++ b/src/gallium/auxiliary/vl/vl_vertex_buffers.c
@@ -165,17 +167,14 @@ vl_vb_get_ves_ycbcr(struct pipe_context *pipe)
 
    memset(&vertex_elems, 0, sizeof(vertex_elems));
    vertex_elems[VS_I_RECT] = vl_vb_get_quad_vertex_element();
-   vertex_elems[VS_I_RECT].src_stride = sizeof(struct vertex2f);
 
    /* Position element */
    vertex_elems[VS_I_VPOS].src_format = PIPE_FORMAT_R8G8B8A8_USCALED;
 
    /* block num element */
    vertex_elems[VS_I_BLOCK_NUM].src_format = PIPE_FORMAT_R32_FLOAT;
-   vertex_elems[VS_I_BLOCK_NUM].src_stride = sizeof(struct vertex2f);
 
    vl_vb_element_helper(&vertex_elems[VS_I_VPOS], 2, 1);
-   vertex_elems[VS_I_VPOS].src_stride = sizeof(struct vl_ycbcr_block);
 
    return pipe->create_vertex_elements_state(pipe, 3, vertex_elems);
 }
@@ -189,24 +188,19 @@ vl_vb_get_ves_mv(struct pipe_context *pipe)
 
    memset(&vertex_elems, 0, sizeof(vertex_elems));
    vertex_elems[VS_I_RECT] = vl_vb_get_quad_vertex_element();
-   vertex_elems[VS_I_RECT].src_stride = sizeof(struct vertex2f);
 
    /* Position element */
    vertex_elems[VS_I_VPOS].src_format = PIPE_FORMAT_R16G16_SSCALED;
 
    vl_vb_element_helper(&vertex_elems[VS_I_VPOS], 1, 1);
-   vertex_elems[VS_I_VPOS].src_stride = sizeof(struct vertex2s);
 
    /* motion vector TOP element */
    vertex_elems[VS_I_MV_TOP].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
-   vertex_elems[VS_I_MV_TOP].src_stride = sizeof(struct vertex2f);
 
    /* motion vector BOTTOM element */
    vertex_elems[VS_I_MV_BOTTOM].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
-   vertex_elems[VS_I_MV_BOTTOM].src_stride = sizeof(struct vertex2f);
 
    vl_vb_element_helper(&vertex_elems[VS_I_MV_TOP], 2, 2);
-   vertex_elems[VS_I_MV_TOP].src_stride = sizeof(struct vl_motionvector);
 
    return pipe->create_vertex_elements_state(pipe, NUM_VS_INPUTS, vertex_elems);
 }
diff --git a/src/gallium/auxiliary/vl/vl_video_buffer.c b/src/gallium/auxiliary/vl/vl_video_buffer.c
index 69cc4563df7..1d6b90b312c 100644
--- a/src/gallium/auxiliary/vl/vl_video_buffer.c
+++ b/src/gallium/auxiliary/vl/vl_video_buffer.c
@@ -73,7 +73,6 @@ vl_video_buffer_plane_order(enum pipe_format format)
 {
    switch(format) {
    case PIPE_FORMAT_YV12:
-   case PIPE_FORMAT_IYUV:
       return const_resource_plane_order_YVU;
 
    case PIPE_FORMAT_NV12:
@@ -118,21 +117,21 @@ vl_video_buffer_is_format_supported(struct pipe_screen *screen,
    vl_get_video_buffer_formats(screen, format, resource_formats);
 
    for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
-      enum pipe_format fmt = resource_formats[i];
+      enum pipe_format format = resource_formats[i];
 
-      if (fmt == PIPE_FORMAT_NONE)
+      if (format == PIPE_FORMAT_NONE)
          continue;
 
       /* we at least need to sample from it */
-      if (!screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D, 0, 0, PIPE_BIND_SAMPLER_VIEW))
-         continue;
+      if (!screen->is_format_supported(screen, format, PIPE_TEXTURE_2D, 0, 0, PIPE_BIND_SAMPLER_VIEW))
+         return false;
 
-      fmt = vl_video_buffer_surface_format(fmt);
-      if (screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D, 0, 0, PIPE_BIND_RENDER_TARGET))
-         return true;
+      format = vl_video_buffer_surface_format(format);
+      if (!screen->is_format_supported(screen, format, PIPE_TEXTURE_2D, 0, 0, PIPE_BIND_RENDER_TARGET))
+         return false;
    }
 
-   return false;
+   return true;
 }
 
 unsigned
@@ -296,19 +295,13 @@ vl_video_buffer_sampler_view_components(struct pipe_video_buffer *buffer)
          nr_components = 3;
 
       for (j = 0; j < nr_components && component < VL_NUM_COMPONENTS; ++j, ++component) {
-         unsigned pipe_swizzle;
-
          if (buf->sampler_view_components[component])
             continue;
 
          memset(&sv_templ, 0, sizeof(sv_templ));
          u_sampler_view_default_template(&sv_templ, res, sampler_format[plane_order[i]]);
-         pipe_swizzle = (buf->base.buffer_format == PIPE_FORMAT_YUYV || buf->base.buffer_format == PIPE_FORMAT_UYVY) ?
-                        (PIPE_SWIZZLE_X + j + 1) % 3 :
-                        (PIPE_SWIZZLE_X + j);
-         sv_templ.swizzle_r = sv_templ.swizzle_g = sv_templ.swizzle_b = pipe_swizzle;
+         sv_templ.swizzle_r = sv_templ.swizzle_g = sv_templ.swizzle_b = PIPE_SWIZZLE_X + j;
          sv_templ.swizzle_a = PIPE_SWIZZLE_1;
-
          buf->sampler_view_components[component] = pipe->create_sampler_view(pipe, res, &sv_templ);
          if (!buf->sampler_view_components[component])
             goto error;
diff --git a/src/gallium/auxiliary/vl/vl_winsys.h b/src/gallium/auxiliary/vl/vl_winsys.h
index 4590bbb9e2c..a3945b67e2c 100644
--- a/src/gallium/auxiliary/vl/vl_winsys.h
+++ b/src/gallium/auxiliary/vl/vl_winsys.h
@@ -29,10 +29,6 @@
  * Target makefiles directly refer to vl_winsys_dri.c to avoid DRI dependency
  */
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 #ifndef vl_winsys_h
 #define vl_winsys_h
 
@@ -41,7 +37,6 @@ extern "C" {
 #endif
 #ifdef _WIN32
 #include <windows.h>
-#include <unknwn.h>
 #endif
 #include "pipe/p_defines.h"
 #include "util/format/u_formats.h"
@@ -102,7 +97,6 @@ vl_dri3_screen_create(void *display, int screen) { return NULL; };
 
 #ifdef _WIN32
 struct vl_screen *vl_win32_screen_create(LUID *adapter);
-struct vl_screen *vl_win32_screen_create_from_d3d12_device(IUnknown* d3d12_device);
 #else
 /* Always enable the DRM vl winsys */
 struct vl_screen *
@@ -122,6 +116,3 @@ vl_xlib_swrast_screen_create(void *display, int screen) { return NULL; }
 #endif
 
 #endif
-#ifdef __cplusplus
-}
-#endif
\ No newline at end of file
diff --git a/src/gallium/auxiliary/vl/vl_winsys_dri.c b/src/gallium/auxiliary/vl/vl_winsys_dri.c
index 0abc90a13a7..091395d27f3 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_dri.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_dri.c
@@ -458,7 +458,7 @@ vl_dri2_screen_create(Display *display, int screen)
    if (authenticate == NULL || !authenticate->authenticated)
       goto free_authenticate;
 
-   if (pipe_loader_drm_probe_fd(&scrn->base.dev, fd, false))
+   if (pipe_loader_drm_probe_fd(&scrn->base.dev, fd))
       scrn->base.pscreen = pipe_loader_create_screen(scrn->base.dev);
 
    if (!scrn->base.pscreen)
diff --git a/src/gallium/auxiliary/vl/vl_winsys_dri3.c b/src/gallium/auxiliary/vl/vl_winsys_dri3.c
index af851fa5ee0..073630e5579 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_dri3.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_dri3.c
@@ -842,7 +842,7 @@ vl_dri3_screen_create(Display *display, int screen)
    scrn->base.color_depth = geom_reply->depth;
    free(geom_reply);
 
-   if (pipe_loader_drm_probe_fd(&scrn->base.dev, fd, false))
+   if (pipe_loader_drm_probe_fd(&scrn->base.dev, fd))
       scrn->base.pscreen = pipe_loader_create_screen(scrn->base.dev);
 
    if (!scrn->base.pscreen)
diff --git a/src/gallium/auxiliary/vl/vl_winsys_drm.c b/src/gallium/auxiliary/vl/vl_winsys_drm.c
index a35c8072908..bae0405e1f6 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_drm.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_drm.c
@@ -46,7 +46,7 @@ vl_drm_screen_create(int fd)
    if (!vscreen)
       return NULL;
 
-   if (pipe_loader_drm_probe_fd(&vscreen->dev, fd, false))
+   if (pipe_loader_drm_probe_fd(&vscreen->dev, fd))
       vscreen->pscreen = pipe_loader_create_screen(vscreen->dev);
 
    if (!vscreen->pscreen)
diff --git a/src/gallium/auxiliary/vl/vl_winsys_win32.c b/src/gallium/auxiliary/vl/vl_winsys_win32.c
index 8f92ddbde5f..6f12d0bb55c 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_win32.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_win32.c
@@ -28,7 +28,6 @@
 
 #include "gallium/winsys/sw/gdi/gdi_sw_winsys.h"
 #include "gallium/drivers/d3d12/d3d12_public.h"
-#include <unknwn.h>
 
 struct vl_win32_screen
 {
@@ -58,7 +57,7 @@ vl_win32_screen_create(LUID *adapter)
    if (!vscreen)
       return NULL;
 
-   struct sw_winsys* winsys = gdi_create_sw_winsys(gdi_sw_acquire_hdc_by_value, gdi_sw_release_hdc_by_value);
+   struct sw_winsys* winsys = gdi_create_sw_winsys();
    if (!winsys)
       goto release_pipe;
 
@@ -78,38 +77,6 @@ vl_win32_screen_create(LUID *adapter)
    return &vscreen->base;
 
 release_pipe:
-   if(winsys)
-      winsys->destroy(winsys);
-   vl_win32_screen_destroy(&vscreen->base);
-   return NULL;
-}
-
-struct vl_screen *
-vl_win32_screen_create_from_d3d12_device(IUnknown* d3d12_device)
-{
-   struct vl_win32_screen *vscreen = CALLOC_STRUCT(vl_win32_screen);
-   if (!vscreen)
-      return NULL;
-
-   struct sw_winsys* winsys = gdi_create_sw_winsys(gdi_sw_acquire_hdc_by_value, gdi_sw_release_hdc_by_value);
-   if (!winsys)
-      goto release_pipe;
-
-   vscreen->base.pscreen = d3d12_create_dxcore_screen_from_d3d12_device(winsys, d3d12_device, &vscreen->adapter_luid);
-
-   if (!vscreen->base.pscreen)
-      goto release_pipe;
-
-   vscreen->base.destroy = vl_win32_screen_destroy;
-   vscreen->base.get_private = NULL;
-   vscreen->base.texture_from_drawable = NULL;
-   vscreen->base.get_dirty_area = NULL;
-
-   return &vscreen->base;
-
-release_pipe:
-   if(winsys)
-      winsys->destroy(winsys);
    vl_win32_screen_destroy(&vscreen->base);
    return NULL;
 }
diff --git a/src/gallium/auxiliary/vl/vl_zscan.c b/src/gallium/auxiliary/vl/vl_zscan.c
index f332309724b..59bc36b0bec 100644
--- a/src/gallium/auxiliary/vl/vl_zscan.c
+++ b/src/gallium/auxiliary/vl/vl_zscan.c
@@ -49,6 +49,73 @@ enum VS_OUTPUT
    VS_O_VTEX = 0
 };
 
+const int vl_zscan_normal_16[] =
+{
+   /* Zig-Zag scan pattern */
+    0, 1, 4, 8, 5, 2, 3, 6,
+    9,12,13,10, 7,11,14,15
+};
+
+const int vl_zscan_linear[] =
+{
+   /* Linear scan pattern */
+    0, 1, 2, 3, 4, 5, 6, 7,
+    8, 9,10,11,12,13,14,15,
+   16,17,18,19,20,21,22,23,
+   24,25,26,27,28,29,30,31,
+   32,33,34,35,36,37,38,39,
+   40,41,42,43,44,45,46,47,
+   48,49,50,51,52,53,54,55,
+   56,57,58,59,60,61,62,63
+};
+
+const int vl_zscan_normal[] =
+{
+   /* Zig-Zag scan pattern */
+    0, 1, 8,16, 9, 2, 3,10,
+   17,24,32,25,18,11, 4, 5,
+   12,19,26,33,40,48,41,34,
+   27,20,13, 6, 7,14,21,28,
+   35,42,49,56,57,50,43,36,
+   29,22,15,23,30,37,44,51,
+   58,59,52,45,38,31,39,46,
+   53,60,61,54,47,55,62,63
+};
+
+const int vl_zscan_alternate[] =
+{
+   /* Alternate scan pattern */
+    0, 8,16,24, 1, 9, 2,10,
+   17,25,32,40,48,56,57,49,
+   41,33,26,18, 3,11, 4,12,
+   19,27,34,42,50,58,35,43,
+   51,59,20,28, 5,13, 6,14,
+   21,29,36,44,52,60,37,45,
+   53,61,22,30, 7,15,23,31,
+   38,46,54,62,39,47,55,63
+};
+
+const int vl_zscan_h265_up_right_diagonal_16[] =
+{
+   /* Up-right diagonal scan order for 4x4 blocks - see H.265 section 6.5.3. */
+    0,  4,  1,  8,  5,  2, 12,  9,
+    6,  3, 13, 10,  7, 14, 11, 15,
+};
+
+const int vl_zscan_h265_up_right_diagonal[] =
+{
+   /* Up-right diagonal scan order for 8x8 blocks - see H.265 section 6.5.3. */
+    0,  8,  1, 16,  9,  2, 24, 17,
+   10,  3, 32, 25, 18, 11,  4, 40,
+   33, 26, 19, 12,  5, 48, 41, 34,
+   27, 20, 13,  6, 56, 49, 42, 35,
+   28, 21, 14,  7, 57, 50, 43, 36,
+   29, 22, 15, 58, 51, 44, 37, 30,
+   23, 59, 52, 45, 38, 31, 60, 53,
+   46, 39, 61, 54, 47, 62, 55, 63,
+};
+
+
 static void *
 create_vert_shader(struct vl_zscan *zscan)
 {
diff --git a/src/gallium/auxiliary/vl/vl_zscan.h b/src/gallium/auxiliary/vl/vl_zscan.h
index 87fe6b4dfa1..135e7c3bafd 100644
--- a/src/gallium/auxiliary/vl/vl_zscan.h
+++ b/src/gallium/auxiliary/vl/vl_zscan.h
@@ -28,7 +28,6 @@
 #ifndef vl_zscan_h
 #define vl_zscan_h
 
-#include "util/vl_zscan_data.h"
 #include "util/compiler.h"
 #include "pipe/p_state.h"
 
@@ -69,6 +68,13 @@ struct vl_zscan_buffer
    struct pipe_surface *dst;
 };
 
+extern const int vl_zscan_normal_16[];
+extern const int vl_zscan_linear[];
+extern const int vl_zscan_normal[];
+extern const int vl_zscan_alternate[];
+extern const int vl_zscan_h265_up_right_diagonal_16[];
+extern const int vl_zscan_h265_up_right_diagonal[];
+
 struct pipe_sampler_view *
 vl_zscan_layout(struct pipe_context *pipe, const int layout[64], unsigned blocks_per_line);
 
diff --git a/src/glx/create_context.c b/src/glx/create_context.c
index 66f8e7e30ac..1c2bbb1cfd1 100644
--- a/src/glx/create_context.c
+++ b/src/glx/create_context.c
@@ -148,7 +148,7 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
                                                  cfg ? cfg->fbconfigID : 0,
                                                  screen,
                                                  share_xid,
-                                                 gc->isDirect,
+                                                 gc ? gc->isDirect : direct,
                                                  num_attribs,
                                                  (const uint32_t *)
                                                  attrib_list);
diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index 81314c0feea..79ca02ebf9a 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -979,9 +979,6 @@ dri2BindExtensions(struct dri2_screen *psc, struct glx_display * priv,
 
    if (psc->rendererQuery)
       __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
-
-   if (psc->interop)
-      __glXEnableDirectExtension(&psc->base, "GLX_MESA_gl_interop");
 }
 
 static char *
diff --git a/src/glx/dri2_priv.h b/src/glx/dri2_priv.h
index 4adf7c0f94b..837709fa5ec 100644
--- a/src/glx/dri2_priv.h
+++ b/src/glx/dri2_priv.h
@@ -83,7 +83,7 @@ dri2_interop_export_object(struct glx_context *ctx,
 _X_HIDDEN int
 dri2_interop_flush_objects(struct glx_context *ctx,
                            unsigned count, struct mesa_glinterop_export_in *objects,
-                           struct mesa_glinterop_flush_out *out);
+                           GLsync *sync);
 
 #ifdef __cplusplus
 }
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 12a05246af1..bd871e81193 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -755,9 +755,6 @@ dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
 
    if (psc->rendererQuery)
       __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
-
-   if (psc->interop)
-      __glXEnableDirectExtension(&psc->base, "GLX_MESA_gl_interop");
 }
 
 static char *
@@ -800,7 +797,6 @@ dri3_create_screen(int screen, struct glx_display * priv)
    __GLXDRIscreen *psp;
    struct glx_config *configs = NULL, *visuals = NULL;
    char *driverName, *driverNameDisplayGPU, *tmp;
-   bool return_zink = false;
 
    psc = calloc(1, sizeof *psc);
    if (psc == NULL)
@@ -836,11 +832,6 @@ dri3_create_screen(int screen, struct glx_display * priv)
       goto handle_error;
    }
 
-   if (!strcmp(driverName, "zink")) {
-      return_zink = true;
-      goto handle_error;
-   }
-
    extensions = driOpenDriver(driverName, &psc->driver);
    if (extensions == NULL)
       goto handle_error;
@@ -1015,8 +1006,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
    return &psc->base;
 
 handle_error:
-   if (!return_zink)
-      CriticalErrorMessageF("failed to load driver: %s\n", driverName ? driverName : "(null)");
+   CriticalErrorMessageF("failed to load driver: %s\n", driverName ? driverName : "(null)");
 
    if (configs)
        glx_config_destroy_list(configs);
@@ -1039,7 +1029,7 @@ handle_error:
    glx_screen_cleanup(&psc->base);
    free(psc);
 
-   return return_zink ? GLX_LOADER_USE_ZINK : NULL;
+   return NULL;
 }
 
 /** dri_destroy_display
@@ -1064,10 +1054,17 @@ dri3_destroy_display(__GLXDRIdisplay * dpy)
 #define DRI3_SUPPORTED_MINOR 0
 #endif
 
-
-bool
-dri3_check_multibuffer(Display * dpy, bool *err)
+/** dri3_create_display
+ *
+ * Allocate, initialize and return a __DRIdisplayPrivate object.
+ * This is called from __glXInitialize() when we are given a new
+ * display pointer. This is public to that function, but hidden from
+ * outside of libGL.
+ */
+_X_HIDDEN __GLXDRIdisplay *
+dri3_create_display(Display * dpy)
 {
+   struct dri3_display                  *pdp;
    xcb_connection_t                     *c = XGetXCBConnection(dpy);
    xcb_dri3_query_version_cookie_t      dri3_cookie;
    xcb_dri3_query_version_reply_t       *dri3_reply;
@@ -1081,11 +1078,11 @@ dri3_check_multibuffer(Display * dpy, bool *err)
 
    extension = xcb_get_extension_data(c, &xcb_dri3_id);
    if (!(extension && extension->present))
-      goto error;
+      return NULL;
 
    extension = xcb_get_extension_data(c, &xcb_present_id);
    if (!(extension && extension->present))
-      goto error;
+      return NULL;
 
    dri3_cookie = xcb_dri3_query_version(c,
                                         DRI3_SUPPORTED_MAJOR,
@@ -1094,10 +1091,14 @@ dri3_check_multibuffer(Display * dpy, bool *err)
                                               PRESENT_SUPPORTED_MAJOR,
                                               PRESENT_SUPPORTED_MINOR);
 
+   pdp = calloc(1, sizeof *pdp);
+   if (pdp == NULL)
+      return NULL;
+
    dri3_reply = xcb_dri3_query_version_reply(c, dri3_cookie, &error);
    if (!dri3_reply) {
       free(error);
-      goto error;
+      goto no_extension;
    }
 
    int dri3Major = dri3_reply->major_version;
@@ -1107,7 +1108,7 @@ dri3_check_multibuffer(Display * dpy, bool *err)
    present_reply = xcb_present_query_version_reply(c, present_cookie, &error);
    if (!present_reply) {
       free(error);
-      goto error;
+      goto no_extension;
    }
    int presentMajor = present_reply->major_version;
    int presentMinor = present_reply->minor_version;
@@ -1116,34 +1117,8 @@ dri3_check_multibuffer(Display * dpy, bool *err)
 #ifdef HAVE_DRI3_MODIFIERS
    if ((dri3Major > 1 || (dri3Major == 1 && dri3Minor >= 2)) &&
        (presentMajor > 1 || (presentMajor == 1 && presentMinor >= 2)))
-      return true;
+      pdp->has_multibuffer = true;
 #endif
-   return false;
-error:
-   *err = true;
-   return false;
-}
-
-/** dri3_create_display
- *
- * Allocate, initialize and return a __DRIdisplayPrivate object.
- * This is called from __glXInitialize() when we are given a new
- * display pointer. This is public to that function, but hidden from
- * outside of libGL.
- */
-_X_HIDDEN __GLXDRIdisplay *
-dri3_create_display(Display * dpy)
-{
-   struct dri3_display                  *pdp;
-   bool err = false;
-   bool has_multibuffer = dri3_check_multibuffer(dpy, &err);
-   if (err)
-      return NULL;
-
-   pdp = calloc(1, sizeof *pdp);
-   if (pdp == NULL)
-      return NULL;
-   pdp->has_multibuffer = has_multibuffer;
 
    pdp->base.destroyDisplay = dri3_destroy_display;
    pdp->base.createScreen = dri3_create_screen;
@@ -1151,6 +1126,9 @@ dri3_create_display(Display * dpy)
    pdp->loader_extensions = loader_extensions;
 
    return &pdp->base;
+no_extension:
+   free(pdp);
+   return NULL;
 }
 
 #endif /* GLX_DIRECT_RENDERING */
diff --git a/src/glx/dri3_priv.h b/src/glx/dri3_priv.h
index 0a9c0a648f8..7bfa6d68ace 100644
--- a/src/glx/dri3_priv.h
+++ b/src/glx/dri3_priv.h
@@ -120,8 +120,6 @@ struct dri3_drawable {
    unsigned frames;
 };
 
-bool
-dri3_check_multibuffer(Display * dpy, bool *err);
 
 _X_HIDDEN int
 dri3_query_renderer_integer(struct glx_screen *base, int attribute,
@@ -143,4 +141,4 @@ dri3_interop_export_object(struct glx_context *ctx,
 _X_HIDDEN int
 dri3_interop_flush_objects(struct glx_context *ctx,
                            unsigned count, struct mesa_glinterop_export_in *objects,
-                           struct mesa_glinterop_flush_out *out);
+                           GLsync *sync);
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 15b0e0fc328..3421d654b5a 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -116,6 +116,7 @@ static const struct
       __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER, doubleBufferMode),
       __ATTRIB(__DRI_ATTRIB_STEREO, stereoMode),
       __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS, numAuxBuffers),
+      __ATTRIB(__DRI_ATTRIB_SWAP_METHOD, swapMethod),
       __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB, bindToTextureRgb),
       __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA, bindToTextureRgba),
       __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE, bindToMipmapTexture),
@@ -178,6 +179,19 @@ driConfigEqual(const __DRIcoreExtension *core,
             return GL_FALSE;
          break;
 
+      case __DRI_ATTRIB_SWAP_METHOD:
+         if (value == __DRI_ATTRIB_SWAP_EXCHANGE)
+            glxValue = GLX_SWAP_EXCHANGE_OML;
+         else if (value == __DRI_ATTRIB_SWAP_COPY)
+            glxValue = GLX_SWAP_COPY_OML;
+         else
+            glxValue = GLX_SWAP_UNDEFINED_OML;
+
+         if (!scalarEqual(config, attrib, glxValue))
+            return GL_FALSE;
+
+         break;
+
       /* Nerf some attributes we can safely ignore if the server claims to
        * support them but the driver does not.
        */
diff --git a/src/glx/dri_common_interop.c b/src/glx/dri_common_interop.c
index c8038d60846..cce3776a35c 100644
--- a/src/glx/dri_common_interop.c
+++ b/src/glx/dri_common_interop.c
@@ -60,14 +60,14 @@ dri2_interop_export_object(struct glx_context *ctx,
 _X_HIDDEN int
 dri2_interop_flush_objects(struct glx_context *ctx,
                            unsigned count, struct mesa_glinterop_export_in *objects,
-                           struct mesa_glinterop_flush_out *out)
+                           GLsync *sync)
 {
    struct dri2_screen *psc = (struct dri2_screen*)ctx->psc;
 
    if (!psc->interop || psc->interop->base.version < 2)
       return MESA_GLINTEROP_UNSUPPORTED;
 
-   return psc->interop->flush_objects(ctx->driContext, count, objects, out);
+   return psc->interop->flush_objects(ctx->driContext, count, objects, sync);
 }
 
 #if defined(HAVE_DRI3)
@@ -100,14 +100,14 @@ dri3_interop_export_object(struct glx_context *ctx,
 _X_HIDDEN int
 dri3_interop_flush_objects(struct glx_context *ctx,
                            unsigned count, struct mesa_glinterop_export_in *objects,
-                           struct mesa_glinterop_flush_out *out)
+                           GLsync *sync)
 {
    struct dri3_screen *psc = (struct dri3_screen*)ctx->psc;
 
    if (!psc->interop || psc->interop->base.version < 2)
       return MESA_GLINTEROP_UNSUPPORTED;
 
-   return psc->interop->flush_objects(ctx->driContext, count, objects, out);
+   return psc->interop->flush_objects(ctx->driContext, count, objects, sync);
 }
 
 #endif /* HAVE_DRI3 */
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index 3d3f75259bc..7dd41eb8746 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -32,7 +32,6 @@
 #include <dlfcn.h>
 #include "dri_common.h"
 #include "drisw_priv.h"
-#include "dri3_priv.h"
 #include <X11/extensions/shmproto.h>
 #include <assert.h>
 #include <vulkan/vulkan_core.h>
@@ -727,11 +726,7 @@ driswCreateDrawable(struct glx_screen *base, XID xDrawable,
    /* Create a new drawable */
    if (kopper) {
       pdp->driDrawable =
-         kopper->createNewDrawable(psc->driScreen, config->driConfig, pdp,
-         &(__DRIkopperDrawableInfo){
-            .multiplanes_available = psc->has_multibuffer,
-            .is_pixmap = !(type & GLX_WINDOW_BIT),
-         });
+         kopper->createNewDrawable(psc->driScreen, config->driConfig, pdp, !(type & GLX_WINDOW_BIT));
 
       pdp->swapInterval = dri_get_initial_swap_interval(psc->driScreen, psc->config);
       psc->kopper->setSwapInterval(pdp->driDrawable, pdp->swapInterval);
@@ -995,17 +990,6 @@ driswCreateScreenDriver(int screen, struct glx_display *priv,
        goto handle_error;
    }
 
-   if (pdpyp->zink) {
-      bool err;
-      psc->has_multibuffer = dri3_check_multibuffer(priv->dpy, &err);
-      if (!psc->has_multibuffer &&
-          !debug_get_bool_option("LIBGL_ALWAYS_SOFTWARE", false) &&
-          !debug_get_bool_option("LIBGL_KOPPER_DRI2", false)) {
-         CriticalErrorMessageF("DRI3 not available\n");
-         goto handle_error;
-      }
-   }
-
    glx_config_destroy_list(psc->base.configs);
    psc->base.configs = configs;
    glx_config_destroy_list(psc->base.visuals);
diff --git a/src/glx/drisw_priv.h b/src/glx/drisw_priv.h
index 53674f81a24..d1f445bc0ad 100644
--- a/src/glx/drisw_priv.h
+++ b/src/glx/drisw_priv.h
@@ -56,8 +56,6 @@ struct drisw_screen
 
    void *driver;
    const char *name;
-
-   bool has_multibuffer;
 };
 
 struct drisw_drawable
diff --git a/src/glx/g_glxglvnddispatchfuncs.c b/src/glx/g_glxglvnddispatchfuncs.c
index a5d6f7d3360..c2defc77d3d 100644
--- a/src/glx/g_glxglvnddispatchfuncs.c
+++ b/src/glx/g_glxglvnddispatchfuncs.c
@@ -5,8 +5,6 @@
 #include "glxglvnddispatchfuncs.h"
 #include "g_glxglvnddispatchindices.h"
 
-#include "GL/mesa_glinterop.h"
-
 const int DI_FUNCTION_COUNT = DI_LAST_INDEX;
 /* Allocate an extra 'dummy' to ease lookup. See FindGLXFunction() */
 int __glXDispatchTableIndices[DI_LAST_INDEX + 1];
@@ -41,9 +39,6 @@ const char * const __glXDispatchTableStrings[DI_LAST_INDEX] = {
     // glXDestroyPixmap implemented by libglvnd
     // glXDestroyWindow implemented by libglvnd
     // glXFreeContextEXT implemented by libglvnd
-    __ATTRIB(GLInteropExportObjectMESA),
-    __ATTRIB(GLInteropFlushObjectsMESA),
-    __ATTRIB(GLInteropQueryDeviceInfoMESA),
     // glXGetClientString implemented by libglvnd
     // glXGetConfig implemented by libglvnd
     __ATTRIB(GetContextIDEXT),
@@ -311,63 +306,6 @@ static void dispatch_DestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf)
 
 
 
-static int dispatch_GLInteropExportObjectMESA(Display *dpy, GLXContext ctx,
-                                              struct mesa_glinterop_export_in *in,
-                                              struct mesa_glinterop_export_out *out)
-{
-    PFNMESAGLINTEROPGLXEXPORTOBJECTPROC pGLInteropExportObjectMESA;
-    __GLXvendorInfo *dd;
-
-    dd = GetDispatchFromContext(ctx);
-    if (dd == NULL)
-        return 0;
-
-    __FETCH_FUNCTION_PTR(GLInteropExportObjectMESA);
-    if (pGLInteropExportObjectMESA == NULL)
-        return 0;
-
-    return pGLInteropExportObjectMESA(dpy, ctx, in, out);
-}
-
-
-static int dispatch_GLInteropFlushObjectsMESA(Display *dpy, GLXContext ctx,
-                                              unsigned count,
-                                              struct mesa_glinterop_export_in *resources,
-                                              struct mesa_glinterop_flush_out *out)
-{
-    PFNMESAGLINTEROPGLXFLUSHOBJECTSPROC pGLInteropFlushObjectsMESA;
-    __GLXvendorInfo *dd;
-
-    dd = GetDispatchFromContext(ctx);
-    if (dd == NULL)
-        return 0;
-
-    __FETCH_FUNCTION_PTR(GLInteropFlushObjectsMESA);
-    if (pGLInteropFlushObjectsMESA == NULL)
-        return 0;
-
-    return pGLInteropFlushObjectsMESA(dpy, ctx, count, resources, out);
-}
-
-
-static int dispatch_GLInteropQueryDeviceInfoMESA(Display *dpy, GLXContext ctx,
-                                                 struct mesa_glinterop_device_info *out)
-{
-    PFNMESAGLINTEROPGLXQUERYDEVICEINFOPROC pGLInteropQueryDeviceInfoMESA;
-    __GLXvendorInfo *dd;
-
-    dd = GetDispatchFromContext(ctx);
-    if (dd == NULL)
-        return 0;
-
-    __FETCH_FUNCTION_PTR(GLInteropQueryDeviceInfoMESA);
-    if (pGLInteropQueryDeviceInfoMESA == NULL)
-        return 0;
-
-    return pGLInteropQueryDeviceInfoMESA(dpy, ctx, out);
-}
-
-
 static GLXContextID dispatch_GetContextIDEXT(const GLXContext ctx)
 {
     PFNGLXGETCONTEXTIDEXTPROC pGetContextIDEXT;
@@ -1043,9 +981,6 @@ const void * const __glXDispatchFunctions[DI_LAST_INDEX + 1] = {
     __ATTRIB(CreateGLXPixmapMESA),
     __ATTRIB(CreateGLXPixmapWithConfigSGIX),
     __ATTRIB(DestroyGLXPbufferSGIX),
-    __ATTRIB(GLInteropExportObjectMESA),
-    __ATTRIB(GLInteropFlushObjectsMESA),
-    __ATTRIB(GLInteropQueryDeviceInfoMESA),
     __ATTRIB(GetContextIDEXT),
     __ATTRIB(GetCurrentDisplayEXT),
     __ATTRIB(GetDriverConfig),
diff --git a/src/glx/g_glxglvnddispatchindices.h b/src/glx/g_glxglvnddispatchindices.h
index 70047dc6559..b65d078098f 100644
--- a/src/glx/g_glxglvnddispatchindices.h
+++ b/src/glx/g_glxglvnddispatchindices.h
@@ -31,9 +31,6 @@ typedef enum __GLXdispatchIndex {
     // DestroyPixmap implemented by libglvnd
     // DestroyWindow implemented by libglvnd
     // FreeContextEXT implemented by libglvnd
-    DI_GLInteropExportObjectMESA,
-    DI_GLInteropFlushObjectsMESA,
-    DI_GLInteropQueryDeviceInfoMESA,
     // GetClientString implemented by libglvnd
     // GetConfig implemented by libglvnd
     DI_GetContextIDEXT,
diff --git a/src/glx/glx_pbuffer.c b/src/glx/glx_pbuffer.c
index d95a3e90c24..0b3cdfaa587 100644
--- a/src/glx/glx_pbuffer.c
+++ b/src/glx/glx_pbuffer.c
@@ -239,7 +239,6 @@ __glXGetDrawableAttribute(Display * dpy, GLXDrawable drawable,
     *     generated."
     */
    if (drawable == 0) {
-      XNoOp(dpy);
       __glXSendError(dpy, GLXBadDrawable, 0, X_GLXGetDrawableAttributes, false);
       return 0;
    }
@@ -270,7 +269,6 @@ __glXGetDrawableAttribute(Display * dpy, GLXDrawable drawable,
       if (pdraw == NULL || gc == &dummyContext || gc->currentDpy != dpy ||
          (gc->currentDrawable != drawable &&
          gc->currentReadable != drawable)) {
-         XNoOp(dpy);
          __glXSendError(dpy, GLXBadDrawable, drawable,
                         X_GLXGetDrawableAttributes, false);
          return 0;
diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index e262b4a80fa..f884a18f205 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -78,8 +78,6 @@ typedef struct __GLXDRIdisplayRec __GLXDRIdisplay;
 typedef struct __GLXDRIscreenRec __GLXDRIscreen;
 typedef struct __GLXDRIdrawableRec __GLXDRIdrawable;
 
-#define GLX_LOADER_USE_ZINK ((struct glx_screen *)(uintptr_t)-1)
-
 struct __GLXDRIdisplayRec
 {
     /**
@@ -210,7 +208,6 @@ typedef struct __GLXattributeMachineRec
 struct mesa_glinterop_device_info;
 struct mesa_glinterop_export_in;
 struct mesa_glinterop_export_out;
-struct mesa_glinterop_flush_out;
 
 struct glx_context_vtable {
    void (*destroy)(struct glx_context *ctx);
@@ -225,7 +222,7 @@ struct glx_context_vtable {
                                 struct mesa_glinterop_export_out *out);
    int (*interop_flush_objects)(struct glx_context *ctx,
                                 unsigned count, struct mesa_glinterop_export_in *objects,
-                                struct mesa_glinterop_flush_out *out);
+                                GLsync *sync);
 };
 
 /**
@@ -460,7 +457,7 @@ struct glx_screen_vtable {
    /* The error outparameter abuses the fact that the only possible errors are
     * GLXBadContext (0), GLXBadFBConfig (9), GLXBadProfileARB (13), BadValue
     * (2), BadMatch (8), and BadAlloc (11). Since those don't collide we just
-    * use them directly rather than try to offset or use a sign convention.
+    * use them directly rather than try to offset or use a sign convention. 
     */
    struct glx_context *(*create_context_attribs)(struct glx_screen *psc,
 						 struct glx_config *config,
diff --git a/src/glx/glxcmds.c b/src/glx/glxcmds.c
index 295fd1836c7..21537b7e6ff 100644
--- a/src/glx/glxcmds.c
+++ b/src/glx/glxcmds.c
@@ -596,7 +596,7 @@ glXCopyContext(Display * dpy, GLXContext source_user,
                              mask, &errorcode, &x11error)) {
       __glXSendError(dpy, errorcode, 0, X_GLXCopyContext, x11error);
    }
-
+   
 #else
    xGLXCopyContextReq *req;
    struct glx_context *gc = __glXGetCurrentContext();
@@ -773,6 +773,7 @@ init_fbconfig_for_chooser(struct glx_config * config,
    config->xRenderable = GLX_DONT_CARE;
    config->fbconfigID = (GLXFBConfigID) (GLX_DONT_CARE);
 
+   config->swapMethod = GLX_DONT_CARE;
    config->sRGBCapable = GLX_DONT_CARE;
 }
 
@@ -823,6 +824,7 @@ fbconfigs_compatible(const struct glx_config * const a,
    MATCH_DONT_CARE(visualRating);
    MATCH_DONT_CARE(xRenderable);
    MATCH_DONT_CARE(fbconfigID);
+   MATCH_DONT_CARE(swapMethod);
 
    MATCH_MINIMUM(rgbBits);
    MATCH_MINIMUM(numAuxBuffers);
@@ -1114,7 +1116,7 @@ glXChooseVisual(Display * dpy, int screen, int *attribList)
                                   &visualTemplate, &i);
 
          if (newList) {
-            XFree(visualList);
+            free(visualList);
             visualList = newList;
             best_config = config;
          }
@@ -1756,7 +1758,7 @@ glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
 
 /*
 ** GLX_SGIX_fbconfig
-** Many of these functions are aliased to GLX 1.3 entry points in the
+** Many of these functions are aliased to GLX 1.3 entry points in the 
 ** GLX_functions table.
 */
 
@@ -2337,13 +2339,6 @@ static const struct name_address_pair GLX_functions[] = {
    GLX_FUNCTION(glXQueryCurrentRendererIntegerMESA),
    GLX_FUNCTION(glXQueryCurrentRendererStringMESA),
 
-   /*** GLX_MESA_gl_interop ***/
-#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
-   GLX_FUNCTION2(glXGLInteropQueryDeviceInfoMESA, MesaGLInteropGLXQueryDeviceInfo),
-   GLX_FUNCTION2(glXGLInteropExportObjectMESA, MesaGLInteropGLXExportObject),
-   GLX_FUNCTION2(glXGLInteropFlushObjectsMESA, MesaGLInteropGLXFlushObjects),
-#endif
-
    {NULL, NULL}                 /* end of list */
 };
 
@@ -2454,30 +2449,4 @@ MesaGLInteropGLXExportObject(Display *dpy, GLXContext context,
    return ret;
 }
 
-PUBLIC int
-MesaGLInteropGLXFlushObjects(Display *dpy, GLXContext context,
-                             unsigned count,
-                             struct mesa_glinterop_export_in *resources,
-                             struct mesa_glinterop_flush_out *out)
-{
-   struct glx_context *gc = (struct glx_context*)context;
-   int ret;
-
-   __glXLock();
-
-   if (!gc || gc->xid == None || !gc->isDirect) {
-      __glXUnlock();
-      return MESA_GLINTEROP_INVALID_CONTEXT;
-   }
-
-   if (!gc->vtable->interop_flush_objects) {
-      __glXUnlock();
-      return MESA_GLINTEROP_UNSUPPORTED;
-   }
-
-   ret = gc->vtable->interop_flush_objects(gc, count, resources, out);
-   __glXUnlock();
-   return ret;
-}
-
 #endif /* defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL) */
diff --git a/src/glx/glxconfig.c b/src/glx/glxconfig.c
index f22d055231a..6f9670bb86c 100644
--- a/src/glx/glxconfig.c
+++ b/src/glx/glxconfig.c
@@ -160,6 +160,9 @@ glx_config_get(struct glx_config * mode, int attribute, int *value_return)
    case GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX:
       *value_return = mode->optimalPbufferHeight;
       return 0;
+   case GLX_SWAP_METHOD_OML:
+      *value_return = mode->swapMethod;
+      return 0;
 #endif
    case GLX_SAMPLE_BUFFERS_SGIS:
       *value_return = mode->sampleBuffers;
@@ -242,6 +245,7 @@ glx_config_create_list(unsigned count)
       (*next)->transparentIndex = GLX_DONT_CARE;
       (*next)->xRenderable = GLX_DONT_CARE;
       (*next)->fbconfigID = GLX_DONT_CARE;
+      (*next)->swapMethod = GLX_SWAP_UNDEFINED_OML;
       (*next)->bindToTextureRgb = GLX_DONT_CARE;
       (*next)->bindToTextureRgba = GLX_DONT_CARE;
       (*next)->bindToMipmapTexture = GLX_DONT_CARE;
diff --git a/src/glx/glxconfig.h b/src/glx/glxconfig.h
index 49abc4f4ad8..009357ce271 100644
--- a/src/glx/glxconfig.h
+++ b/src/glx/glxconfig.h
@@ -85,6 +85,9 @@ struct glx_config {
     /* SGIX_visual_select_group */
     GLint visualSelectGroup;
 
+    /* OML_swap_method */
+    GLint swapMethod;
+
     GLint screen;
 
     /* EXT_texture_from_pixmap */
diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index 6cf04d1b745..01d5bda497c 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -66,6 +66,7 @@ glx_message(int level, const char *f, ...)
 
    /* Note that the _LOADER_* levels are lower numbers for more severe. */
    if (level <= threshold) {
+      fprintf(stderr, "libGL%s: ", level <= _LOADER_WARNING ? " error" : "");
       va_start(args, f);
       vfprintf(stderr, f, args);
       va_end(args);
@@ -556,6 +557,19 @@ __glXInitializeVisualConfigFromTags(struct glx_config * config, int count,
       case GLX_VISUAL_SELECT_GROUP_SGIX:
          config->visualSelectGroup = *bp++;
          break;
+      case GLX_SWAP_METHOD_OML:
+         if (*bp == GLX_SWAP_UNDEFINED_OML ||
+             *bp == GLX_SWAP_COPY_OML ||
+             *bp == GLX_SWAP_EXCHANGE_OML) {
+            config->swapMethod = *bp++;
+         } else {
+            /* X servers with old HW drivers may return any value here, so
+             * assume GLX_SWAP_METHOD_UNDEFINED.
+             */
+            config->swapMethod = GLX_SWAP_UNDEFINED_OML;
+            bp++;
+         }
+         break;
 #endif
       case GLX_SAMPLE_BUFFERS_SGIS:
          config->sampleBuffers = *bp++;
@@ -563,11 +577,12 @@ __glXInitializeVisualConfigFromTags(struct glx_config * config, int count,
       case GLX_SAMPLES_SGIS:
          config->samples = *bp++;
          break;
+#ifdef GLX_USE_APPLEGL
       case IGNORE_GLX_SWAP_METHOD_OML:
          /* We ignore this tag.  See the comment above this function. */
          ++bp;
          break;
-#ifndef GLX_USE_APPLEGL
+#else
       case GLX_BIND_TO_TEXTURE_RGB_EXT:
          config->bindToTextureRgb = *bp++;
          break;
@@ -763,11 +778,10 @@ glx_screen_cleanup(struct glx_screen *psc)
 ** If that works then fetch the per screen configs data.
 */
 static Bool
-AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
+AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
 {
    struct glx_screen *psc;
    GLint i, screens;
-   unsigned screen_count = 0;
 
    /*
     ** First allocate memory for the array of per screen configs.
@@ -777,7 +791,7 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
    if (!priv->screens)
       return GL_FALSE;
 
-   for (i = 0; i < screens; i++) {
+   for (i = 0; i < screens; i++, psc++) {
       psc = NULL;
 #if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
 #if defined(GLX_USE_DRM)
@@ -794,7 +808,7 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
 	 psc = priv->windowsdriDisplay->createScreen(i, priv);
 #endif
 
-      if ((psc == GLX_LOADER_USE_ZINK || psc == NULL) && priv->driswDisplay)
+      if (psc == NULL && priv->driswDisplay)
 	 psc = priv->driswDisplay->createScreen(i, priv);
 #endif /* GLX_DIRECT_RENDERING && !GLX_USE_APPLEGL */
 
@@ -804,21 +818,17 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
       if (psc == NULL)
          psc = applegl_create_screen(i, priv);
 #else
-      if (psc == NULL && !zink)
+      if (psc == NULL)
       {
          psc = indirect_create_screen(i, priv);
          indirect = true;
       }
 #endif
       priv->screens[i] = psc;
-      if (psc)
-         screen_count++;
 
       if(indirect) /* Load extensions required only for indirect glx */
          glxSendClientInfo(priv, i);
    }
-   if (zink && !screen_count)
-      return GL_FALSE;
    SyncHandle();
    return GL_TRUE;
 }
@@ -877,16 +887,12 @@ __glXInitialize(Display * dpy)
 
    dpyPriv->glXDrawHash = __glxHashCreate();
 
-   Bool zink = False;
-   Bool try_zink = False;
-
 #if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
    Bool glx_direct = !debug_get_bool_option("LIBGL_ALWAYS_INDIRECT", false);
    Bool glx_accel = !debug_get_bool_option("LIBGL_ALWAYS_SOFTWARE", false);
+   Bool zink;
    const char *env = getenv("MESA_LOADER_DRIVER_OVERRIDE");
-
    zink = env && !strcmp(env, "zink");
-   try_zink = False;
 
    dpyPriv->drawHash = __glxHashCreate();
 
@@ -903,22 +909,15 @@ __glXInitialize(Display * dpy)
 #if defined(GLX_USE_DRM)
    if (glx_direct && glx_accel && !zink) {
 #if defined(HAVE_DRI3)
-      if (!debug_get_bool_option("LIBGL_DRI3_DISABLE", false)) {
+      if (!debug_get_bool_option("LIBGL_DRI3_DISABLE", false))
          dpyPriv->dri3Display = dri3_create_display(dpy);
-         /* nouveau wants to fallback to zink so if we get a screen enable try_zink */
-         if (dpyPriv->dri3Display)
-            try_zink = !debug_get_bool_option("LIBGL_KOPPER_DISABLE", false);
-      }
 #endif /* HAVE_DRI3 */
       if (!debug_get_bool_option("LIBGL_DRI2_DISABLE", false))
          dpyPriv->dri2Display = dri2CreateDisplay(dpy);
-      if (!dpyPriv->dri3Display && !dpyPriv->dri2Display)
-         try_zink = !debug_get_bool_option("LIBGL_KOPPER_DISABLE", false) &&
-                    !getenv("GALLIUM_DRIVER");
    }
 #endif /* GLX_USE_DRM */
    if (glx_direct)
-      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink | try_zink);
+      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink);
 
 #ifdef GLX_USE_WINDOWSGL
    if (glx_direct && glx_accel)
@@ -933,20 +932,9 @@ __glXInitialize(Display * dpy)
    }
 #endif
 
-   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv, zink | try_zink)) {
-      Bool fail = True;
-#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
-      if (try_zink) {
-         free(dpyPriv->screens);
-         dpyPriv->driswDisplay->destroyDisplay(dpyPriv->driswDisplay);
-         dpyPriv->driswDisplay = driswCreateDisplay(dpy, false);
-         fail = !AllocAndFetchScreenConfigs(dpy, dpyPriv, False);
-      }
-#endif
-      if (fail) {
-         free(dpyPriv);
-         return NULL;
-      }
+   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
+      free(dpyPriv);
+      return NULL;
    }
 
    glxSendClientInfo(dpyPriv, -1);
diff --git a/src/glx/glxextensions.c b/src/glx/glxextensions.c
index 71b2c94d092..b731042cde7 100644
--- a/src/glx/glxextensions.c
+++ b/src/glx/glxextensions.c
@@ -105,10 +105,10 @@ static const struct extension_info known_glx_extensions[] = {
    { GLX(ATI_pixel_format_float),         N, N },
    { GLX(INTEL_swap_event),               N, N },
    { GLX(MESA_copy_sub_buffer),           N, N },
-   { GLX(MESA_gl_interop),                N, Y },
    { GLX(MESA_query_renderer),            N, Y },
    { GLX(MESA_swap_control),              N, Y },
    { GLX(NV_float_buffer),                N, N },
+   { GLX(OML_swap_method),                Y, N },
    { GLX(OML_sync_control),               N, Y },
    { GLX(SGIS_multisample),               Y, N },
    { GLX(SGIX_fbconfig),                  Y, N },
diff --git a/src/glx/glxextensions.h b/src/glx/glxextensions.h
index 37f60f5cf85..3523998babd 100644
--- a/src/glx/glxextensions.h
+++ b/src/glx/glxextensions.h
@@ -60,11 +60,12 @@ enum
    ATI_pixel_format_float_bit,
    INTEL_swap_event_bit,
    MESA_copy_sub_buffer_bit,
-   MESA_gl_interop_bit,
+   MESA_depth_float_bit,
    MESA_query_renderer_bit,
    MESA_swap_control_bit,
    MESA_swap_frame_usage_bit,
    NV_float_buffer_bit,
+   OML_swap_method_bit,
    OML_sync_control_bit,
    SGIS_multisample_bit,
    SGIX_fbconfig_bit,
diff --git a/src/glx/meson.build b/src/glx/meson.build
index 1a5e9833956..20f04742894 100644
--- a/src/glx/meson.build
+++ b/src/glx/meson.build
@@ -125,7 +125,7 @@ endif
 libglx = static_library(
   'glx',
   [files_libglx, glx_generated],
-  include_directories : [inc_include, inc_src, inc_glapi, inc_loader],
+  include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_glapi, inc_loader],
   c_args : [
     '-DGL_LIB_NAME="lib@0@.so.@1@"'.format(gl_lib_name, gl_lib_version.split('.')[0]),
   ],
@@ -136,7 +136,7 @@ libglx = static_library(
   ],
   dependencies : [
     idep_mesautil, idep_xmlconfig,
-    dep_libdrm, dep_dri2proto, dep_glproto, dep_x11, dep_xext, dep_glvnd, dep_xxf86vm, dep_xshmfence
+    dep_libdrm, dep_dri2proto, dep_glproto, dep_x11, dep_glvnd, dep_xxf86vm, dep_xshmfence
   ],
 )
 
diff --git a/src/loader/loader.c b/src/loader/loader.c
index db242b8f8f4..c06096d79fb 100644
--- a/src/loader/loader.c
+++ b/src/loader/loader.c
@@ -51,11 +51,8 @@
 #include "util/libdrm.h"
 #include "util/os_file.h"
 #include "util/os_misc.h"
-#include "util/u_debug.h"
 #include "git_sha1.h"
 
-#include "drm-uapi/nouveau_drm.h"
-
 #define MAX_DRM_DEVICES 64
 
 #ifdef USE_DRICONF
@@ -105,8 +102,7 @@ loader_open_device(const char *device_name)
    return fd;
 }
 
-char *
-loader_get_kernel_driver_name(int fd)
+static char *loader_get_kernel_driver_name(int fd)
 {
    char *driver;
    drmVersionPtr version = drmGetVersion(fd);
@@ -125,7 +121,7 @@ loader_get_kernel_driver_name(int fd)
 }
 
 bool
-iris_predicate(int fd, const char *driver)
+iris_predicate(int fd)
 {
    char *kernel_driver = loader_get_kernel_driver_name(fd);
    bool ret = kernel_driver && (strcmp(kernel_driver, "i915") == 0 ||
@@ -135,50 +131,11 @@ iris_predicate(int fd, const char *driver)
    return ret;
 }
 
-/* choose zink or nouveau GL */
-bool
-nouveau_zink_predicate(int fd, const char *driver)
-{
-#if !defined(HAVE_NVK) || !defined(HAVE_ZINK)
-   if (!strcmp(driver, "zink"))
-      return false;
-   return true;
-#else
-
-   bool prefer_zink = false;
-
-   /* enable this once zink is up to speed.
-    * struct drm_nouveau_getparam r = { .param = NOUVEAU_GETPARAM_CHIPSET_ID };
-    * int ret = drmCommandWriteRead(fd, DRM_NOUVEAU_GETPARAM, &r, sizeof(r));
-    * if (ret == 0 && (r.value & ~0xf) >= 0x160)
-    *    prefer_zink = true;
-    */
-
-   prefer_zink = debug_get_bool_option("NOUVEAU_USE_ZINK", prefer_zink);
-
-   if (prefer_zink && !strcmp(driver, "zink"))
-      return true;
-
-   if (!prefer_zink && !strcmp(driver, "nouveau"))
-      return true;
-   return false;
-#endif
-}
-
-
-/**
- * Goes through all the platform devices whose driver is on the given list and
- * try to open their render node. It returns the fd of the first device that
- * it can open.
- */
 int
-loader_open_render_node_platform_device(const char * const drivers[],
-                                        unsigned int n_drivers)
+loader_open_render_node(const char *name)
 {
    drmDevicePtr devices[MAX_DRM_DEVICES], device;
-   int num_devices, fd = -1;
-   int i, j;
-   bool found = false;
+   int i, num_devices, fd = -1;
 
    num_devices = drmGetDevices2(0, devices, MAX_DRM_DEVICES);
    if (num_devices <= 0)
@@ -201,13 +158,7 @@ loader_open_render_node_platform_device(const char * const drivers[],
             continue;
          }
 
-         for (j = 0; j < n_drivers; j++) {
-            if (strcmp(version->name, drivers[j]) == 0) {
-               found = true;
-               break;
-            }
-         }
-         if (!found) {
+         if (strcmp(version->name, name) != 0) {
             drmFreeVersion(version);
             close(fd);
             continue;
@@ -225,22 +176,6 @@ loader_open_render_node_platform_device(const char * const drivers[],
    return fd;
 }
 
-bool
-loader_is_device_render_capable(int fd)
-{
-   drmDevicePtr dev_ptr;
-   bool ret;
-
-   if (drmGetDevice2(fd, 0, &dev_ptr) != 0)
-      return false;
-
-   ret = (dev_ptr->available_nodes & (1 << DRM_NODE_RENDER));
-
-   drmFreeDevice(&dev_ptr);
-
-   return ret;
-}
-
 char *
 loader_get_render_node(dev_t device)
 {
@@ -388,54 +323,23 @@ static char *drm_get_id_path_tag_for_fd(int fd)
 bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
 {
    const char *dri_prime = getenv("DRI_PRIME");
-   bool debug = debug_get_bool_option("DRI_PRIME_DEBUG", false);
-   char *default_tag = NULL;
+   char *default_tag, *prime = NULL;
    drmDevicePtr devices[MAX_DRM_DEVICES];
    int i, num_devices, fd = -1;
-   struct {
-      enum {
-         PRIME_IS_INTEGER,
-         PRIME_IS_VID_DID,
-         PRIME_IS_PCI_TAG
-      } semantics;
-      union {
-         int as_integer;
-         struct {
-            uint16_t v, d;
-         } as_vendor_device_ids;
-      } v;
-      char *str;
-   } prime = {};
-   prime.str = NULL;
+   bool prime_is_vid_did;
+   uint16_t vendor_id, device_id;
 
    if (dri_prime)
-      prime.str = strdup(dri_prime);
+      prime = strdup(dri_prime);
 #ifdef USE_DRICONF
    else
-      prime.str = loader_get_dri_config_device_id();
+      prime = loader_get_dri_config_device_id();
 #endif
 
-   if (prime.str == NULL) {
+   if (prime == NULL)
       goto no_prime_gpu_offloading;
-   } else {
-      uint16_t vendor_id, device_id;
-      if (sscanf(prime.str, "%hx:%hx", &vendor_id, &device_id) == 2) {
-         prime.semantics = PRIME_IS_VID_DID;
-         prime.v.as_vendor_device_ids.v = vendor_id;
-         prime.v.as_vendor_device_ids.d = device_id;
-      } else {
-         int i = atoi(prime.str);
-         if (i < 0 || strcmp(prime.str, "0") == 0) {
-            printf("Invalid value (%d) for DRI_PRIME. Should be > 0\n", i);
-            goto err;
-         } else if (i == 0) {
-            prime.semantics = PRIME_IS_PCI_TAG;
-         } else {
-            prime.semantics = PRIME_IS_INTEGER;
-            prime.v.as_integer = i;
-         }
-      }
-   }
+   else
+      prime_is_vid_did = sscanf(prime, "%hx:%hx", &vendor_id, &device_id) == 2;
 
    default_tag = drm_get_id_path_tag_for_fd(*fd_render_gpu);
    if (default_tag == NULL)
@@ -445,103 +349,33 @@ bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
    if (num_devices <= 0)
       goto err;
 
-   if (debug) {
-      log_(_LOADER_WARNING, "DRI_PRIME: %d devices\n", num_devices);
-      for (i = 0; i < num_devices; i++) {
-         log_(_LOADER_WARNING, "  %d:", i);
-         if (!(devices[i]->available_nodes & 1 << DRM_NODE_RENDER)) {
-            log_(_LOADER_WARNING, "not a render node -> not usable\n");
-            continue;
-         }
-         char *tag = drm_construct_id_path_tag(devices[i]);
-         if (tag) {
-            log_(_LOADER_WARNING, " %s", tag);
-            free(tag);
-         }
-         if (devices[i]->bustype == DRM_BUS_PCI) {
-            log_(_LOADER_WARNING, " %4x:%4x",
-               devices[i]->deviceinfo.pci->vendor_id,
-               devices[i]->deviceinfo.pci->device_id);
-         }
-         log_(_LOADER_WARNING, " %s", devices[i]->nodes[DRM_NODE_RENDER]);
-
-         if (drm_device_matches_tag(devices[i], default_tag)) {
-            log_(_LOADER_WARNING, " [default]");
-         }
-         log_(_LOADER_WARNING, "\n");
-      }
-   }
-
-   if (prime.semantics == PRIME_IS_INTEGER &&
-       prime.v.as_integer >= num_devices) {
-      printf("Inconsistent value (%d) for DRI_PRIME. Should be < %d "
-             "(GPU devices count). Using: %d\n",
-             prime.v.as_integer, num_devices, num_devices - 1);
-      prime.v.as_integer = num_devices - 1;
-   }
-
    for (i = 0; i < num_devices; i++) {
       if (!(devices[i]->available_nodes & 1 << DRM_NODE_RENDER))
          continue;
 
-      log_(debug ? _LOADER_WARNING : _LOADER_INFO, "DRI_PRIME: device %d ", i);
-
       /* three formats of DRI_PRIME are supported:
-       * "N": a >= 1 integer value. Select the Nth GPU, skipping the
-       *      default one.
+       * "1": choose any other card than the card used by default.
        * id_path_tag: (for example "pci-0000_02_00_0") choose the card
        * with this id_path_tag.
        * vendor_id:device_id
        */
-      switch (prime.semantics) {
-         case PRIME_IS_INTEGER: {
-            /* Skip the default device */
-            if (drm_device_matches_tag(devices[i], default_tag)) {
-               log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-                    "skipped (default device)\n");
-               continue;
-            }
-            prime.v.as_integer--;
-
-            /* Skip more GPUs? */
-            if (prime.v.as_integer) {
-               log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-                    "skipped (%d more to skip)\n", prime.v.as_integer - 1);
-               continue;
-            }
-            log_(debug ? _LOADER_WARNING : _LOADER_INFO, " -> ");
-            break;
-         }
-         case PRIME_IS_VID_DID: {
-            if (devices[i]->bustype == DRM_BUS_PCI &&
-                devices[i]->deviceinfo.pci->vendor_id == prime.v.as_vendor_device_ids.v &&
-                devices[i]->deviceinfo.pci->device_id == prime.v.as_vendor_device_ids.d) {
-               /* Update prime for the "different_device"
-                * determination below. */
-               free(prime.str);
-               prime.str = drm_construct_id_path_tag(devices[i]);
-               log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-                    " - vid:did match -> ");
-               break;
-            } else {
-               log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-                    "skipped (vid:did didn't match)\n");
-            }
+      if (!strcmp(prime,"1")) {
+         if (drm_device_matches_tag(devices[i], default_tag))
             continue;
-         }
-         case PRIME_IS_PCI_TAG: {
-            if (!drm_device_matches_tag(devices[i], prime.str)) {
-               log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-                    "skipped (pci id tag didn't match)\n");
+      } else {
+         if (prime_is_vid_did && devices[i]->bustype == DRM_BUS_PCI &&
+             devices[i]->deviceinfo.pci->vendor_id == vendor_id &&
+             devices[i]->deviceinfo.pci->device_id == device_id) {
+            /* Update prime for the "different_device"
+             * determination below. */
+            free(prime);
+            prime = drm_construct_id_path_tag(devices[i]);
+         } else {
+            if (!drm_device_matches_tag(devices[i], prime))
                continue;
-            }
-            log_(debug ? _LOADER_WARNING : _LOADER_INFO, " - pci tag match -> ");
-            break;
          }
       }
 
-      log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-           "selected (%s)\n", devices[i]->nodes[DRM_NODE_RENDER]);
       fd = loader_open_device(devices[i]->nodes[DRM_NODE_RENDER]);
       break;
    }
@@ -550,15 +384,10 @@ bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
    if (i == num_devices)
       goto err;
 
-   if (fd < 0) {
-      log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-           "DRI_PRIME: failed to open '%s'\n",
-           devices[i]->nodes[DRM_NODE_RENDER]);
-
+   if (fd < 0)
       goto err;
-   }
 
-   bool is_render_and_display_gpu_diff = !!strcmp(default_tag, prime.str);
+   bool is_render_and_display_gpu_diff = !!strcmp(default_tag, prime);
    if (original_fd) {
       if (is_render_and_display_gpu_diff) {
          *original_fd = *fd_render_gpu;
@@ -573,13 +402,11 @@ bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
    }
 
    free(default_tag);
-   free(prime.str);
+   free(prime);
    return is_render_and_display_gpu_diff;
  err:
-   log_(debug ? _LOADER_WARNING : _LOADER_INFO,
-        "DRI_PRIME: error. Using the default GPU\n");
    free(default_tag);
-   free(prime.str);
+   free(prime);
  no_prime_gpu_offloading:
    if (original_fd)
       *original_fd = *fd_render_gpu;
@@ -676,7 +503,7 @@ loader_get_pci_driver(int fd)
       if (vendor_id != driver_map[i].vendor_id)
          continue;
 
-      if (driver_map[i].predicate && !driver_map[i].predicate(fd, driver_map[i].driver))
+      if (driver_map[i].predicate && !driver_map[i].predicate(fd))
          continue;
 
       if (driver_map[i].num_chips_ids == -1) {
@@ -708,7 +535,7 @@ loader_get_driver_for_fd(int fd)
     * user's problem, but this allows vc4 simulator to run on an i965 host,
     * and may be useful for some touch testing of i915 on an i965 host.
     */
-   if (__normal_user()) {
+   if (geteuid() == getuid()) {
       const char *override = os_get_option("MESA_LOADER_DRIVER_OVERRIDE");
       if (override)
          return strdup(override);
@@ -813,7 +640,7 @@ loader_open_driver_lib(const char *driver_name,
    const char *search_paths, *next, *end;
 
    search_paths = NULL;
-   if (__normal_user() && search_path_vars) {
+   if (geteuid() == getuid() && search_path_vars) {
       for (int i = 0; search_path_vars[i] != NULL; i++) {
          search_paths = getenv(search_path_vars[i]);
          if (search_paths)
@@ -900,6 +727,8 @@ loader_open_driver(const char *driver_name,
       free(get_extensions_name);
    }
 
+   if (!extensions)
+      extensions = dlsym(driver, __DRI_DRIVER_EXTENSIONS);
    if (extensions == NULL) {
       log_(_LOADER_WARNING,
            "MESA-LOADER: driver exports no extensions (%s)\n", dlerror());
diff --git a/src/loader/loader.h b/src/loader/loader.h
index 8cbfb1afc00..2480b62d4f3 100644
--- a/src/loader/loader.h
+++ b/src/loader/loader.h
@@ -43,15 +43,8 @@ struct __DRIextensionRec;
 int
 loader_open_device(const char *);
 
-char *
-loader_get_kernel_driver_name(int fd);
-
 int
-loader_open_render_node_platform_device(const char * const drivers[],
-                                        unsigned int n_drivers);
-
-bool
-loader_is_device_render_capable(int fd);
+loader_open_render_node(const char *name);
 
 char *
 loader_get_render_node(dev_t device);
diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index dc1db4fa8be..32135770e9d 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -463,6 +463,13 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->vtable->set_drawable_size(draw, draw->width, draw->height);
    free(reply);
 
+   draw->swap_method = __DRI_ATTRIB_SWAP_UNDEFINED;
+   if (draw->ext->core->base.version >= 2) {
+      (void )draw->ext->core->getConfigAttrib(dri_config,
+                                              __DRI_ATTRIB_SWAP_METHOD,
+                                              &draw->swap_method);
+   }
+
    /*
     * Make sure server has the same swap interval we do for the new
     * drawable.
@@ -1063,7 +1070,7 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
     * The force_copy parameter is used by EGL to attempt to preserve
     * the back buffer across a call to this function.
     */
-   if (force_copy)
+   if (draw->swap_method != __DRI_ATTRIB_SWAP_UNDEFINED || force_copy)
       draw->cur_blit_source = LOADER_DRI3_BACK_ID(draw->cur_back);
 
    /* Exchange the back and fake front. Even though the server knows about these
@@ -1076,7 +1083,7 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
       draw->buffers[LOADER_DRI3_FRONT_ID] = back;
       draw->buffers[LOADER_DRI3_BACK_ID(draw->cur_back)] = tmp;
 
-      if (force_copy)
+      if (draw->swap_method == __DRI_ATTRIB_SWAP_COPY  || force_copy)
          draw->cur_blit_source = LOADER_DRI3_FRONT_ID;
    }
 
@@ -2237,8 +2244,10 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
    }
 
    /* pixmaps always have front buffers.
+    * Exchange swaps also mandate fake front buffers.
     */
-   if (draw->type != LOADER_DRI3_DRAWABLE_WINDOW)
+   if (draw->type != LOADER_DRI3_DRAWABLE_WINDOW ||
+       draw->swap_method == __DRI_ATTRIB_SWAP_EXCHANGE)
       buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;
 
    if (buffer_mask & __DRI_IMAGE_BUFFER_FRONT) {
@@ -2370,6 +2379,7 @@ loader_dri3_close_screen(__DRIscreen *dri_screen)
  * Find a potentially new back buffer, and if it's not been allocated yet and
  * in addition needs initializing, then try to allocate and initialize it.
  */
+#include <stdio.h>
 static struct loader_dri3_buffer *
 dri3_find_back_alloc(struct loader_dri3_drawable *draw)
 {
@@ -2392,7 +2402,7 @@ dri3_find_back_alloc(struct loader_dri3_drawable *draw)
 
    dri3_set_render_buffer(draw, id, back);
 
-   /* If necessary, prefill the back with data. */
+   /* If necessary, prefill the back with data according to swap_method mode. */
    if (draw->cur_blit_source != -1 &&
        draw->buffers[draw->cur_blit_source] &&
        back != draw->buffers[draw->cur_blit_source]) {
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index cc2362dd599..1fd340bd145 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -182,6 +182,7 @@ struct loader_dri3_drawable {
    struct loader_dri3_extensions *ext;
    const struct loader_dri3_vtable *vtable;
 
+   unsigned int swap_method;
    unsigned int back_format;
    xcb_present_complete_mode_t last_present_mode;
 
diff --git a/src/loader/meson.build b/src/loader/meson.build
index 043cc852112..35f9991ba2f 100644
--- a/src/loader/meson.build
+++ b/src/loader/meson.build
@@ -47,6 +47,6 @@ libloader = static_library(
   c_args : loader_c_args,
   gnu_symbol_visibility : 'hidden',
   include_directories : [inc_include, inc_src, inc_util],
-  dependencies : [dep_libdrm, dep_thread, dep_xcb, dep_xcb_xrandr],
+  dependencies : [dep_libdrm, dep_thread, dep_xcb_xrandr],
   build_by_default : false,
 )
diff --git a/src/loader/pci_id_driver_map.h b/src/loader/pci_id_driver_map.h
index b6febe4f53a..2da47a16776 100644
--- a/src/loader/pci_id_driver_map.h
+++ b/src/loader/pci_id_driver_map.h
@@ -44,15 +44,14 @@ static const int vmwgfx_chip_ids[] = {
 #undef CHIPSET
 };
 
-bool iris_predicate(int fd, const char *driver);
-bool nouveau_zink_predicate(int fd, const char *driver);
+bool iris_predicate(int fd);
 
 static const struct {
    int vendor_id;
    const char *driver;
    const int *chip_ids;
    int num_chips_ids;
-   bool (*predicate)(int fd, const char *driver);
+   bool (*predicate)(int fd);
 } driver_map[] = {
    { 0x8086, "i915", i915_chip_ids, ARRAY_SIZE(i915_chip_ids) },
    { 0x8086, "crocus", crocus_chip_ids, ARRAY_SIZE(crocus_chip_ids) },
@@ -60,8 +59,7 @@ static const struct {
    { 0x1002, "r300", r300_chip_ids, ARRAY_SIZE(r300_chip_ids) },
    { 0x1002, "r600", r600_chip_ids, ARRAY_SIZE(r600_chip_ids) },
    { 0x1002, "radeonsi", NULL, -1 },
-   { 0x10de, "nouveau", NULL, -1, nouveau_zink_predicate },
-   { 0x10de, "zink", NULL, -1, nouveau_zink_predicate },
+   { 0x10de, "nouveau", NULL, -1, },
    { 0x1af4, "virtio_gpu", virtio_gpu_chip_ids, ARRAY_SIZE(virtio_gpu_chip_ids) },
    { 0x15ad, "vmwgfx", vmwgfx_chip_ids, ARRAY_SIZE(vmwgfx_chip_ids) },
 };
