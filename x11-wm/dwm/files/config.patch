diff --git a/config.def.h b/config.def.h
index 9efa774..76d8294 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,26 +1,130 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
+#ifdef VANITYGAPS
+static const unsigned int gappih    = 18;       /* horiz inner gap between windows */
+static const unsigned int gappiv    = 18;       /* vert inner gap between windows */
+static const unsigned int gappoh    = 10;       /* horiz outer gap between windows and screen edge */
+static const unsigned int gappov    = 10;       /* vert outer gap between windows and screen edge */
+static const int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
+#endif
+#ifdef PERSONAL
+static const unsigned int borderpx  = 2;        /* border pixel of windows */
+#else
 static const unsigned int borderpx  = 1;        /* border pixel of windows */
+#endif
+#ifdef ROUNDEDCORNERS
+static const int cornerradius 	    = 10;
+#endif
 static const unsigned int snap      = 32;       /* snap pixel */
+#ifdef SYSTRAY
+static const unsigned int systraypinning = 0;   /* 0: sloppy systray follows selected monitor, >0: pin systray to monitor X */
+static const unsigned int systrayspacing = 2;   /* systray spacing */
+static const int systraypinningfailfirst = 1;   /* 1: if pinning fails, display systray on the first monitor, False: display systray on the last monitor*/
+static const int showsystray        = 1;     /* 0 means no systray */
+#endif
+#if defined(PERSONAL) && defined(BARPADDING)
+static const int vertpad            = 10;       /* vertical padding of bar */
+static const int sidepad            = 80;       /* horizontal padding of bar */
+#elif defined(BARPADDING)
+static const int vertpad            = 10;       /* vertical padding of bar */
+static const int sidepad            = 10;       /* horizontal padding of bar */
+#endif
 static const int showbar            = 1;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
+#ifdef PERSONAL
+static const char *fonts[]          = { "Iosevka Nerd Font:size=12:style=heavy" };
+static const char buttonbar[]       = "懶 ";
+#else
 static const char *fonts[]          = { "monospace:size=10" };
 static const char dmenufont[]       = "monospace:size=10";
+#ifdef PERSONAL
+static const char col_gray1[]       = "#222222";
+static const char col_gray2[]       = "#444444";
+static const char col_gray3[]       = "#faebd7";
+static const char col_black[]       = "#000000";
+static const char col_border[]      = "#ff79c6";
+static const char col_cyan[]        = "#005577";
+static const char col_red[]         = "#ff5555";
+static const char col_yellow[]      = "#ffff00";
+static const char col_smthFG[]      = "#f5fffa";
+static const char col_SeparatorBG[] = "#707070";
+static const char col_BGgreen[]     = "#008000";
+static const char col_smth[]        = "#eee5de";
+#else
 static const char col_gray1[]       = "#222222";
 static const char col_gray2[]       = "#444444";
 static const char col_gray3[]       = "#bbbbbb";
 static const char col_gray4[]       = "#eeeeee";
 static const char col_cyan[]        = "#005577";
+#endif
 static const char *colors[][3]      = {
+	/*               			fg         bg         		border   */
+	#ifdef PERSONAL
+	[SchemeNorm] 		=	 { col_gray3,     col_gray1,  		col_black },
+	[SchemeSel]  		=	 { col_black,	  col_border,		col_border },
+	[SchemeWarn]   		=	 { col_black,     col_yellow, 		col_red },
+	[SchemeUrgent]		=	 { col_smthFG, 	  col_red,    		col_red },
+	[SchemeTagUnderline] 	=	 { col_border,    col_border,   	col_border },
+	[SchemeBGgreen] 	=	 { col_gray3,  	  col_BGgreen,		col_gray2 },
+	[SchemeWnameBG] 	=	 { col_border, 	  col_gray1,		col_red },
+	[SchemeBlockSeparator] 	=	 { col_cyan,      col_SeparatorBG,	col_red },
+	[SchemeCmusButton] 	=	 { col_smth,	  col_cyan,		col_red },
+	#else
 	/*               fg         bg         border   */
 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+	#endif
 };
 
 /* tagging */
+//static const char *tags[] = { "", "", "", "", "", "", "", "", "" };
+//static const char *tags[] = { "", "", "", "", "", "", "", "", "" };
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+//static const char *tags[] = { "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" };
 
+#if defined(PERSONAL) && defined(CENTER)
+static const Rule rules[] = {
+	/* xprop(1):
+	 *	WM_CLASS(STRING) = instance, class
+	 *	WM_NAME(STRING) = title
+	 */
+	/* class      		instance    title       tags mask     iscentered	isfloating   monitor */
+	{ "Gimp",     		NULL,       NULL,       0,            1,		1,           -1 },
+	{ "Firefox",  		NULL,       NULL,       1 << 2,       0,		0,           -1 },
+	{ "mpv",      		NULL,       NULL,       0,            1,		1,           -1 },
+	{ "feh",      		NULL,       NULL,       0,            1,		1,           -1 },
+	{ "Sxiv",      		NULL,       NULL,       0,            1,		1,           -1 },
+	{ "Kodi",     		NULL,       NULL,       1 << 7,       0,		0,           -1 },
+	{ "Steam",    		NULL,       NULL,       1 << 4,       1,		0,           -1 },
+	{ "QtCreator",  	NULL,       NULL,       1 << 3,       1,		0,           -1 },
+	{ "KeePassXC",  	NULL,       NULL,       0,            1,		1,           -1 },
+	{ "Galculator",      	NULL,       NULL,       0,            1,		1,           -1 },
+	{ "VirtualBox",      	NULL,       NULL,       0,            1,		0,           -1 },
+	{ "Gcolor2",      	NULL,       NULL,       0,            1,		1,           -1 },
+};
+#elif defined(PERSONAL)
+static const Rule rules[] = {
+	{ "Gimp",     		NULL,       NULL,       0,            1,           -1 },
+	{ "Firefox",  		NULL,       NULL,       1 << 2,       0,           -1 },
+	{ "mpv",      		NULL,       NULL,       0,            1,           -1 },
+	{ "feh",      		NULL,       NULL,       0,            1,           -1 },
+	{ "Sxiv",      		NULL,       NULL,       0,            1,           -1 },
+	{ "Kodi",     		NULL,       NULL,       1 << 7,       0,           -1 },
+	{ "Steam",    		NULL,       NULL,       1 << 4,       1,           -1 },
+	{ "QtCreator",  	NULL,       NULL,       1 << 3,       1,           -1 },
+	{ "KeePassXC",  	NULL,       NULL,       0,            1,           -1 },
+	{ "Galculator",      	NULL,       NULL,       0,            1,           -1 },
+	{ "VirtualBox",      	NULL,       NULL,       0,            1,           -1 },
+	{ "Gcolor2",      	NULL,       NULL,       0,            1,           -1 },
+};
+#elif defined(CENTER) && ! defined(PERSONAL)
+static const Rule rules[] = {
+	/* class      instance    title       tags mask     iscentered   isfloating   monitor */
+	{ "Gimp",     NULL,       NULL,       0,            0,           1,           -1 },
+	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           0,           -1 },
+};
+#else
 static const Rule rules[] = {
 	/* xprop(1):
 	 *	WM_CLASS(STRING) = instance, class
@@ -30,9 +134,14 @@ static const Rule rules[] = {
 	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
 	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
 };
+#endif
 
 /* layout(s) */
+ifdef PERSONAL
+static const float mfact     = 0.50; /* factor of master area size [0.05..0.95] */
+#else
 static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+#endif
 static const int nmaster     = 1;    /* number of clients in master area */
 static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
 static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
@@ -45,7 +154,7 @@ static const Layout layouts[] = {
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
@@ -57,60 +166,118 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray3, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
+#ifdef PERSONAL
+static const char *roficmd[] = { "rofi", "-modi", "drun", "-show", "drun", "-show-icons", NULL };
+static const char *roficmdtasks[] = { "rofi", "-theme", "solarized_alternate", "-i", "-show", "window", NULL };
+static const char *upvol[] = { "audio-change-volume-up", NULL };
+static const char *downvol[] = { "audio-change-volume-down", NULL };
+static const char *kodi[] = { "kodi", NULL };
+static const char *firefox[] = { "firefox", NULL };
+static const char *cmusstart[] = { "cmus-remote", "-p", NULL };
+static const char *cmusstop[] = { "cmus-remote", "-s", NULL };
+static const char *screenshotfull[] = { "TakeScreenshot-Full.sh", NULL };
+static const char *screenshotgrab[] = { "TakeScreenshot-Grab.sh", NULL };
+static const char *reboot[] = { "Reboot-machine.sh", NULL };
+static const char *showDateTimeWeather[] = { "dateTimeWeather.sh", NULL };
+#endif
+
 static const Key keys[] = {
-	/* modifier                     key        function        argument */
-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
-	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
-	{ MODKEY,                       XK_Return, zoom,           {0} },
-	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
-	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
-	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
-	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
-	TAGKEYS(                        XK_1,                      0)
-	TAGKEYS(                        XK_2,                      1)
-	TAGKEYS(                        XK_3,                      2)
-	TAGKEYS(                        XK_4,                      3)
-	TAGKEYS(                        XK_5,                      4)
-	TAGKEYS(                        XK_6,                      5)
-	TAGKEYS(                        XK_7,                      6)
-	TAGKEYS(                        XK_8,                      7)
-	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	/* modifier                     key        	function        argument */
+	#ifdef PERSONAL
+	{ MODKEY,                       XK_F2,     	spawn,          {.v = roficmd } },
+	{ MODKEY,                       XK_F3,     	spawn,          {.v = roficmdtasks } },
+	{ MODKEY,                       XK_F4,     	spawn,          {.v = dmenucmd } },
+	{ MODKEY,                       XK_F5,     	spawn,          SHCMD("dmenuunicode") },
+	{ 0,              XF86XK_AudioRaiseVolume, 	spawn,          {.v = upvol } },
+        { 0,              XF86XK_AudioLowerVolume, 	spawn,          {.v = downvol } },
+	{ 0,              XF86XK_Forward,  		spawn,          {.v = cmusstop } },
+	{ 0,              XF86XK_Back,       		spawn,   	{.v = cmusstart } },
+	{ 0,              XF86XK_Calculator, 		spawn,          {.v = downvol } },
+        { 0,              XF86XK_Sleep, 		spawn,          {.v = upvol } },
+	{ 0,              XF86XK_AudioMedia,       	spawn,          {.v = kodi } },
+	{ 0,              XF86XK_Mail,             	spawn,          {.v = showDateTimeWeather } },
+	{ 0,              XF86XK_HomePage,         	spawn,          {.v = firefox } },
+	{ 0,              XF86XK_MyComputer,         	fullscreenmode, {0} },
+	{ 0,              XF86XK_AudioRecord,         	fullscreenmode, {0} },
+	{ 0,                            XK_Print,  	spawn,          {.v = screenshotfull } },
+	{ MODKEY,                       XK_Print,  	spawn,          {.v = screenshotgrab } },
+	{ MODKEY|ControlMask|ShiftMask, XK_r,      	spawn,          {.v = reboot } },
+	#else
+	{ MODKEY,                       XK_p,      	spawn,          {.v = dmenucmd } },
+	#endif
+	{ MODKEY,             		XK_Return, 	spawn,          {.v = termcmd } },
+	{ MODKEY,                       XK_b,      	togglebar,      {0} },
+	{ MODKEY,                       XK_j,      	focusstack,     {.i = +1 } },
+	{ MODKEY,                       XK_k,      	focusstack,     {.i = -1 } },
+	{ MODKEY,                       XK_i,      	incnmaster,     {.i = +1 } },
+	{ MODKEY,                       XK_d,      	incnmaster,     {.i = -1 } },
+	{ MODKEY,                       XK_h,      	setmfact,       {.f = -0.05} },
+	{ MODKEY,                       XK_l,      	setmfact,       {.f = +0.05} },
+	#ifdef VANITYGAPS
+	{ MODKEY|Mod4Mask,              XK_h,      	incrgaps,       {.i = +1 } },
+	{ MODKEY|Mod4Mask,              XK_l,      	incrgaps,       {.i = -1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_h,      	incrogaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_l,      	incrogaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask|ControlMask,  XK_h,      	incrigaps,      {.i = +1 } },
+	{ MODKEY|Mod4Mask|ControlMask,  XK_l,      	incrigaps,      {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_0,      	togglegaps,     {0} },
+	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      	defaultgaps,    {0} },
+	{ MODKEY,                       XK_y,      	incrihgaps,     {.i = +1 } },
+	{ MODKEY,                       XK_o,      	incrihgaps,     {.i = -1 } },
+	{ MODKEY|ControlMask,           XK_y,      	incrivgaps,     {.i = +1 } },
+	{ MODKEY|ControlMask,           XK_o,      	incrivgaps,     {.i = -1 } },
+	{ MODKEY|Mod4Mask,              XK_y,      	incrohgaps,     {.i = +1 } },
+	{ MODKEY|Mod4Mask,              XK_o,      	incrohgaps,     {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_y,      	incrovgaps,     {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_o,      	incrovgaps,     {.i = -1 } },
+	#endif
+	{ MODKEY,                       XK_space,  	zoom,           {0} },
+	{ MODKEY,                       XK_Tab,    	view,           {0} },
+	{ MODKEY,             		XK_q,      	killclient,     {0} },
+	{ MODKEY,                       XK_t,      	setlayout,      {.v = &layouts[0]} },
+	{ MODKEY,                       XK_f,      	setlayout,      {.v = &layouts[1]} },
+	{ MODKEY,                       XK_m,      	setlayout,      {.v = &layouts[2]} },
+	{ MODKEY|ShiftMask,             XK_Return, 	setlayout,      {0} },
+	{ MODKEY|ShiftMask,             XK_space,  	togglefloating, {0} },
+	{ MODKEY,                       XK_comma,  	focusmon,       {.i = -1 } },
+	{ MODKEY,                       XK_period, 	focusmon,       {.i = +1 } },
+	{ MODKEY|ShiftMask,             XK_comma,  	tagmon,         {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_period, 	tagmon,         {.i = +1 } },
+	TAGKEYS(                        XK_1,                      	0)
+	TAGKEYS(                        XK_2,                      	1)
+	TAGKEYS(                        XK_3,                      	2)
+	TAGKEYS(                        XK_4,                      	3)
+	TAGKEYS(                        XK_5,                      	4)
+	TAGKEYS(                        XK_6,                      	5)
+	TAGKEYS(                        XK_7,                      	6)
+	TAGKEYS(                        XK_8,                      	7)
+	TAGKEYS(                        XK_9,                      	8)
+	#ifdef RESTARTSIG
+	{ MODKEY|ControlMask|ShiftMask, XK_q,           quit,           {0} }, // QUIT TO TTY
+	{ MODKEY|ControlMask|ShiftMask, XK_F5,      	quit,           {1} }, // RESTART DWM
+	#else
+	{ MODKEY|ShiftMask,             XK_q,      	quit,           {0} },
+	#endif
 };
 
 /* button definitions */
 /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
 static const Button buttons[] = {
 	/* click                event mask      button          function        argument */
+	#ifdef PERSONAL
+	{ ClkCmusButton,	0,		Button1,	spawn,		{.v = cmusstart } },
+	{ ClkCmusButton,	0,		Button3,	spawn,		{.v = cmusstop } },
+	#else
 	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
 	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+	#endif
 	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
 	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
 	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
 	{ ClkTagBar,            0,              Button1,        view,           {0} },
-	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
 	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
 };
 
diff --git a/config.mk b/config.mk
index 9746634..a1b6d95 100644
--- a/config.mk
+++ b/config.mk
@@ -14,6 +14,8 @@ X11LIB = /usr/lib64/X11
 XINERAMALIBS  = -lXinerama
 XINERAMAFLAGS = -DXINERAMA
 
+ROUNDEDCORNERSLIBS = -lxcb -lxcb-shape
+
 # freetype
 FREETYPELIBS = -lfontconfig -lXft
 FREETYPEINC = /usr/include/freetype2
@@ -21,12 +23,27 @@ FREETYPEINC = /usr/include/freetype2
 #FREETYPEINC = ${X11INC}/freetype2
 #MANPREFIX = ${PREFIX}/man
 
+ATTACHASIDEFLAGS = -DATTACHASIDE
+BARPADDINGFLAGS = -DBARPADDING
+CENTERFLAGS = -DCENTER
+ALPHABORDERFLAGS = -DALPHABORDER
+PERTAGFLAGS = -DPERTAG
+EMOJISFLAGS = -DEMOJIS
+SYSTRAYFLAGS = -DSYSTRAY
+PERSONALFLAGS = -DPERSONAL
+VANITYGAPSFLAGS = -DVANITYGAPS
+RESTARTSIGFLAGS = -DRESTARTSIG
+HIDEVACANTTAGSFLAGS =
+ROUNDEDCORNERSFLAGS = -DROUNDEDCORNERS
+
 # includes and libs
 INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
++LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS} ${ROUNDEDCORNERSLIBS}
 
 # flags
-CPPFLAGS += -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
+CPPFLAGS += -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS} ${ATTACHASIDEFLAGS} \
+	    ${CENTERFLAGS} ${ALPHABORDERFLAGS} ${PERTAGFLAGS} ${SYSTRAYFLAGS} ${PERSONALFLAGS} ${VANITYGAPSFLAGS} ${RESTARTSIGFLAGS} \
+	    ${HIDEVACANTTAGSFLAGS} ${ROUNDEDCORNERSFLAGS} ${BARPADDINGFLAGS} ${EMOJISFLAGS}
 #CFLAGS   = -g -std=c99 -pedantic -Wall -O0 ${INCS} ${CPPFLAGS}
 CFLAGS   += -std=c99 -pedantic -Wall -Wno-deprecated-declarations ${INCS} ${CPPFLAGS}
 LDFLAGS  += ${LIBS}
diff --git a/drw.c b/drw.c
index a58a2b4..6b77289 100644
--- a/drw.c
+++ b/drw.c
@@ -190,6 +190,10 @@ drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
 	                       DefaultColormap(drw->dpy, drw->screen),
 	                       clrname, dest))
 		die("error, cannot allocate color '%s'", clrname);
+
+	#ifdef ALPHABORDER
+	dest->pixel |= 0xff << 24;
+	#endif
 }
 
 /* Wrapper to create color schemes. The caller has to call free(3) on the
@@ -223,6 +227,54 @@ drw_setscheme(Drw *drw, Clr *scm)
 		drw->scheme = scm;
 }
 
+#ifdef PERSONAL
+int
+drw_get_width(Drw *drw, int numcolors, const char *text)
+{
+	int i;
+	Fnt *curfont = drw->fonts;
+	int w = drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+	unsigned int ew = 0;
+
+	drw_font_getexts(curfont, "\x01", 1,  &ew, NULL);
+
+	for (i = 0; i < strlen(text); i++) {
+		if (text[i] > 0 && text[i] <= numcolors) {
+			/* we found a color code
+			 * drw_text counted it as a normal character and added one character's width
+			 * we aren't going to render this character, so we remove one character's width */
+			w -= ew;
+
+		}
+	}
+	return w;
+}
+
+void
+drw_colored_text(Drw *drw, Clr **scheme, int numcolors, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, char *text)
+{
+	if (!drw || !drw->fonts || !drw->scheme)
+		return;
+
+	char *buf = text, *ptr = buf, c = 1;
+	int i;
+
+	while (*ptr) {
+		for (i = 0; *ptr < 0 || *ptr > numcolors; i++, ptr++);
+		if (!*ptr)
+			break;
+		c = *ptr;
+		*ptr = 0;
+		if (i)
+			x = drw_text(drw, x, y, w, h, lpad, buf, 0);
+		*ptr = c;
+		drw_setscheme(drw, scheme[c-1]);
+		buf = ++ptr;
+	}
+	drw_text(drw, x, y, w, h, lpad, buf, 0);
+}
+#endif
+
 void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
 {
@@ -239,7 +291,7 @@ int
 drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
 {
 	int i, ty, ellipsis_x = 0;
-	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len;
+	unsigned int tmpw, ew = 0, ellipsis_w = 0, ellipsis_len;
 	XftDraw *d = NULL;
 	Fnt *usedfont, *curfont, *nextfont;
 	int utf8strlen, utf8charlen, render = x || y || w || h;
@@ -381,7 +433,11 @@ no_match:
 	if (d)
 		XftDrawDestroy(d);
 
+	#ifdef PERSONAL
+	return x;
+	#else
 	return x + (render ? w : 0);
+	#endif
 }
 
 void
diff --git a/drw.h b/drw.h
index 6471431..d1afbab 100644
--- a/drw.h
+++ b/drw.h
@@ -51,6 +51,10 @@ void drw_setfontset(Drw *drw, Fnt *set);
 void drw_setscheme(Drw *drw, Clr *scm);
 
 /* Drawing functions */
+#ifdef PERSONAL
+int drw_get_width(Drw *drw, int numcolors, const char *text);
+void drw_colored_text(Drw *drw, Clr **scheme, int numcolors, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, char *text);
+#endif
 void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
 int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
 
diff --git a/dwm.c b/dwm.c
index f1d86b2..f3e8a1f 100644
--- a/dwm.c
+++ b/dwm.c
@@ -41,6 +41,11 @@
 #endif /* XINERAMA */
 #include <X11/Xft/Xft.h>
 
+#ifdef ROUNDEDCORNERS
+#include <xcb/xcb.h>
+#include <xcb/shape.h>
+#endif
+
 #include "drw.h"
 #include "util.h"
 
@@ -49,7 +54,12 @@
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+#ifdef ATTACHASIDE
+#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
+#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
+#else
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#endif
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
@@ -57,14 +67,46 @@
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
 
+#ifdef SYSTRAY
+#define SYSTEM_TRAY_REQUEST_DOCK    0
+
+/* XEMBED messages */
+#define XEMBED_EMBEDDED_NOTIFY      0
+#define XEMBED_WINDOW_ACTIVATE      1
+#define XEMBED_FOCUS_IN             4
+#define XEMBED_MODALITY_ON         10
+
+#define XEMBED_MAPPED              (1 << 0)
+#define XEMBED_WINDOW_ACTIVATE      1
+#define XEMBED_WINDOW_DEACTIVATE    2
+
+#define VERSION_MAJOR               0
+#define VERSION_MINOR               0
+#define XEMBED_EMBEDDED_VERSION (VERSION_MAJOR << 16) | VERSION_MINOR
+#endif
+
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+#ifdef PERSONAL
+enum { SchemeNorm, SchemeSel, SchemeWarn, SchemeUrgent, SchemeTagUnderline, SchemeBGgreen, SchemeWnameBG, SchemeBlockSeparator, SchemeCmusButton }; /* color schemes */
+#else
 enum { SchemeNorm, SchemeSel }; /* color schemes */
+#endif
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+#ifdef SYSTRAY
+NetSystemTray, NetSystemTrayOP, NetSystemTrayOrientation, NetSystemTrayOrientationHorz,
+#endif
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+#ifdef SYSTRAY
+enum { Manager, Xembed, XembedInfo, XLast }; /* Xembed atoms */
+#endif
 enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+#ifdef PERSONAL
+enum { ClkTagBar, ClkCmusButton, ClkStatusText, ClkWinTitle,
+#else
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+#endif
        ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
 
 typedef union {
@@ -92,7 +134,11 @@ struct Client {
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
 	int bw, oldbw;
 	unsigned int tags;
+	#ifdef CENTER
+	int isfixed, iscentered, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	#else
 	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+	#endif
 	Client *next;
 	Client *snext;
 	Monitor *mon;
@@ -111,6 +157,10 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+#ifdef PERTAG
+typedef struct Pertag Pertag;
+#endif
+
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
@@ -119,6 +169,12 @@ struct Monitor {
 	int by;               /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
+	#ifdef VANITYGAPS
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
+	#endif
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -130,6 +186,9 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+	#ifdef PERTAG
+	Pertag *pertag;
+	#endif
 };
 
 typedef struct {
@@ -137,16 +196,31 @@ typedef struct {
 	const char *instance;
 	const char *title;
 	unsigned int tags;
+	#ifdef CENTER
+	int iscentered;
+	#endif
 	int isfloating;
 	int monitor;
 } Rule;
 
+#ifdef SYSTRAY
+typedef struct Systray   Systray;
+struct Systray {
+	Window win;
+	Client *icons;
+};
+#endif
+
 /* function declarations */
 static void applyrules(Client *c);
 static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
+#ifdef ATTACHASIDE
+static void attachaside(Client *c);
+static Client *nexttagged(Client *c);
+#endif
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -195,21 +269,56 @@ static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
 static void scan(void);
+#ifdef SYSTRAY
+static Atom getatomprop(Client *c, Atom prop);
+static unsigned int getsystraywidth();
+static void removesystrayicon(Client *i);
+static void resizebarwin(Monitor *m);
+static void resizerequest(XEvent *e);
+static Monitor *systraytomon(Monitor *m);
+static void updatesystray(void);
+static void updatesystrayicongeom(Client *i, int w, int h);
+static void updatesystrayiconstate(Client *i, XPropertyEvent *ev);
+static Client *wintosystrayicon(Window w);
+#endif
+#ifdef SYSTRAY
+static int sendevent(Window w, Atom proto, int m, long d0, long d1, long d2, long d3, long d4);
+#else
 static int sendevent(Client *c, Atom proto);
+#endif
 static void sendmon(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
+#ifdef VANITYGAPS
+static void setgaps(int oh, int ov, int ih, int iv);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void defaultgaps(const Arg *arg);
+#endif
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
 static void showhide(Client *c);
+#ifdef RESTARTSIG
+static void sighup(int unused);
+static void sigterm(int unused);
+#endif
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglebar(const Arg *arg);
+#ifdef PERSONAL
+static void fullscreenmode(const Arg *arg);
+#endif
 static void togglefloating(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
@@ -233,14 +342,27 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+#ifdef ROUNDEDCORNERS
+static void roundcorners(Client* c, const unsigned int fs);
+#endif
 
 /* variables */
+#ifdef SYSTRAY
+static Systray *systray =  NULL;
+#endif
 static const char broken[] = "broken";
 static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh;               /* bar height */
+#ifdef VANITYGAPS
+static int enablegaps = 1;   /* enables gaps, used by togglegaps */
+#endif
 static int lrpad;            /* sum of left and right padding for text */
+#ifdef BARPADDING
+static int vp;               /* vertical padding for bar */
+static int sp;               /* side padding for bar */
+#endif
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
@@ -257,9 +379,19 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[MapRequest] = maprequest,
 	[MotionNotify] = motionnotify,
 	[PropertyNotify] = propertynotify,
+	#ifdef SYSTRAY
+	[ResizeRequest] = resizerequest,
+	#endif
 	[UnmapNotify] = unmapnotify
 };
+#ifdef SYSTRAY
+static Atom wmatom[WMLast], netatom[NetLast], xatom[XLast];
+#else
 static Atom wmatom[WMLast], netatom[NetLast];
+#endif
+#ifdef RESTARTSIG
+static int restart = 0;
+#endif
 static int running = 1;
 static Cur *cursor[CurLast];
 static Clr **scheme;
@@ -271,6 +403,22 @@ static Window root, wmcheckwin;
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+#ifdef SYSTRAY
+static Atom getatomprop(Client *c, Atom prop);
+static unsigned int getsystraywidth();
+static void removesystrayicon(Client *i);
+static void resizebarwin(Monitor *m);
+static void resizerequest(XEvent *e);
+static Monitor *systraytomon(Monitor *m);
+static void updatesystray(void);
+static void updatesystrayicongeom(Client *i, int w, int h);
+static void updatesystrayiconstate(Client *i, XPropertyEvent *ev);
+static Client *wintosystrayicon(Window w);
+#endif
+#ifdef SYSTRAY
+static int sendevent(Window w, Atom proto, int m, long d0, long d1, long d2, long d3, long d4);
+#else
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -285,6 +433,9 @@ applyrules(Client *c)
 	XClassHint ch = { NULL, NULL };
 
 	/* rule matching */
+	#ifdef CENTER
+	c->iscentered = 0;
+	#endif
 	c->isfloating = 0;
 	c->tags = 0;
 	XGetClassHint(dpy, c->win, &ch);
@@ -297,6 +448,9 @@ applyrules(Client *c)
 		&& (!r->class || strstr(class, r->class))
 		&& (!r->instance || strstr(instance, r->instance)))
 		{
+			#ifdef CENTER
+			c->iscentered = r->iscentered;
+			#endif
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
 			for (m = mons; m && m->num != r->monitor; m = m->next);
@@ -396,7 +550,7 @@ arrange(Monitor *m)
 void
 arrangemon(Monitor *m)
 {
-	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof(m->ltsymbol) - 1);
 	if (m->lt[m->sellt]->arrange)
 		m->lt[m->sellt]->arrange(m);
 }
@@ -408,6 +562,19 @@ attach(Client *c)
 	c->mon->clients = c;
 }
 
+#ifdef ATTACHASIDE
+void
+attachaside(Client *c) {
+	Client *at = nexttagged(c);
+	if(!at) {
+		attach(c);
+		return;
+		}
+	c->next = at->next;
+	at->next = c;
+}
+#endif
+
 void
 attachstack(Client *c)
 {
@@ -418,7 +585,11 @@ attachstack(Client *c)
 void
 buttonpress(XEvent *e)
 {
+	#ifdef HIDEVACANTTAGS
+	unsigned int i, x, click, occ = 0;
+	#else
 	unsigned int i, x, click;
+	#endif
 	Arg arg = {0};
 	Client *c;
 	Monitor *m;
@@ -433,16 +604,37 @@ buttonpress(XEvent *e)
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
+		#if ! defined(HIDEVACANTTAGS)
 		do
+		#endif
+		#if defined(HIDEVACANTTAGS)
+		for (c = m->clients; c; c = c->next)
+			occ |= c->tags == 255 ? 0 : c->tags;
+		do {
+			/* do not reserve space for vacant tags */
+			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+				continue;
+			x += TEXTW(tags[i]);	
+		} while (ev->x >= x && ++i < LENGTH(tags));
+		#else
 			x += TEXTW(tags[i]);
 		while (ev->x >= x && ++i < LENGTH(tags));
+		#endif
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+			#ifdef PERSONAL
+			click = ClkCmusButton;
+			#else
 			click = ClkLtSymbol;
+			#endif
+		#ifdef SYSTRAY
+		else if (ev->x > selmon->ww - TEXTW(stext) - getsystraywidth())
+		#else
 		else if (ev->x > selmon->ww - (int)TEXTW(stext))
 			click = ClkStatusText;
+		#endif
 		else
 			click = ClkWinTitle;
 	} else if ((c = wintoclient(ev->window))) {
@@ -484,6 +676,13 @@ cleanup(void)
 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
 	while (mons)
 		cleanupmon(mons);
+	#ifdef SYSTRAY
+	if (showsystray) {
+		XUnmapWindow(dpy, systray->win);
+		XDestroyWindow(dpy, systray->win);
+		free(systray);
+	}
+	#endif
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
 	for (i = 0; i < LENGTH(colors); i++)
@@ -515,9 +714,57 @@ cleanupmon(Monitor *mon)
 void
 clientmessage(XEvent *e)
 {
+	#ifdef SYSTRAY
+	XWindowAttributes wa;
+	XSetWindowAttributes swa;
+	#endif
 	XClientMessageEvent *cme = &e->xclient;
 	Client *c = wintoclient(cme->window);
 
+	#ifdef SYSTRAY
+	if (showsystray && cme->window == systray->win && cme->message_type == netatom[NetSystemTrayOP]) {
+		/* add systray icons */
+		if (cme->data.l[1] == SYSTEM_TRAY_REQUEST_DOCK) {
+			if (!(c = (Client *)calloc(1, sizeof(Client))))
+				die("fatal: could not malloc() %u bytes\n", sizeof(Client));
+			if (!(c->win = cme->data.l[2])) {
+				free(c);
+			return;
+			}
+			c->mon = selmon;
+			c->next = systray->icons;
+			systray->icons = c;
+			XGetWindowAttributes(dpy, c->win, &wa);
+			c->x = c->oldx = c->y = c->oldy = 0;
+			c->w = c->oldw = wa.width;
+			c->h = c->oldh = wa.height;
+			c->oldbw = wa.border_width;
+			c->bw = 0;
+			c->isfloating = True;
+			/* reuse tags field as mapped status */
+			c->tags = 1;
+			updatesizehints(c);
+			updatesystrayicongeom(c, wa.width, wa.height);
+			XAddToSaveSet(dpy, c->win);
+			XSelectInput(dpy, c->win, StructureNotifyMask | PropertyChangeMask | ResizeRedirectMask);
+			XReparentWindow(dpy, c->win, systray->win, 0, 0);
+			/* use parents background color */
+			swa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
+			XChangeWindowAttributes(dpy, c->win, CWBackPixel, &swa);
+			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_EMBEDDED_NOTIFY, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
+			/* FIXME not sure if I have to send these events, too */
+			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_FOCUS_IN, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
+			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
+			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_MODALITY_ON, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
+			XSync(dpy, False);
+			resizebarwin(selmon);
+			updatesystray();
+			setclientstate(c, NormalState);
+		}
+		return;
+	}
+	#endif
+
 	if (!c)
 		return;
 	if (cme->message_type == netatom[NetWMState]) {
@@ -570,7 +817,13 @@ configurenotify(XEvent *e)
 				for (c = m->clients; c; c = c->next)
 					if (c->isfullscreen)
 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+				#if defined(SYSTRAY) && defined(BARPADDING)
+				resizebarwin(m);
+				#elif defined(BARPADDING) && ! defined(SYSTRAY)
+				XMoveResizeWindow(dpy, m->barwin, m->wx + sp, m->by + vp, m->ww -  2 * sp, bh);
+				#else
 				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+				#endif
 			}
 			focus(NULL);
 			arrange(NULL);
@@ -634,6 +887,9 @@ Monitor *
 createmon(void)
 {
 	Monitor *m;
+	#ifdef PERTAG
+	unsigned int i;
+	#endif
 
 	m = ecalloc(1, sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
@@ -641,9 +897,30 @@ createmon(void)
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	#ifdef VANITYGAPS
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
+	#endif
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	#ifdef PERTAG
+	m->pertag = ecalloc(1, sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+
+	for (i = 0; i <= LENGTH(tags); i++) {
+		m->pertag->nmasters[i] = m->nmaster;
+		m->pertag->mfacts[i] = m->mfact;
+
+		m->pertag->ltidxs[i][0] = m->lt[0];
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+
+		m->pertag->showbars[i] = m->showbar;
+	}
+	#endif
 	return m;
 }
 
@@ -655,6 +932,13 @@ destroynotify(XEvent *e)
 
 	if ((c = wintoclient(ev->window)))
 		unmanage(c, 1);
+	#ifdef SYSTRAY
+	else if ((c = wintosystrayicon(ev->window))) {
+		removesystrayicon(c);
+		resizebarwin(selmon);
+		updatesystray();
+	}
+	#endif
 }
 
 void
@@ -698,54 +982,135 @@ dirtomon(int dir)
 void
 drawbar(Monitor *m)
 {
-	int x, w, tw = 0;
+	#ifdef SYSTRAY
+	int x, w, sw = 0, stw = 0;
+	#else
+	int x, w, sw = 0;
+	#endif
 	int boxs = drw->fonts->h / 9;
 	int boxw = drw->fonts->h / 6 + 2;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
+	#ifdef SYSTRAY
+	if(showsystray && m == systraytomon(m))
+		stw = getsystraywidth();
+	#endif
+
 	if (!m->showbar)
 		return;
 
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
+		#if defined(PERSONAL) && defined(SYSTRAY) && defined(BARPADDING)
+		sw = drw_get_width(drw, LENGTH(colors), stext);
+		drw_colored_text(drw, scheme, LENGTH(colors), m->ww - sw - stw - 2 * sp, 0, sw, bh, 0, stext);
+		#elif defined(PERSONAL) && defined(SYSTRAY)
+		sw = drw_get_width(drw, LENGTH(colors), stext);
+		drw_colored_text(drw, scheme, LENGTH(colors), m->ww - sw - stw, 0, sw, bh, 0, stext);
+		#elif defined(PERSONAL)
+		sw = drw_get_width(drw, LENGTH(colors), stext);
+		drw_colored_text(drw, scheme, LENGTH(colors), m->ww - sw - 0, 0, sw, bh, 0, stext);
+		#elif defined(SYSTRAY)
+		sw = TEXTW(stext) - lrpad / 2 + 2; /* 2px right padding */
+		drw_text(drw, m->ww - sw - stw, 0, sw, bh, lrpad / 2 - 2, stext, 0);
+		#elif defined(BARPADDING)
+		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+		drw_text(drw, m->ww - sw - 2 * sp, 0, sw, bh, 0, stext, 0);
+		#else
 		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
 		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+		#endif
 	}
 
+	#ifdef SYSTRAY
+	resizebarwin(m);
+	#endif
 	for (c = m->clients; c; c = c->next) {
+		#ifdef HIDEVACANTTAGS
+		occ |= c->tags == 255 ? 0 : c->tags;
+		#else
 		occ |= c->tags;
+		#endif
 		if (c->isurgent)
 			urg |= c->tags;
 	}
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
+		#if defined(HIDEVACANTTAGS)
+		/* do not draw vacant tags */
+		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+		continue;
+		#endif
 		w = TEXTW(tags[i]);
+		#ifdef PERSONAL
+		drw_setscheme(drw, scheme[(m->tagset[m->seltags] & 1 << i) ? SchemeSel : (urg & 1 << i ? SchemeUrgent : SchemeNorm)]);
+		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], 0);
+		#else
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-				urg & 1 << i);
+		#endif
+		#if defined(PERSONAL) && ! defined(HIDEVACANTTAGS)   // Active TAG indicators
+		{
+			if (occ & 1 << i) {
+				drw_setscheme(drw, scheme[SchemeTagUnderline]);
+				drw_rect(drw, x + boxw + 4, 0, w - ( 2 * boxw) - 8, boxw - 2, 1, 0);
+				drw_rect(drw, x + boxw + 4, 19, w - ( 2 * boxw) - 8, boxw - 2, 1, 0);
+			}
+		}
+		#elif defined(PERSONAL) && defined(HIDEVACANTTAGS)
+		// NOP
+		#elif defined(HIDEVACANTTAGS)
+		// NOP
+		#else
+			if (occ & 1 << i)
+				drw_rect(drw, x + boxs, boxs, boxw, boxw, m == selmon && selmon->sel && selmon->sel->tags & 1 << i, urg & 1 << i);
+		#endif
 		x += w;
 	}
+	#ifdef PERSONAL
+	w = blw = TEXTW(buttonbar);
+	drw_setscheme(drw, scheme[SchemeCmusButton]);
+	x = drw_text(drw, x, 0, w, bh, lrpad / 2, buttonbar, 0);
+	#else
 	w = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, scheme[SchemeNorm]);
 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+	#endif
 
+	#ifdef SYSTRAY
+	if ((w = m->ww - sw - stw - x) > bh) {
+	#else
 	if ((w = m->ww - tw - x) > bh) {
+	#endif
 		if (m->sel) {
+			#ifdef PERSONAL
+			drw_setscheme(drw, scheme[SchemeWnameBG]); // set Window name BG color as black
+			#else
 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+			#endif
+			#ifdef BARPADDING
+			drw_text(drw, x, 0, w - 2 * sp, bh, lrpad / 2, m->sel->name, 0);
+			#else
 			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+			#endif
 			if (m->sel->isfloating)
 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
 		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
+			#ifdef BARPADDING
+			drw_rect(drw, x, 0, w - 2 * sp, bh, 1, 1);
+			#else
 			drw_rect(drw, x, 0, w, bh, 1, 1);
+			#endif
 		}
 	}
+	#ifdef SYSTRAY
+	drw_map(drw, m->barwin, 0, 0, m->ww - stw, bh);
+	#else
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+	#endif
 }
 
 void
@@ -782,8 +1147,17 @@ expose(XEvent *e)
 	Monitor *m;
 	XExposeEvent *ev = &e->xexpose;
 
+	#ifdef SYSTRAY
+	if (ev->count == 0 && (m = wintomon(ev->window))) {
+ 		drawbar(m);
+		if (m == selmon)
+			updatesystray();
+	}
+	#else
+
 	if (ev->count == 0 && (m = wintomon(ev->window)))
 		drawbar(m);
+	#endif
 }
 
 void
@@ -869,9 +1243,25 @@ getatomprop(Client *c, Atom prop)
 	unsigned char *p = NULL;
 	Atom da, atom = None;
 
+	#ifdef SYSTRAY
+	/* FIXME getatomprop should return the number of items and a pointer to
+	 * the stored data instead of this workaround */
+	Atom req = XA_ATOM;
+	if (prop == xatom[XembedInfo])
+		req = xatom[XembedInfo];
+	#endif
+
+	#ifdef SYSTRAY
+	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, req,
+	#else
 	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
+	#endif
 		&da, &di, &dl, &dl, &p) == Success && p) {
 		atom = *(Atom *)p;
+		#ifdef SYSTRAY
+		if (da == xatom[XembedInfo] && dl == 2)
+			atom = ((Atom *)p)[1];
+		#endif
 		XFree(p);
 	}
 	return atom;
@@ -905,6 +1295,18 @@ getstate(Window w)
 	return result;
 }
 
+#ifdef SYSTRAY
+unsigned int
+getsystraywidth()
+{
+	unsigned int w = 0;
+	Client *i;
+	if(showsystray)
+		for(i = systray->icons; i; w += i->w + systrayspacing, i = i->next) ;
+	return w ? w + systrayspacing : 1;
+}
+#endif
+
 int
 gettextprop(Window w, Atom atom, char *text, unsigned int size)
 {
@@ -980,7 +1382,11 @@ grabkeys(void)
 void
 incnmaster(const Arg *arg)
 {
+	#ifdef PERTAG
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+	#else
 	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	#endif
 	arrange(selmon);
 }
 
@@ -1017,7 +1423,11 @@ killclient(const Arg *arg)
 {
 	if (!selmon->sel)
 		return;
+	#ifdef SYSTRAY
+	if (!sendevent(selmon->sel->win, wmatom[WMDelete], NoEventMask, wmatom[WMDelete], CurrentTime, 0 , 0, 0)) {
+	#else
 	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
+	#endif
 		XGrabServer(dpy);
 		XSetErrorHandler(xerrordummy);
 		XSetCloseDownMode(dpy, DestroyAll);
@@ -1068,13 +1478,23 @@ manage(Window w, XWindowAttributes *wa)
 	updatewindowtype(c);
 	updatesizehints(c);
 	updatewmhints(c);
+	#ifdef CENTER
+	if (c->iscentered) {
+		c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+		c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
+	}
+	#endif
 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
 	grabbuttons(c, 0);
 	if (!c->isfloating)
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
 	if (c->isfloating)
 		XRaiseWindow(dpy, c->win);
+	#ifdef ATTACHASIDE
+	attachaside(c);
+	#else
 	attach(c);
+	#endif
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
 		(unsigned char *) &(c->win), 1);
@@ -1084,6 +1504,9 @@ manage(Window w, XWindowAttributes *wa)
 		unfocus(selmon->sel, 0);
 	c->mon->sel = c;
 	arrange(c->mon);
+	#ifdef ROUNDEDCORNERS
+	roundcorners(c, cornerradius);
+	#endif
 	XMapWindow(dpy, c->win);
 	focus(NULL);
 }
@@ -1103,6 +1526,14 @@ maprequest(XEvent *e)
 {
 	static XWindowAttributes wa;
 	XMapRequestEvent *ev = &e->xmaprequest;
+	#ifdef SYSTRAY
+	Client *i;
+	if ((i = wintosystrayicon(ev->window))) {
+		sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
+		resizebarwin(selmon);
+		updatesystray();
+	}
+	#endif
 
 	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
 		return;
@@ -1202,6 +1633,18 @@ movemouse(const Arg *arg)
 	}
 }
 
+#ifdef ATTACHASIDE
+Client *
+nexttagged(Client *c) {
+	Client *walked = c->mon->clients;
+	for(;
+		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
+		walked = walked->next
+	);
+	return walked;
+}
+#endif
+
 Client *
 nexttiled(Client *c)
 {
@@ -1225,6 +1668,19 @@ propertynotify(XEvent *e)
 	Window trans;
 	XPropertyEvent *ev = &e->xproperty;
 
+	#ifdef SYSTRAY
+	if ((c = wintosystrayicon(ev->window))) {
+		if (ev->atom == XA_WM_NORMAL_HINTS) {
+			updatesizehints(c);
+			updatesystrayicongeom(c, c->w, c->h);
+		}
+		else
+			updatesystrayiconstate(c, ev);
+		resizebarwin(selmon);
+		updatesystray();
+	}
+	#endif
+
 	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
 		updatestatus();
 	else if (ev->state == PropertyDelete)
@@ -1258,6 +1714,9 @@ propertynotify(XEvent *e)
 void
 quit(const Arg *arg)
 {
+	#ifdef RESTARTSIG
+	if(arg->i) restart = 1;
+	#endif
 	running = 0;
 }
 
@@ -1275,6 +1734,46 @@ recttomon(int x, int y, int w, int h)
 	return r;
 }
 
+#ifdef SYSTRAY
+void
+removesystrayicon(Client *i)
+{
+	Client **ii;
+
+	if (!showsystray || !i)
+		return;
+	for (ii = &systray->icons; *ii && *ii != i; ii = &(*ii)->next);
+	if (ii)
+		*ii = i->next;
+	free(i);
+}
+
+void
+resizebarwin(Monitor *m) {
+	unsigned int w = m->ww;
+	if (showsystray && m == systraytomon(m))
+		w -= getsystraywidth();
+	#if defined(BARPADDING)
+	XMoveResizeWindow(dpy, m->barwin, m->wx + sp, m->by + vp, w - 2 * sp, bh);	
+	#else
+	XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, w, bh);
+	#endif
+}
+
+void
+resizerequest(XEvent *e)
+{
+	XResizeRequestEvent *ev = &e->xresizerequest;
+	Client *i;
+
+	if ((i = wintosystrayicon(ev->window))) {
+		updatesystrayicongeom(i, ev->width, ev->height);
+		resizebarwin(selmon);
+		updatesystray();
+	}
+}
+#endif
+
 void
 resize(Client *c, int x, int y, int w, int h, int interact)
 {
@@ -1297,6 +1796,95 @@ resizeclient(Client *c, int x, int y, int w, int h)
 	XSync(dpy, False);
 }
 
+#ifdef ROUNDEDCORNERS
+void roundcorners(Client *ac, const unsigned int fs) {
+	xcb_connection_t *c;
+     	c = xcb_connect (NULL, NULL);
+	const xcb_query_extension_reply_t *shape_query;
+  	shape_query = xcb_get_extension_data(c, &xcb_shape_id);
+  	if (!shape_query->present)
+		return;
+
+	int32_t rad, dia;
+        rad = fs;
+        rad += ac->bw; dia = rad*2-1;
+
+	if(ac->w < dia || ac->h < dia)
+    		return;
+
+     	int ow  = ac->w+2*ac->bw;
+     	int oh  = ac->h+2*ac->bw;
+
+     	xcb_pixmap_t bpid = xcb_generate_id(c);
+      	xcb_pixmap_t cpid = xcb_generate_id(c);
+
+        xcb_create_pixmap(c, 1, bpid, ac->win, ow, oh);
+        xcb_create_pixmap(c, 1, cpid, ac->win, ac->w, ac->h);
+
+        xcb_gcontext_t black = xcb_generate_id(c);
+        xcb_gcontext_t white = xcb_generate_id(c);
+	xcb_create_gc(c, black, bpid, XCB_GC_FOREGROUND, (uint32_t[]){0, 0});
+        xcb_create_gc(c, white, bpid, XCB_GC_FOREGROUND, (uint32_t[]){1, 0});
+
+        xcb_arc_t barcs[] = {
+            { -1,     -1,     dia, dia, 0, 360 << 6 },
+            { -1,     oh-dia, dia, dia, 0, 360 << 6 },
+            { ow-dia, -1,     dia, dia, 0, 360 << 6 },
+            { ow-dia, oh-dia, dia, dia, 0, 360 << 6 },
+        };
+        xcb_rectangle_t brects[] = {
+            { rad, 0, ow-dia, oh },
+            { 0, rad, ow, oh-dia },
+        };
+
+        rad -= ac->bw; dia = rad*2-1;
+
+        xcb_arc_t carcs[] = {
+            { -1,    -1,    dia, dia, 0, 360 << 6 },
+            { -1,    ac->h-dia, dia, dia, 0, 360 << 6 },
+            { ac->w-dia, -1,    dia, dia, 0, 360 << 6 },
+            { ac->w-dia, ac->h-dia, dia, dia, 0, 360 << 6 },
+        };
+        xcb_rectangle_t crects[] = {
+            { rad, 0, ac->w-dia, ac->h },
+            { 0, rad, ac->w, ac->h-dia },
+        };
+	xcb_rectangle_t bounding = {0, 0, ow, oh};
+        xcb_poly_fill_rectangle(c, bpid, black, 1, &bounding);
+        xcb_poly_fill_rectangle(c, bpid, white, 2, brects);
+        xcb_poly_fill_arc(c, bpid, white, 4, barcs);
+
+        xcb_rectangle_t clipping = {0, 0, ac->w, ac->h};
+        xcb_poly_fill_rectangle(c, cpid, black, 1, &clipping);
+        xcb_poly_fill_rectangle(c, cpid, white, 2, crects);
+        xcb_poly_fill_arc(c, cpid, white, 4, carcs);
+
+        xcb_shape_mask(c, XCB_SHAPE_SO_SET, XCB_SHAPE_SK_BOUNDING, ac->win, -ac->bw, -ac->bw, bpid);
+        xcb_shape_mask(c, XCB_SHAPE_SO_SET, XCB_SHAPE_SK_CLIP, ac->win, 0, 0, cpid);
+
+	xcb_get_geometry_reply_t *geo = xcb_get_geometry_reply(c, xcb_get_geometry(c, ac->win), NULL);
+	if (geo == NULL)
+	{
+		free(geo);
+		xcb_free_pixmap(c, bpid);
+        	xcb_free_pixmap(c, cpid);
+		xcb_free_gc(c, bpid);
+		xcb_free_gc(c, cpid);
+		xcb_disconnect (c);
+		return;
+	}
+
+	xcb_shape_mask(c, XCB_SHAPE_SO_SET, XCB_SHAPE_SK_BOUNDING, ac->win, ac->x-geo->x, ac->y-geo->y, bpid);
+
+	free(geo);
+        xcb_free_pixmap(c, bpid);
+        xcb_free_pixmap(c, cpid);
+	xcb_free_gc(c, bpid);
+	xcb_free_gc(c, cpid);
+	xcb_disconnect (c);
+}
+#endif
+
 void
 resizemouse(const Arg *arg)
 {
@@ -1341,6 +1929,9 @@ resizemouse(const Arg *arg)
 			}
 			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
 				resize(c, c->x, c->y, nw, nh, 1);
+			#ifdef ROUNDEDCORNERS
+			roundcorners(c, cornerradius);
+			#endif
 			break;
 		}
 	} while (ev.type != ButtonRelease);
@@ -1352,6 +1943,9 @@ resizemouse(const Arg *arg)
 		selmon = m;
 		focus(NULL);
 	}
+	#ifdef ROUNDEDCORNERS
+	roundcorners(c, cornerradius);
+	#endif
 }
 
 void
@@ -1427,7 +2021,11 @@ sendmon(Client *c, Monitor *m)
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+	#ifdef ATTACHASIDE
+	attachaside(c);
+	#else
 	attach(c);
+	#endif
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
@@ -1443,26 +2041,62 @@ setclientstate(Client *c, long state)
 }
 
 int
+#ifdef SYSTRAY
+sendevent(Window w, Atom proto, int mask, long d0, long d1, long d2, long d3, long d4)
+#else
 sendevent(Client *c, Atom proto)
+#endif
 {
 	int n;
+	#ifdef SYSTRAY
+	Atom *protocols, mt;
+	#else
 	Atom *protocols;
+	#endif
 	int exists = 0;
 	XEvent ev;
 
+	#ifdef SYSTRAY
+	if (proto == wmatom[WMTakeFocus] || proto == wmatom[WMDelete]) {
+		mt = wmatom[WMProtocols];
+		if (XGetWMProtocols(dpy, w, &protocols, &n)) {
+			while (!exists && n--)
+				exists = protocols[n] == proto;
+			XFree(protocols);
+		}
+	}
+	else {
+		exists = True;
+		mt = proto;
+	#else
 	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
 		while (!exists && n--)
 			exists = protocols[n] == proto;
 		XFree(protocols);
+	#endif
 	}
 	if (exists) {
 		ev.type = ClientMessage;
+		#ifdef SYSTRAY
+		ev.xclient.window = w;
+		ev.xclient.message_type = mt;
+		#else
 		ev.xclient.window = c->win;
 		ev.xclient.message_type = wmatom[WMProtocols];
+		#endif
 		ev.xclient.format = 32;
+		#ifdef SYSTRAY
+		ev.xclient.data.l[0] = d0;
+		ev.xclient.data.l[1] = d1;
+		ev.xclient.data.l[2] = d2;
+		ev.xclient.data.l[3] = d3;
+		ev.xclient.data.l[4] = d4;
+		XSendEvent(dpy, w, False, mask, &ev);
+		#else
 		ev.xclient.data.l[0] = proto;
 		ev.xclient.data.l[1] = CurrentTime;
 		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
+		#endif
 	}
 	return exists;
 }
@@ -1476,7 +2110,11 @@ setfocus(Client *c)
 			XA_WINDOW, 32, PropModeReplace,
 			(unsigned char *) &(c->win), 1);
 	}
+	#ifdef SYSTRAY
+	sendevent(c->win, wmatom[WMTakeFocus], NoEventMask, wmatom[WMTakeFocus], CurrentTime, 0, 0, 0);
+	#else
 	sendevent(c, wmatom[WMTakeFocus]);
+	#endif
 }
 
 void
@@ -1491,6 +2129,9 @@ setfullscreen(Client *c, int fullscreen)
 		c->bw = 0;
 		c->isfloating = 1;
 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+		#ifdef ROUNDEDCORNERS
+		roundcorners(c, 0);
+		#endif
 		XRaiseWindow(dpy, c->win);
 	} else if (!fullscreen && c->isfullscreen){
 		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
@@ -1503,18 +2144,136 @@ setfullscreen(Client *c, int fullscreen)
 		c->w = c->oldw;
 		c->h = c->oldh;
 		resizeclient(c, c->x, c->y, c->w, c->h);
+		#ifdef ROUNDEDCORNERS
+		roundcorners(c, cornerradius);
+		#endif
 		arrange(c->mon);
 	}
 }
 
+#ifdef VANITYGAPS
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	enablegaps = !enablegaps;
+	arrange(selmon);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+#endif
+
 void
 setlayout(const Arg *arg)
 {
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+		#ifdef PERTAG
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+		#else
 		selmon->sellt ^= 1;
+		#endif
 	if (arg && arg->v)
+		#ifdef PERTAG
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+		#else
 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
-	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+		#endif
+	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof(selmon->ltsymbol) - 1);
 	if (selmon->sel)
 		arrange(selmon);
 	else
@@ -1532,7 +2291,11 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.05 || f > 0.95)
 		return;
+	#ifdef PERTAG
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+	#else
 	selmon->mfact = f;
+	#endif
 	arrange(selmon);
 }
 
@@ -1553,6 +2316,11 @@ setup(void)
 	/* clean up any zombies (inherited from .xinitrc etc) immediately */
 	while (waitpid(-1, NULL, WNOHANG) > 0);
 
+	#ifdef RESTARTSIG
+	signal(SIGHUP, sighup);
+	signal(SIGTERM, sigterm);
+	#endif
+
 	/* init screen */
 	screen = DefaultScreen(dpy);
 	sw = DisplayWidth(dpy, screen);
@@ -1564,6 +2332,10 @@ setup(void)
 	lrpad = drw->fonts->h;
 	bh = drw->fonts->h + 2;
 	updategeom();
+	#ifdef BARPADDING
+	sp = sidepad;
+	vp = (topbar == 1) ? vertpad : - vertpad;
+	#endif
 	/* init atoms */
 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
 	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
@@ -1572,6 +2344,15 @@ setup(void)
 	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
 	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
 	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+	#ifdef SYSTRAY
+	netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
+	netatom[NetSystemTrayOP] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_OPCODE", False);
+	netatom[NetSystemTrayOrientation] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION", False);
+	netatom[NetSystemTrayOrientationHorz] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION_HORZ", False);
+	xatom[Manager] = XInternAtom(dpy, "MANAGER", False);
+	xatom[Xembed] = XInternAtom(dpy, "_XEMBED", False);
+	xatom[XembedInfo] = XInternAtom(dpy, "_XEMBED_INFO", False);
+	#endif
 	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
@@ -1587,9 +2368,16 @@ setup(void)
 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
 	for (i = 0; i < LENGTH(colors); i++)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+	#ifdef SYSTRAY
+	/* init system tray */
+	updatesystray();
+	#endif
 	/* init bars */
 	updatebars();
 	updatestatus();
+	#ifdef BARPADDING
+	updatebarpos(selmon);
+	#endif
 	/* supporting window for NetWMCheck */
 	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
@@ -1644,6 +2432,22 @@ showhide(Client *c)
 	}
 }
 
+#ifdef RESTARTSIG
+void
+sighup(int unused)
+{
+	Arg a = {.i = 1};
+	quit(&a);
+}
+
+void
+sigterm(int unused)
+{
+	Arg a = {.i = 0};
+	quit(&a);
+}
+#endif
+
 void
 spawn(const Arg *arg)
 {
